---
title: Java变量的分类与自动类型转换
date: 2019-03-26 19:16:10
tags:	
	- Java
	- JavaSE
categories: JavaSE
---

# Java变量的分类与自动类型转换

## 变量的分类

| 类型                 | 从属于      | 内存位置                                                     | 声明位置                       | 生命周期                                                     |
| -------------------- | ----------- | ------------------------------------------------------------ | ------------------------------ | ------------------------------------------------------------ |
| 局部变量             | 方法/语句块 | 栈内存（方法被调用时都会创建一个栈帧，存储局部变量等)）（没有默认初始化） | 方法或者语句块内               | 从声明位置开始，直到方法或语句块执行完毕，局部变量消失       |
| 成员变量（实例变量） | 对象        | 堆内存（有默认初始化）                                       | 类内部，方法外部               | 对象创建，成员变量也跟着创建。对象消失，成员变量也跟着消失； |
| 静态变量（类变量）   | 类          | 方法区中的静态区（有默认初始化）                             | 类内部，方法外部。static修饰。 | 类被加载，静态变量就有效；类被卸载，静态变量就消失           |

### 局部变量（local variable）

方法或语句块内部定义的变量。生命周期是从声明位置开始到到方法或语句块执行完毕为止。局部变量在使用前**必须先声明、初始化(赋初值)再使用**。

### 成员变量（也叫实例变量 member variable）

方法外部、类的内部定义的变量。从属于对象，生命周期伴随对象始终。如果不自行初始化，它会自动初始化成该类型的默认初始值。

| 数据类型 | 默认初始值 |
| -------- | ---------- |
| int      | 0          |
| double   | 0.0        |
| char     | '\u0000'   |
| boolean  | false      |

### 静态变量（类变量 static variable）

 使用static定义。 从属于类，生命周期伴随类始终，从类加载到卸载。 如果不自行初始化，与成员变量相同会自动初始化成该类型的默认初始值，如上表所示。

```java
public class TestVariable{
	int a;//成员变量，从属于对象；成员变量会自动被初始化
	static int size; //静态变量，从属于类
	public static void main(String[] args) {
		{
			int age=18;//局部变量，从属于语句块
		}
		int salary=3000;//局部变量，从属于方法
		int i;//局部变量，必须初始化
		int j=i+5;//编译出错，变量i还未被初始化
	}
}
```



## 自动类型转换

1. 数据范围小的数据与数据范围大的数据进行数学计算时，自动向大范围的数据类型转换后计算。（例如int和long计算，则int类型先自动变为long类型，再计算）
2. 常量也有类型，常整数为int，常浮点数为double

```java
long a = 55555555;  //编译成功，在int表示的范围内(2.1e9内)。
long b = 55555555555;//不加L编译可通过，但是结果不正确，已经超过int表示的范围，数据溢出。
```

我们修改成long类型的常量即可

```java
long b = 55555555555L;
```

```java
public class Test02 {	
	public static void main(String[] args) {
			int microPerDay=24*60*60*1000;
			long nanosPerDay=24*60*60*1000*1000*1000L;
			System.out.print(nanosPerDay/microPerDay);
	}
}
```

输出：

```java
5794//显然溢出了
```

这是因为24\*60\*60\*1000\*1000数据已经溢出，需要修改如下

```java
long nanosPerDay=24L*60*60*1000*1000*1000;
```



此时第一个数就变成long类型，计算正确

```java
1000000//结果正确
```



```java
float f=(float)1.24;
float f=1.24f;
```

问：这两种赋值方式一样么？

答：不一样。

第一种方式，底层存储double类型，占8字节，再强制类型转换成float

第二种方式，底层 存储float类型，占4字节（推荐使用）



**注意事项**

byte,short,char参与运算的时候默认会转换成int类型，即使是统一数据类型相加也会转成int型

```java
	public static void main(String[] args) {
		byte b=10;
		byte c=10;//编译器会自动判断是否处于byte范围内。若属于，则编译通过
        short a=10;//同理
		byte d=b+c;//此处报错，Type mismatch: cannot convert from int to byte，b+c时候，自动转换成int类型
		short s=b;//此处没问题
	}
```

