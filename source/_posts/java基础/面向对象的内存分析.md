---
title: 面向对象的内存分析
date: 2019-04-02 10:42:44
tags:
	- JavaSE
	- Java
categories: JavaSE
---

****

# 一个类的初始化过程

## Student s = new Student();在内存中做了哪些事情?

1. 加载Student.class文件进内存【方法区】,并且创建对应的字节码文件
2. 在栈内存为s开辟空间
3. 在堆内存为学生对象开辟空间
4. 对学生对象的成员变量进行默认初始化//0,null,
5. 对学生对象的成员变量进行显示初始化`显示初始化的意思是，类定义的时候给成员变量赋了初值`例如：

```java
class Person {
    private String name="WJJ";//显示初始化
    private int age=18;//显示初始化
  	//构造函数即getXxx(),setXxxx()
}
```



6. 通过构造方法对学生对象的成员变量赋值

7. 学生对象初始化完毕，把对象地址赋值给s变量

**Java虚拟机的内存可以分为三个区域：栈stack、堆heap、方法区method area。***

# 栈的特点如下：

1. 栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧(存储局部变量、操作数、方法出口等)
2. JVM为每个线程创建一个栈，用于存放该线程执行方法的信息(实际参数、局部变量等)
3. 栈属于线程私有，不能实现线程间的共享!
4. 栈的存储特性是“先进后出，后进先出”
5. 栈是由系统自动分配，速度快!栈是一个连续的内存空间!

## 总结

关于栈和栈帧，我们做个小结：

- 每个JVM线程有一个私有栈，栈在线程创建的同时被创建。
- 栈由许多帧组成，也叫 “栈帧”
- 每次方法调用都会创建一个栈帧

换句话说，当一个Java/Scala/JVM方法被执行时：

- 当方法被执行时，一个新的栈帧被创建并用来给这个方法存储数据
- 栈帧大小各不相同，取决于方法的参数、局部变量和算法
- 当一个方法被执行时，程序只能访问当前栈帧中的数据，你能看到的只有栈顶的帧

{%asset_img 栈与栈帧2.png%}

## Java/JVM中栈的官方定义

**Oracle关于[栈和栈帧](https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html)提供了如下描述：**

> 每个JVM线程拥有一个私有的 Java虚拟机栈，创建线程的同时栈也被创建。一个JVM栈由许多帧组成，称之为"栈帧"。JVM中的栈和C等常见语言中的栈比较类似，都用于保存局部变量和部分计算结果，同时也参与方法调用和返回。

因此，你可以想象一下，一个栈拥有许多栈帧，如下图：

{% asset_img 栈与栈帧.png%}

如Oracle官方说明，每个线程拥有自己的私有栈，因此在多线程应用中将有多个栈，每个栈有自己的栈帧。

{%asset_img 栈与栈帧2.png%}

## Java中的栈

> 当一个新的线程创建时，JVM会为这个线程创建一个新的Stack。一个Java Stack在一个个独立的栈帧中存储了线程的状态。JVM只会在Java Stack中做两个操作：push 和 pop.

> 一个线程当前正在执行的方法称之为线程的 当前方法，当前方法对应的栈帧称为 当前帧，当前方法所属的类称为 当前类，当前类的常量池称为 当前常量池。 在执行一个方法时，JVM会保存当前类和当前常量池的轨迹。当JVM执行 需要操作栈帧中数据的指令时，JVM会在当前栈帧进行处理。

> 当一个线程执行一个Java方法时，JVM将创建一个新的栈帧并且把它push到栈顶。此时新的栈帧就变成了当前栈帧，方法执行时，使用栈帧来存储参数、局部变量、中间指令以及其他数据。

## Java中的栈帧

> 栈帧由三部分组成：局部变量表、操作数栈以及帧数据。

{%asset_img 栈帧.png%}

> 每个方法涉及的局部变量表和操作数栈的大小取决于每个具体的方法，但是大小在编译后便已确定，而且已经包含在class文件中。

**重要的是：栈帧的大小因局部变量表和操作数栈而异。书中对于size的描述如下：**

> 当JVM执行一个方法时，它会检查class中的数据，以便确定一个方法执行时在局部变量表和操作数栈中所需存储的word size。然后，JVM会为当前方法创建一个size相对应的栈帧，然后把它push到栈顶。

## Word size、操作数栈和常量池

简述下 word size、operand stack(操作数栈)、constant pool(常量池)这三个短语的定义：

- [word size](https://www.artima.com/insidejvm/ed2/jvm3.html)：它是一个度量单位，在不同类型的JVM中，word size的大小不一定会相同。但是，它至少会有32位以保证可以存储long或double类型。
- operand stack：操作数栈在 [oracle.com ](https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.6.2)中被定义。捎带提一嘴，其中的定义涉及到了机器代码，例如：它展示了使用iadd指令进行两个integer的加法操作。 欢迎你深入学习这些细节，但是我们这里只想让你简单知道：操作数栈只是栈帧中的一块内存区域。
- 常量池：Java运行时常量时在 [oracle.com ](https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5.5)中定义. 写道：**一个运行时常量池 … 包含了许多种常量，编译时的常见数值字面量、运行时需要处理的方法和字段引用等. 运行时常量池和一些编程语言中的符号表有点类似，只不过它比符号表存储的数据范围更广。**

# 堆的特点如下：

1. 堆用于存储创建好的对象和数组(数组也是对象)
2. JVM只有一个堆，被所有线程共享
3. 堆是一个不连续的内存空间，分配灵活，速度慢!

# 方法区(又叫静态区)特点如下：

1. JVM只有一个方法区，被所有线程共享!
2. 方法区实际也是堆，只是用于存储类、常量相关的信息!
3. 来存放程序中永远是不变或唯一的内容。(类信息【Class对象】、静态变量、字符串常量、静态、非静态方法等)

# 内存图解

```java
class Computer{
	String brand;//品牌
}
public class Stu{
	int id;
	String name;
	int age;
	Computer comp;
	void study() {
		System.out.println("我正在学习！使用电脑:"+comp.brand);
	}
	//构造方法
	Stu(){
	}
	public static void main(String[] args) {
		Stu stu1=new Stu();
		stu1.name="张三";
		Computer comp1=new Computer();
		comp1.brand="联想";
		stu1.comp=comp1;
		stu1.study();
	}
}
```

{%asset_img 内存分配图1.png%}

{%asset_img 内存分配图2.png%}





