---
title: 3.线程池
date: 2019-04-26 14:52:59
tags:
	- JavaSE
	- Java
categories: JavaSE
---

# 线程池

## 1 线程池思想概述

我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：

如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。

那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？

在Java中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下Java的线程池。

## 2. 线程池概念

- **线程池：**其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。

由于线程池中有很多操作都是与优化资源相关的，我们在这里就不多赘述。我们通过一张图来了解线程池的工作原理：

{%asset_img 线程池原理.bmp%}

合理利用线程池能够带来三个好处：

1. 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。
2. 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
3. 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。

## 3 线程池的使用

Java里面线程池的顶级接口是`java.util.concurrent.Executor`，但是严格意义上讲`Executor`并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是`java.util.concurrent.ExecutorService`。

要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在`java.util.concurrent.Executors`线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。

Executors类中有个创建线程池的方法如下：

- `public static ExecutorService newFixedThreadPool(int nThreads)`：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)

获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：

- `public Future<?> submit(Runnable task)`:获取线程池中的某一个线程对象，并执行

  > Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。

使用线程池中线程对象的步骤：

1. 创建线程池对象。
2. 创建Runnable接口子类对象。(task)
3. 提交Runnable接口子类对象。(take task)
4. 关闭线程池(一般不做)。

Runnable实现类代码：

```java
package pool;

public class MyRun implements Runnable {

    private int taskno;

    public MyRun(int taskno) {
        this.taskno = taskno;
    }

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+"正在执行"+taskno);
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName()+"完成任务"+taskno);
    }
}
```

线程池测试类：

```java
package pool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPool1 {
    public static void main(String[] args) {
        //1创建线程池对象。
        ExecutorService service= Executors.newFixedThreadPool(3);
        //下面这种方式不指定线程数量
        //ExecutorService service=Executors.newCachedThreadPool();
        //2创建Runnable接口子类对象。(task)
        MyRun t1=new MyRun(1);
        MyRun t2=new MyRun(2);
        MyRun t3=new MyRun(3);
        MyRun t4=new MyRun(4);
        //3提交Runnable接口子类对象。(take task)
     /*   service.execute(t1);
        service.execute(t2);
        service.execute(t3);
        service.execute(t4);*/
        service.submit(t1);
        service.submit(t2);
        service.submit(t3);
        service.submit(t4);
        //4关闭线程池(一般不做)。
        service.shutdown();
    }
}
```

结果：

```java
//ExecutorService service= Executors.newFixedThreadPool(3);
pool-1-thread-1正在执行1
pool-1-thread-3正在执行3
pool-1-thread-2正在执行2
pool-1-thread-3完成任务3
pool-1-thread-1完成任务1
pool-1-thread-2完成任务2
pool-1-thread-1正在执行4
pool-1-thread-1完成任务4
```

```java
 //ExecutorService service=Executors.newCachedThreadPool();
pool-1-thread-3正在执行3
pool-1-thread-1正在执行1
pool-1-thread-2正在执行2
pool-1-thread-4正在执行4//有线程4
pool-1-thread-3完成任务3
pool-1-thread-4完成任务4
pool-1-thread-1完成任务1
pool-1-thread-2完成任务2
```

# 4 使用Callable<>

MyCall:传入一个数，计算从1加到该数的和

```java
package pool;

import java.util.concurrent.Callable;

public class MyCall implements Callable<Integer> {
    int num;

    public MyCall(int num) {
        this.num = num;
    }

    @Override
    public Integer call() throws Exception {
        System.out.println(Thread.currentThread().getName()+"正在执行任务");
        int sum=0;
        for(int i=0;i<=num;i++){
            sum+=i;
        }
        Thread.sleep(1000);
        return sum;
    }
}
```

```java
package pool;

import java.util.concurrent.*;

public class PoolDemo2 {
    public static void main(String[] args) throws ExecutionException, InterruptedException, TimeoutException {
       // ExecutorService service= Executors.newCachedThreadPool();
        ExecutorService service=Executors.newFixedThreadPool(3);
        MyCall c1=new MyCall(5);
        MyCall c2=new MyCall(6);
        MyCall c3=new MyCall(7);
        MyCall c4=new MyCall(8);
        Future<Integer> result1 = service.submit(c1);
        Future<Integer> result2 = service.submit(c2);
        Future<Integer> result3 = service.submit(c3);
        Future<Integer> result4 = service.submit(c4);

        int num1=result1.get();//等待计算完成，然后检索其结果。阻塞线程，等待返回计算结果
        int num2=result2.get();
        int num3=result3.get(3,TimeUnit.SECONDS);
        int num4=result4.get(1000, TimeUnit.MILLISECONDS);//如果需要等待最多在给定的时间计算完成，然后检索其结果（如果可用）。 
        System.out.println("num4 = " + num4);
        System.out.println("num3 = " + num3);
        System.out.println("num2 = " + num2);
        System.out.println("num1 = " + num1);
        service.shutdown();

    }
}
```

```java
pool-1-thread-3正在执行任务
pool-1-thread-1正在执行任务
pool-1-thread-2正在执行任务
pool-1-thread-3正在执行任务
num4 = 36
num3 = 28
num2 = 21
num1 = 15
```

