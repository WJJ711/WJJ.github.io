---
title: 15.类加载器
date: 2019-04-30 22:49:18
tags:
	- JavaSE
	- Java
categories: JavaSE
---

# 第一章 类加载器的作用

##  类加载器的作用

*  将class文件字节码内容加载到内存中，并将这些静态数据转换成方法
  区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class
  对象，作为方法区类数据的访问入口。

## 类缓存

*  标准的Java SE类加载器可以按要求查找类，但一旦某个类被加载到类加载
  器中，它将维持加载（缓存）一段时间。不过，JVM垃圾收集器可以回收
  这些Class对象。

# 第二章： java.class.ClassLoader类

## 作用

*  java.lang.ClassLoader类的基本职责就是根据一个指定的类的名称，
  找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个
  Java 类，即 java.lang.Class类的一个实例。
* 除此之外，ClassLoader还负责加载 Java 应用所需的资源，如图像文
  件和配置文件等。

## 相关方法

* `getParent() `返回该类加载器的父类加载器。
* `loadClass(String name)` 加载名称为 name的类，返回的结果是`java.lang.Class`类的实例。
  * 此方法负责加载指定名字的类，首先会从已加载的类中去寻找，如果没有找到；从`parent ClassLoader[ExtClassLoader]`中加载；如果没有加载到，则从`Bootstrap ClassLoader`中尝试加载(`findBootstrapClassOrNull`方法), 如果还是加载失败，则自己加载。如果还不能加载，则抛出异常`ClassNotFoundException`。
  * 如果要改变类的加载顺序可以覆盖此方法
* `findClass(String name) `查找名称为 name的类，返回的结果是`java.lang.Class`类的实例。
* `findLoadedClass(String name) `查找名称为 name的已经被加载过的类，返回的结果是` java.lang.Class`类的实例。
* `defineClass(String name, byte[] b, int off, int len) `把字节数组 b中的内容转换成 Java 类，返回的结果是`java.lang.Class`类的实例。这个方法被声明为 final的。
* `resolveClass(Class<?> c) `链接指定的 Java 类。
* 对于以上给出的方法，表示类名称的 name参数的值是类的二进制名称。需要注意的是内部类的表示，如com.example.Sample$1和com.example.Sample$Inner等表示方式

# 第三章 类加载器的层次结构

## 引导类加载器（`bootstrap class loader`）

* 它用来加载 Java 的核心库`(JAVA_HOME/jre/lib/rt.jar`,或`sun.boot.class.path`路径下的内容)，是用原生代码来实现的，并不继承自 `java.lang.ClassLoader`。

* 加载扩展类和应用程序类加载器。并指定他们的父类加载器。

## 扩展类加载器（`extensions class loader`）

* 用来加载 Java 的扩展库(`JAVA_HOME/jre/ext/*.jar`，或`java.ext.dirs`路径下的内容) 。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java类。
* 由`sun.misc.Launcher$ExtClassLoade`r实现

## 应用程序类加载器（`application class loader`）
  * 它根据 Java 应用的类路径（`classpath，java.class.path` 路径下的内容）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的
  * 由`sun.misc.Launcher$AppClassLoader`实现
## 自定义类加载器
  * 开发人员可以通过继承 `java.lang.ClassLoader`类的方式
    实现自己的类加载器，以满足一些特殊的需求。

![类加载器结构](D:\blog\WJJ711\source\_posts\15-类加载器\类加载器结构.png)

{%asset_img 类加载器结构.png%}

# 第四章 类加载器的代理模式

## 代理模式

*  交给其他加载器来加载指定的类

## 双亲委托机制

* 就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委
  托给父类加载器，依次追溯，直到最高的爷爷辈的，如果父类加载器
  可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载
  任务时，才自己去加载。
*  双亲委托机制是为了保证 Java 核心库的类型安全。
  * **这种机制就保证不会出现用户自己能定义`java.lang.Object`类的情况。**
* 类加载器除了用于加载类，也是安全的最基本的屏障。
* 双亲委托机制是代理模式的一种
  * 并不是所有的类加载器都采用双亲委托机制。
  * tomcat服务器类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的

# 第五章 自定义类加载器

## 流程

1. 继承`java.lang.ClassLoader`
2. 首先检查请求的类型是否已经被这个类装载器装载到命名空间中了，如果已经装载，直接返回；否则转入步骤3
3. 委派类加载请求给父类加载器（更准确的说应该是双亲类加载器，虚拟机中各种类加载器最终会呈现树状结构），如果父类加载器能够完成，则返回父类加载器加载的Class实例；否则转入步骤4
4. 调用本类加载器的findClass（…）方法，试图获取对应的字节码，如果获取的到，则调用defineClass（…）导入类型到方法区；如
   果获取不到对应的字节码或者其他原因失败，返回异常给loadClass（…）， loadClass（…）转抛异常，终止加载过程（注意：这里的异常种类不止一种）。

**注意：被两个类加载器加载的同一个类， JVM不认为是相同的类**

# 自定义文件加载系统

## Test

```java
package classload;

/**
 * 测试自定义的FileSystemClassLoader
 */
public class Test {
    public static void main(String[] args) throws Exception {
        String path="D:/Myjava/classloader";
        FileSystemClassLoader loader=new FileSystemClassLoader(path);
        FileSystemClassLoader loader2 = new FileSystemClassLoader(path);

        Class<?> c = loader.loadClass("HelloWorld");
        Class<?> c2 = loader.loadClass("HelloWorld");
        Class<?> c3 = loader2.loadClass("HelloWorld");

        Class<?> c4 = loader2.loadClass("classload.Test");
        Class<?> c5 = loader2.loadClass("java.lang.String");

        System.out.println(c);//class HelloWorld
        System.out.println(c.hashCode());//745160567
        System.out.println(c2.hashCode());//745160567
        System.out.println(c3.hashCode());//610984013,被两个类加载器加载的同一个类， JVM不认为是相同的类。
        System.out.println(c4.hashCode());//997110508系统默认类加载器

        //自定义类加载器
        System.out.println(c3.getClassLoader());//classload.FileSystemClassLoader@7a79be86
        //系统默认类加载器
        System.out.println(c4.getClassLoader());//jdk.internal.loader.ClassLoaders$AppClassLoader@2437c6dc
        //引导类加载器
        System.out.println(c5.getClassLoader());//null
    }
}
```

## FileSystemClassLoader

```java
package classload;

import java.io.*;

/**
 * 自定义文件系统类加载器

*/
public class FileSystemClassLoader extends ClassLoader {
    private String rootDir;

    public FileSystemClassLoader(String rootDir) {
        this.rootDir = rootDir;
    }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        Class<?> c = findLoadedClass(name);
        //应该要先查询有没有加载过这个类。如果已经加载，则直接返回加载好的类，如果没有，则加载新的类
        if(c!=null){
            return c;
        }else {
            ClassLoader parent=this.getParent();
            try{
                c=parent.loadClass(name);//委派给父类加载
            }catch (Exception e){
            }


            if(c!=null){
                return c;
            }else {//如果父类没有加载，则自己加载
                byte[] classData=getClassData(name);
                if(classData==null){
                    throw new ClassNotFoundException();
                }else{
                    c=defineClass(name,classData,0,classData.length);
                }
            }
        }
        return c;
    }

    private byte[] getClassData(String classname) {
        String path=rootDir+"/"+classname.replace('.','/')+".class";
        InputStream is=null;
        ByteArrayOutputStream baos=new ByteArrayOutputStream();
        try {
            is=new FileInputStream(path);
            byte[] buffer=new byte[1024];
            int len=0;
            while ((len=is.read(buffer))!=-1){
                baos.write(buffer,0,len);
            }
            return baos.toByteArray();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if(is!=null){
                try {
                    is.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        return null;
    }

}
```

# 自定义加密解密类加载器

## 测试

```java
package classload;

public class Demo04 {
    public static void main(String[] args) throws ClassNotFoundException {
        //加密后的class文件，正常的类加载器无法加载，报classFormatError
       /* FileSystemClassLoader loader=new FileSystemClassLoader("D:/Myjava/classloader/temp");
        Class<?> c = loader.loadClass("HelloWorld");
        System.out.println(c);*/
        
       DecryptClassLoader loader=new DecryptClassLoader("D:/Myjava/classloader/temp");
       Class<?> c = loader.loadClass("HelloWorld");
        System.out.println(c);
    }
}
```

## 加密工具类

```java
package classload;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

/**
 * 加密工具类
 */
public class EncryptUtil {
    public static void main(String[] args) {
        encrypt("D:/Myjava/classloader/HelloWorld.class","D:/Myjava/classloader/temp/HelloWorld.class");
    }
    public static void encrypt(String src,String dest){
        FileInputStream fis=null;
        FileOutputStream fos=null;
        try {
            fis=new FileInputStream(src);
            fos=new FileOutputStream(dest);
            int temp=-1;
            while ((temp=fis.read())!=-1){
                fos.write(temp^0xff);//取反操作
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if(fis!=null){
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(fos!=null){
                try {
                    fos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

## 解密类加载器

```java
package classload;

import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

/**
 * 加载文件系统中加密后的class字节码的类加载器
 */

public class DecryptClassLoader extends ClassLoader {
    private String rootDir;

    public DecryptClassLoader(String rootDir) {
        this.rootDir = rootDir;
    }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        Class<?> c = findLoadedClass(name);

        //应该要先查询有没有加载过这个类，如果已经加载，则直接返回加载好的类，如果没有，则加载新的类
        if(c!=null){
            return c;
        }else {
            ClassLoader parent = this.getParent();
            try{
                c=parent.loadClass(name);//委派给父类加载
            }catch (Exception e){

            }
            if(c!=null){
                return c;
            }else {
                byte[] classDatas=getBytes(name);
                c = defineClass(name, classDatas, 0, classDatas.length);
                return c;
            }
        }

    }
    private byte[] getBytes(String name){
        String path=rootDir+"/"+name.replace(",","/")+".class";
        FileInputStream is=null;
        ByteArrayOutputStream baos=new ByteArrayOutputStream();
        try {
            is=new FileInputStream(path);
            int temp=-1;
            while ((temp=is.read())!=-1){
                baos.write(temp^0xff);
            }
            baos.flush();
            return baos.toByteArray();

        } catch (FileNotFoundException e) {
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if(is!=null){
                try {
                    is.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        return null;
    }
}
```

