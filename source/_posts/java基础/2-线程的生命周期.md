---
title: 2.线程的生命周期
date: 2019-04-25 15:28:09
tags:
	- JavaSE
	- Java
categories: JavaSE
---

当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，
有几种状态呢？在API中 java.lang.Thread.State 这个枚举中给出了六种线程状态：

{%asset_img 6种线程状态.png%}

# 1.Timed Waiting （计时等待)

Timed Waiting在API中的描述为：正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。单独
的去理解这句话，真是玄之又玄，其实我们在之前的操作中已经接触过这个状态了，在哪里呢？
在我们写卖票的案例中，为了模拟网络延时，在run方法中添加了sleep语句，这样就强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。
其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting(计时等
待)。

通过案例可以发现， sleep方法的使用还是很简单的。我们需要记住下面几点：
1. 进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协
    作关系。

2. 为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程
    中会睡眠

3. sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态。

  > 小提示：sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始立刻执行。还要看到它有没有抢到CPU的时间片

  Timed Waiting 线程状态图：

  {%asset_img TimedWaiting.png%}

# 2.BLOCKED （锁阻塞）

Blocked 状态在API中的介绍为：被阻塞等待监视器锁定的线程处于此状态。
学完同步机制，那么这个状态是非常好理解的了。比如，线程A与线程B代码中使用同一锁，如果线程A获
取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。
这是由Runnable状态进入Blocked状态。除此以外Waiting以及Time Waiting状态也会在某种情况下进入阻塞状态

{%asset_img Blocked.png%}

# 3 Waiting （无限等待）

Wating状态在API中介绍为：正在等待另一个线程执行特定动作的线程处于此状态。

一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的
Object.notify()方法 或 Object.notifyAll()方法。
其实waiting状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系，
多个线程会争取锁，同时相互之间又存在协作关系。
当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入
了Waiting（无限等待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用了
notify()方法，那么就会将无限等待的A线程唤醒。注意是唤醒，如果获取到锁对象，那么A线程唤醒后就进入
Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）。

{%asset_img Waiting.png%}

# 4.综上

{%asset_img 线程生命图.png%}

{%asset_img 线程生命周期图2.png%}