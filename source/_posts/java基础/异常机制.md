---
title: 异常机制Exception
date: 2019-04-11 11:45:18
tags: 
	- Java
	- JavaSE
categories: JavaSE
---

***世界上最真情的相依,是你在try我在catch,无论你发神马脾气,我都默默接受,静静处理***

# 异常机制的本质

***就是当程序出现错误，程序安全退出的机制。***

# JVM的默认处理

1. jvm发现运算是已经违反了数学运算规则,java将这种常见的问题进行描述,并封装成了对象叫做ArithmeticException

2. 当除0运算发生后,jvm将该问题打包成了一个异常对象.

3. 并将对象抛给调用者main函数,new ArithmeticException("/by zero");

4. main函数收到这个问题时,有两种处理方式:

   1,自己将该问题处理,然后继续运行

   2,自己没有针对的处理方式,只有交给调用main的jvm来处理

**JVM有一个默认的异常处理机制,就将该异常进行处理.并将该异常的名称,异常的信息.异常出现的位置打印在了控制台上**

**同时将程序停止运行**



# 异常分类

{%asset_img Java异常类层次结构图.png%}



##　**Error**

​      Error是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM(Java 虚拟机)出现的问题。例如，Java虚拟机运行错误(Virtual Machine　Error)，当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机(JVM)一般会选择线程终止。

​      Error表明系统JVM已经处于不可恢复的崩溃状态中。我们不需要管它。

##　**Exception**

  Exception是程序本身能够处理的异常，如：空指针异(NullPointerException)、数组下标越界异常(ArrayIndexOutOfBoundsException)、类型转换异常(ClassCastException)、算术异常(ArithmeticException)等。

​      Exception类是所有异常类的父类，其子类对应了各种各样可能出现的异常事件。 通常Java的异常可分为：

​      1. RuntimeException 运行时异常——（这种情况一般都是代码不够严谨，所以推荐修改代码逻辑解决）

​      2. CheckedException 已检查异常

## **Error与Exception的区别**

1. 我在开车之前要检查一下车有没有问题。如果有问题，则是CheckedException 已检查异常
2. 我开着车走在路上，一头猪冲在路中间，我刹车。这叫一个RuntimeException 运行时异常。

3. 我开着车在路上，发动机坏了，我停车，这叫错误。系统处于不可恢复的崩溃状态。发动机什么时候坏?我们普通司机能管吗?不能。发动机什么时候坏是汽车厂发动机制造商的事。

## **Java是采用面向对象的方式来处理异常的。处理过程：**

   1. **抛出异常：**在执行一个方法时，如果发生异常，则这个方法生成代表该异常的一个对象，停止当前执行路径，并把异常对象提交给JRE。

      `throws`

2. **捕获异常：**JRE得到该异常后，寻找相应的代码来处理该异常。JRE在方法的调用栈中查找，从生成异常的方法开始回溯，直到找到相应的异常处理代码为止。基本格式：try是检测异常,catch是用来捕获异常的,finally是用来结束资源的

​	`try...catch...finally`

#  **异常的处理方式之一：捕获异常**

```java
try{
    //语句
}catch(异常类型 异常名){
	//处理
}finally{
    
}
```

**注意事项**

1. try里面代码越少越好，最好只有可能发生异常的代码
2. 当异常处理的代码执行结束以后，不会回到try语句去执行尚未执行的代码
3. 如果发生了异常，异常对象会依次和catch语句进行匹配，如果匹配到了，就执行相应的catch语句，如果没有，则异常不会得到处理

##　**上面过程详细解析：**

**1. try：**

​      try语句指定了一段代码，该段代码就是异常捕获并处理的范围。在执行过程中，当任意一条语句产生异常时，就会跳过该条语句中后面的代码。代码中可能会产生并抛出一种或几种类型的异常对象，它后面的catch语句要分别对这些异常做相应的处理。

​      一个try语句必须带有至少一个catch语句块或一个finally语句块 。

**注意事项**

​      当异常处理的代码执行结束以后，不会回到try语句去执行尚未执行的代码。

**2. catch：**

​      n-每个try语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常对象。

​      n-常用方法，这些方法均继承自Throwable类 。

​          u-toString ()方法，显示异常的类名和产生异常的原因

​          u-getMessage()方法，只显示产生异常的原因，但不显示类名。

​          u-printStackTrace()方法，用来跟踪异常事件发生时堆栈的内容。

​      n-catch捕获异常时的捕获顺序：

​          u-如果异常类之间有继承关系，在顺序安排上需注意。越是顶层的类，越放在下面，再不然就直接把多余的catch省略掉。 也就是先捕获子类异常再捕获父类异常。

**2. finally：**

finally的作用

•用于释放资源，在IO流操作和数据库操作中会见到

​      n-有些语句，不管是否发生了异常，都必须要执行，那么就可以把这样的语句放到finally语句块中。

​      n-通常在finally中关闭程序块已打开的资源，比如：关闭文件流、释放数据库连接等。

**try-catch-finally语句块的执行过程：**

​      try-catch-finally程序块的执行流程以及执行结果比较复杂。

​      基本执行过程如下：

​      程序首先执行可能发生异常的try语句块。如果try语句没有出现异常则执行完后跳至finally语句块执行;如果try语句出现异常，则中断执行并根据发生的异常类型跳至相应的catch语句块执行处理。catch语句块可以有多个，分别捕获不同类型的异常。catch语句块执行完后程序会继续执行finally语句块。finally语句是可选的，如果有的话，则不管是否发生异常，finally语句都会被执行。

**注意事项**

​    1. 即使try和catch块中存在return语句，finally语句也会执行。是在执行完finally语句后再通过return退出。

​    2. finally语句块只有一种情况是不会执行的，那就是在执行finally之前遇到了System.exit(0)结束程序运行。

# **异常的处理方式之二：声明异常(throws子句)**

1. 当CheckedException产生时，不一定立刻处理它，可以再把异常throws出去。

2. 在方法中使用try-catch-finally是由这个方法来处理异常。但是在一些情况下，当前方法并不需要处理发生的异常，而是向上传递给调用它的方法处理。

3. 如果一个方法中可能产生某种异常，但是并不能确定如何处理这种异常，则应根据异常规范在方法的首部声明该方法可能抛出的异常。

4. 如果一个方法抛出多个已检查异常，就必须在方法的首部列出所有的异常，之间以逗号隔开。

## **注意事项**

​      1. 方法重写中声明异常原则：子类重写父类方法时，如果父类方法有声明异常，那么子类声明的异常范围不能超过父类声明的范围。

# **RuntimeException运行时异常**

​    派生于RuntimeException的异常，如被 0 除、数组下标越界、空指针等，其产生比较频繁，处理麻烦，如果显式的声明或捕获将会对程序可读性和运行效率影响很大。 因此由系统自动检测并将它们交给缺省的异常处理程序(用户可不必对其处理)。

   这类异常通常是由编程错误导致的，所以在编写程序时，并不要求必须使用异常处理机制来处理这类异常,经常需要**通过增加“逻辑处理来避免这些异常”**

1. **ArithmeticException异常：试图除以0**
2. **NullPointerException异常**
3. **ClassCastException异常**
4. **ArrayIndexOutOfBoundsException异常**
5. **NumberFormatException异常**

##　**注意事项**

​      1. 在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器(exception handler)。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。

2. 运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而**未找到**合适的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。

# **CheckedException已检查异常**

所有不是RuntimeException的异常，统称为Checked Exception，又被称为“已检查异常”，如IOException、SQLException等以及用户自定义的Exception异常。 这类异常在编译时就必须做出处理，否则无法通过编译。

![异常体系](D:\blog\WJJ711\source\_posts\异常机制\异常体系.png

# 抛出异常throw

在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。

在java中，提供了一个**throw**关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？

1. 创建一个异常对象。封装一些提示信息(信息可以自己编写)。

2. 需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。

   throw**用在方法内**，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。

**使用格式：**

```
throw new 异常类名(参数);
```

 例如：

```java
throw new NullPointerException("要访问的arr数组不存在");

throw new ArrayIndexOutOfBoundsException("该索引在数组中不存在，已超出范围");
```

通过下面程序演示下throw的使用。

```java
public class ThrowDemo {
    public static void main(String[] args) {
        //创建一个数组 
        int[] arr = {2,4,52,2};
        //根据索引找对应的元素 
        int index = 4;
        int element = getElement(arr, index);

        System.out.println(element);
        System.out.println("over");
    }
    /*
     * 根据 索引找到数组中对应的元素
     */
    public static int getElement(int[] arr,int index){ 
       	//判断  索引是否越界
        if(index<0 || index>arr.length-1){
             /*
             判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。
             这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 
              */
             throw new ArrayIndexOutOfBoundsException("角标越界了~~~");
        }
        int element = arr[index];
        return element;
    }
}
```

> 注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。
>
> 那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。

# 自定义异常

1. 在程序中，可能会遇到JDK提供的任何标准异常类都无法充分描述清楚我们想要表达的问题，这种情况下可以创建自己的异常类，即自定义异常类。

2. 自定义异常类只需从Exception类或者它的子类派生一个子类即可。

3. 自定义异常类如果继承Exception类，则为受检查异常，必须对其进行处理;如果不想处理，可以让自定义异常类继承运行时异常RuntimeException类。

4. 习惯上，自定义异常类应该包含2个构造器：一个是默认的构造器，另一个是带有详细信息的构造器。

**异常类如何定义:**

1. 自定义一个编译期异常: 自定义类 并继承于`Exception`。

2. 自定义一个运行时期的异常类:自定义类 并继承于`RuntimeException`。 

3. 提供构造方法：一个无参的，一个有参的

   ```java
     public MyException() {//一个无参的
       }
   
       public MyException(String message) {
           super(message);//一个有参的
       }
   ```

```java
public class Test{
    public static void main(String[] args)  {
        Scanner scanner=new Scanner(System.in);
        int score=scanner.nextInt();
        try {

            check(score);
        }catch (Exception e){
            e.printStackTrace();
        }
        System.out.println("over");


    }
    public  static void check(int score)  {
        if(score<0||score>100)
            throw new MyException("分数不合理~");
    }
}
class MyException extends RuntimeException{
    public MyException() {
    }

    public MyException(String message) {
        super(message);
    }
}
```

输出结果

```java
输入：120
casual.MyException: 分数不合理~
	at casual.Test.check(Test.java:21)
	at casual.Test.main(Test.java:11)
over
```



# 异常注意事项

**均是指编译时异常**

1. 子类重写父类方法时，子类不能抛出父类没有的异常
2. 如果被重写的方法没有异常抛出,那么子类的方法绝对不可以抛出异常,如果子类方法内有异常发生,那么子类只能try,不能throws

因为多态，父类引用指向子类对象。所以**子类只能比父类好！**

# 面试题

```java
package casual;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;

public class Test {
    public static void main(String[] args) {
        int result=f();
        System.out.println(result);
    }
    public static int f(){
        String s="2019-04-11";
        DateFormat sdf = new SimpleDateFormat("yyyy/MM/dd");
        int result=10;
        try {
            Date date=sdf.parse(s);
        }catch (Exception e){
            result=30;
            return result;//返回这条，但是finally也会被执行，result返回值不会改
        }finally {
            System.out.println("我一定会被执行");
            result=40;
            //return result;//如果在finally里有返回，则返回这个，结果为40
        }

        return result;
    }

}
```

结果是：

```java
我一定会被执行
30
```

# **使用异常机制的建议**

​      1.要避免使用异常处理代替错误处理，这样会降低程序的清晰性，并且效率低下。

​      2.处理异常不可以代替简单测试---只在异常情况下使用异常机制。

​      3.不要进行小粒度的异常处理---应该将整个任务包装在一个try语句块中。

​      4.异常往往在高层处理