---
title: 12.反射机制
date: 2019-04-29 21:01:06
tags:
	- JavaSE
	- Java
categories: JavaSE
---

# 第一章 反射

```java 
对象是表示或封装一些数据，一个类被加载后，JVM会创建一个对应该类的Class对象，类的整个结构信息会放到对应的Class对象中。
这个Class对象就像一面镜子一样，通过这面镜子我可以看到该类的全部信息
```

JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。

加载完类之后，在堆内存中，就产生了一个 Class 类型的对象（一个类只有一个 Class 对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。

要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类对象。从而得到其中的方法或成员.所以先要获取到每一个字节码文件对应的Class类型的对象.

# 第二章Class类

 java.lang.Class类十分特殊，用来表示java中类型(class/interface/enum/annotation/primitive type/void)本身。

* Class类的对象包含了某个被加载类的结构。一个被加载的类对应一个Class对象。
* 当一个class被加载，或当加载器（class loader）的defineClass()被JVM调用，JVM 便自动产生一个Class 对象。

• Class类是Reflection的根源。

* 针对任何您想动态加载、运行的类，唯有先获得相应的Class 对象

## 获取Class类型的对象

**三种获取Class对象的方式**

1. 方式一

   ```java
   Person p = new Person();
   
   Class c = p.getClass();
   ```

2. 方式二

   ```java
   Class c2 = Person.class;
   ```

     任意数据类型都具备一个class静态属性,看上去要比第一种方式简单.

3. 将类名作为字符串传递给Class类中的静态方法forName即可

   ```java
   Class c3 = Class.forName("包名.类名");//最常用
   ```

   

   第三种和前两种的区别  

   前两种你必须明确Person类型.

   后面是你给我这种类型的字符串就行.这种扩展更强.我不需要知道你的类.我只提供字符串,按照配置文件加载就可以了

   ```java
   package reflection;
   
   public class Demo01 {
       public static void main(String[] args) throws ClassNotFoundException {
           String path="reflection.User";
           Class<?> clazz = Class.forName(path);
           //对象是表示或封装一些数据，一个类被加载后，JVM会创建一个对应该类的Class对象，类的整个结构信息会放到对应的Class对象中。
           //这个Class对象就像一面镜子一样，通过这面镜子我可以看到该类的全部信息
           System.out.println(clazz.hashCode());//509886383
           Class<?> clazz2 = Class.forName(path);
           System.out.println(clazz2==clazz);//true
   
           Class<String> strClazz = String.class;
           Class<? extends String> strClazz2 = path.getClass();
           //String类型共享一个Class对象
           System.out.println(strClazz==strClazz2);//true,同一类型共享同一个Class对象
   
           Class<Integer> intClazz = int.class;
           int[] arr01=new int[10];
           int[] arr02=new int[30];
           int[][] arr03=new int[30][];
           double[] arr04=new double[10];
           System.out.println(arr01.hashCode());//1854778591
           System.out.println(arr02.hashCode());//2054798982
           //同一类型的对象共享一个Class对象所以，int[]类型的共享一个Class对象
           System.out.println(arr01.getClass().hashCode());//885951223
           System.out.println(arr02.getClass().hashCode());//885951223
           System.out.println(arr03.getClass().hashCode());//191382150
           System.out.println(arr04.getClass().hashCode());//142666848
       }
   }
   ```

   

# 应用反射的API，获取类的信息(类的名字、属性、方法、构造器等)

```java
package reflection;

import jdk.swing.interop.SwingInterOpUtils;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class Demo02 {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException {
        String path="reflection.User";
        Class<?> clazz = Class.forName(path);//获取类对象

        //获取类的名字
        System.out.println(clazz.getName());//reflection.User
        System.out.println(clazz.getSimpleName());//User

        //获取属性的信息
        //Field[] fields = clazz.getFields();//只能获取public的field
        Field[] fields = clazz.getDeclaredFields();//获取所有的field
        System.out.println(fields.length);//3
        for (Field f:fields){       //private int reflection.User.id
            System.out.println(f);  //private int reflection.User.age
        }                           //private java.lang.String reflection.User.name

        //获取方法的信息
        System.out.println("-------------------------");
        Method[] methods = clazz.getDeclaredMethods();
        //如果方法无参，则传递null
        Method m01=clazz.getDeclaredMethod("getName");
        System.out.println(m01);
        //如果方法有参，则必须传递参数类型对应的class对象
        Method m02 = clazz.getDeclaredMethod("setName", String.class);
        for (Method m:methods){
            System.out.println(m);
        }

        //获取构造器信息
        System.out.println("--------------------------------");
        Constructor<?>[] constructors = clazz.getDeclaredConstructors();
        Constructor c=clazz.getConstructor(int.class,int.class,String.class);
        System.out.println(c);
        for (Constructor temp:constructors){
            System.out.println(temp);
        }

    }
}
```



```java
package reflection;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class Demo03 {
    public static void main(String[] args) throws Exception {
        String path="reflection.User";
        //获取Class对象
        Class<User> clazz = (Class<User>)Class.forName(path);

        //通过反射API调用构造方法，构造对象已过时
        //可以替换
        //   clazz.getDeclaredConstructor().newInstance()
       // User u = ((User) clazz.newInstance());//其实是调用了User的无参构造方法
        Constructor<?> c1 = clazz.getDeclaredConstructor();
        User u = ((User) c1.newInstance());
        System.out.println(u);//User{id=0, age=0, name='null'}

        System.out.println("------------------------");
        //通过反射API调用构造方法，构造对象
        Constructor<User> c = clazz.getDeclaredConstructor(int.class, int.class, String.class);
        User u2 = c.newInstance(100, 18, "wjj2");
        System.out.println(u2);//User{id=100, age=18, name='wjj2'}
        System.out.println(u2.getName());//wjj2

        System.out.println("------------------------------");
        //通过反射API调用普通方法
        User u3 = clazz.getDeclaredConstructor().newInstance();
        Method setNameClass = clazz.getDeclaredMethod("setName", String.class);
        setNameClass.invoke(u3,"wjj3");
       // u3.setName("wjj3");//等价于，但是用上面的如果要调用别的方法，只需要改变字符串，如setAge，方法不需要变
        System.out.println(u3);//User{id=0, age=0, name='wjj3'}

        System.out.println("-------------------------");
        //通过反射API操作属性
        User u4 = clazz.getDeclaredConstructor().newInstance();
        Field nameClass = clazz.getDeclaredField("name");
        nameClass.setAccessible(true);//这个属性不需要做安全检查，可以直接访问
        nameClass.set(u4,"wjj4");//通过反射直接写属性
        System.out.println(nameClass.get(u4));//通过反射直接读属性的值
        System.out.println(u4.getName());//通过对象获取
        System.out.println(u4);//User{id=0, age=0, name='wjj4'}

    }
}
```

