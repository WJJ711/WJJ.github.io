---
title: 面向对象三大特性3——多态
date: 2019-04-04 15:59:11
tags:
	- JavaSE
	- Java
categories: JavaSE
---

#  **多态(polymorphism)**

多态指的是同一个方法调用，由于对象不同可能会有不同的行为。现实生活中，同一个方法，具体实现会完全不同。 比如：同样是调用人“吃饭”的方法，中国人执行就是用筷子吃饭，英国人执行就是用刀叉吃饭，印度人执行用手吃饭。

# 多态的要点：

1. **多态是方法的多态，不是属性的多态(多态与属性无关)。**
2. 多态的存在要有3个必要条件：***继承（实现），方法重写，父类引用指向子类对象。***
3. 父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了。

# 成员访问特点

## 成员变量

​	编译看左边，运行看左边

## 静态变量

​	编译看左边，运行看左边

## 成员方法

​	***编译看左边，运行看右边（多态！！！）***

## 静态方法

​	编译看左边，运行看左边

# 孔子装爹

​	从前有个圣人叫孔子，孔子教论语，孔子他爹教农耕；

​	孔子爹就比较忙，经常外出讲课，收入很高；

​	有一天，又有人请孔子爹去教农耕，恰巧孔子爹不在。给的报酬很高，孔子就心动了。就打算打扮成他爹的样子去，穿上爹的衣服，带上爹的帽子，粘上小胡子就去了。`Father f=new Son();`f.name f.age 其实是爹的属性，因为别人看到的是孔子爹的属性（样貌）。别人请孔子教农耕，孔子就露馅了` f.teach(）`教的是论语。

```java
class KongDie{
	int age=70;
	String name="老爹";
	public static void sleep() {
		System.out.println("孔爹睡觉");
	}
	public void teach() {
		System.out.println("孔爹教农耕");
	}
}
class Kong extends KongDie{
	int age=30;
	String name="小孔";
	public static void sleep() {
		System.out.println("小孔睡觉");
	}
	public void teach() {
		System.out.println("小孔教论语");
	}
}
public class TestDemo{
	public static void main(String[] args) {
		KongDie f=new Kong();
		System.out.println("年龄:"+f.age);
		System.out.println("姓名:"+f.name);
		f.sleep();
		f.teach();
	}
}
```

运行结果：

```java
年龄:70 //成员变量，运行看左边
姓名:老爹//成员变量，运行看左边
孔爹睡觉//静态方法，运行看左边
小孔教论语//成员方法,运行看右边，多态！
```

# 多态的好处

1. 提高了程序的维护性（由继承保证）
2. 提高了程序的扩展性（由多态保证）

# 多态的弊端

1. 不能访问子类特有功能

2. 那么我们如何才能访问子类的特有功能呢?

   多态中的转型

# 多态中的转型问题

## 向上转型

​	父类引用指向子类对象，我们称这个过程为向上转型，属于自动类型转换。

```java
Father father=new Son();
```

# 向下转型

​	    向上转型后的父类引用变量只能调用它编译类型的方法，不能调用它运行时类型的方法。这时，我们就需要进行类型的强制转换，我们称之为向下转型!

```java
Son son=(Son)father;//父类引用变量father实际上指向的是子类对象
```

# 面试题

```java
class A{
	char x='A';
	public void show(){
		System.out.println("父类A中的this地址为："+this);
		this.show2();
	}
	public void show2(){
		System.out.println("我");
	}
}
class B extends A {
	char x='B';
	public void show2(){
		System.out.println("爱");
	}
}
class C extends B {
	char x='C';
	public void show(){
		System.out.println("子类C的super的地址为："+ super.toString());
		super.show();
	}
	public void show2(){
		System.out.println("你");
	}
}
public class TestDemo {
	public static void main(String[] args) {
		A a = new B();
		System.out.println("a的地址是："+a);
		System.out.println("a.x= "+a.x);
		a.show();
		System.out.println("------------------------");
		B b = new C();
		System.out.println("b的地址是："+b);
		System.out.println("b.x= "+b.x);
		b.show();
	}
}
```

输出结果：

```java
a的地址是：classlib.B@36d64342
a.x= A//成员变量没有多态，编译运行都看左边
父类A中的this地址为：classlib.B@36d64342
爱
------------------------
b的地址是：classlib.C@511baa65
b.x= B//成员变量没有多态，编译运行都看左边
子类C的super的地址为：classlib.C@511baa65//super表示的是该对象内存中的一部分地址，该部分存储了从父类中继承的成员
父类A中的this地址为：classlib.C@511baa65
你
```

## 多态的内存分析

{%asset_img ABC内存分析.png%}

# 模拟Servlet并内存分析

```java
public class TestDemo{
	public static void main(String[] args) {
		HttpServlet s=new MyServlet();
		s.service();
		System.out.println("对象s的内存地址"+s);
	}
}
class HttpServlet{
	public void service() {
		System.out.println("HttpServlet.service()");
		System.out.println("调用doGet()时的内存地址"+this);
		this.doGet();
	}
	public void doGet() {
		System.out.println("HttpServlet.doGet()");
	}
}
class MyServlet extends HttpServlet {
	//重写doGet()方法，不重写service()方法
	public void doGet() {
		System.out.println("MyServlet.doGet()");
	}
}
```

```java
HttpServlet.service()
调用doGet()时的内存地址classlib.MyServlet@36d64342
MyServlet.doGet()
对象s的内存地址classlib.MyServlet@36d64342
```



内存分析图如下：

{%asset_img servlet内存分析.png%}

 