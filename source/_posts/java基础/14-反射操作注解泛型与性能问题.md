---
title: 14.反射操作注解泛型与性能问题
date: 2019-04-30 14:00:39
tags:
	- JavaSE
	- Java
categories: JavaSE
---

# 反射操作泛型（Generic）

* Java采用泛型擦除的机制来引入泛型。Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换的麻烦。但是，一旦编译完成，所有的和泛型有关的类型全部擦除。

* 为了通过反射操作这些类型以迎合实际开发的需要，Java就新增了ParameterizedType，GenericArrayType，TypeVariable 和WildcardType几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型。
* ParameterizedType: 表示一种参数化的类型，比如Collection<String>
* GenericArrayType: 表示一种元素类型是参数化类型或者类型变量的数组类型
* TypeVariable: 是各种类型变量的公共父接口
* WildcardType: 代表一种通配符类型表达式，比如?, ? extends Number, ? super Integer【wildcard是一个单词：就是“通配符”】

```java
package reflection;

import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.List;
import java.util.Map;

/**
 * 通过反射获取泛型信息
 */
public class Demo04 {
    public void test01(Map<String,User> map, List<User> list){
        System.out.println("Demo04.test01");
    }
    public Map<Integer,User> test02(){
        System.out.println("Demo04.test02");
        return null;
    }

    public static void main(String[] args) {
        try {
            //获得指定方法参数泛型信息
            Method m = Demo04.class.getDeclaredMethod("test01", Map.class, List.class);
            Type[] types = m.getGenericParameterTypes();//获取指定方法参数泛型信息
            for (Type paramType:types){
                System.out.println("#"+paramType);//#java.util.Map<java.lang.String, reflection.User>
                if(paramType instanceof ParameterizedType){
                    Type[] genericTypes = ((ParameterizedType) paramType).getActualTypeArguments();
                    for (Type genericType:genericTypes){
                        System.out.println("泛型类型："+genericType);//泛型类型：class java.lang.String
                        //泛型类型：class reflection.User
                    }
                }
            }
            System.out.println("-----------------------------------");
            //获得指定方法返回值泛型信息
            Method m2 = Demo04.class.getDeclaredMethod("test02");
            Type genericReturnType = m2.getGenericReturnType();
            if (genericReturnType instanceof ParameterizedType){
                System.out.println("#"+genericReturnType);//#java.util.Map<java.lang.Integer, reflection.User>
                Type[] types2 = ((ParameterizedType) genericReturnType).getActualTypeArguments();
                for(Type t:types2){
                    System.out.println("泛型类型："+t);//泛型类型：class java.lang.Integer
                }//泛型类型：class reflection.User
            }


        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        }
    }
}
```

# 反射获取注解信息

见 13第六章 注解和配置文件应用

# 反射机制性能问题

`setAccessible`

* 启用和禁用访问安全检查的开关,值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查。值为 false 则指示反射的对象应该实施 Java 语言访问检查。并不是为true就能访问为false就不能访问。为true可以访问私有的
* 禁止安全检查，可以提高反射的运行速度。

```java
package reflection;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

/**
 * 通过跳过安全检查，提高反射效率
 * 三种执行方法的效率差异比较
 */
  public static void main(String[] args) throws Exception {
        //test01();//普通方法调用，执行1亿次，耗时：1651ms
        //test02();//通过反射动态方法调用，执行1亿次，耗时：3383ms
        test03();//通过反射动态方法调用，跳过安全检查，执行1亿次，耗时：2377ms
    }

public class Demo06 {
    public static void test01(){
        User u=new User();
        long start = System.currentTimeMillis();
        for (int i=0;i<1e9;i++){
            u.getName();
        }
        long end = System.currentTimeMillis();
        System.out.println("普通方法调用，执行1亿次，耗时："+(end-start)+"ms");
    }
    public static void test02() throws Exception {
        User u=new User();
        Class<? extends User> clazz = u.getClass();
        Method method = clazz.getDeclaredMethod("getName");
        long start = System.currentTimeMillis();
        for (int i = 0; i < 1e9; i++) {
            method.invoke(u);
        }
        long end = System.currentTimeMillis();
        System.out.println("通过反射动态方法调用，执行1亿次，耗时："+(end-start)+"ms");
    }
    public static void test03() throws Exception {
        User u3=new User();
        Class<? extends User> clazz = u3.getClass();
        Method method = clazz.getDeclaredMethod("getName");
        method.setAccessible(true);
        long start=System.currentTimeMillis();
        for (int i = 0; i <1e9; i++) {
            method.invoke(u3);
        }
        long end = System.currentTimeMillis();
        System.out.println("通过反射动态方法调用，跳过安全检查，执行1亿次，耗时："+(end-start)+"ms");
    }
}
```

