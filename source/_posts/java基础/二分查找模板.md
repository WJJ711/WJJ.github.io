---
title: 二分查找模板
date: 2019-04-19 23:27:02
tags: Algorithm
categories: Algorithm
---

# 第一个与key值相等的元素

```java
/**
 * 第一个与key值相等的元素
 */
public class BinarySearch01 {
    public static int search(int[] arr,int key){
        int left=0;
        int right=arr.length-1;
        while (left<right){
            int mid=left+((right-left)>>1);//因为这里是right=mid所以不用+1,注意，这里括号一个都不能少>>优先级较低
            if(arr[mid]>=key){//说明第一个与key相等的值在mid或者mid左边
                right=mid;
            }else{
                left=mid+1;//说明第一个与key相等的值在mid右边
            }
        }
        if(arr[left]==key)
            return left;
        else return -1;
    }
}
```

# 最后一个等于key的元素

```java
/**
 * 最后一个等于key的元素
 */
public class BinarySearch02 {
    public static int search(int[] arr,int key){
        int left=0;
        int right=arr.length-1;
        while (left<right){
            int mid=left+((right-left+1)>>1);//因为求最后一个等于key的元素，left要向右边逼近，是left=mid
            //这里如果不加1会死循环，因为mid向下取整，例如right=9，mid永远=8，left永远等于8
            if(arr[mid]<=key){//该位置在mid右边或者mid
                left=mid;
            }else {
                right=mid-1;//该位置在mid左边
            }
        }
        if(arr[left]==key)
            return left;
        else return -1;
    }
}
```

# 查找最后一个小于等于key值的元素

``` java
/**
 * 查找最后一个小于等于key值的元素
 */
public class BinarySearch03 {
    public static int search(int[] arr,int key){
        int left=0;
        int right=arr.length-1;
        while (left<right){
            int mid=left+((right-left+1)>>1);//这里括号一个都不能少>>优先级较低，这里必须+1,因为找的最后一个，left向右边逼近，如果没有+1，right=9，left=8，则mid和left永远等于8，死循环
            if(arr[mid]<=key){//在mid处或者mid的右边
                left=mid;
            }else {//在mid左边
                right=mid-1;
            }

        }
        if(arr[left]<=key){
            return left;
        }else {
            return -1;
        }
    }
}
```

# 查找第一个大于等于key的值

```java
/**
 * 查找第一个大于等于key的值
 */
public class BinarySearch04 {
    public static int search(int[] arr,int key){
        int left=0;
        int right=arr.length-1;
        while (left<right){
            int mid=left+((right-left)>>1);
            if(arr[mid]>=key){//在mid处，或者mid的左边,right向左边逼近，这里括号一个都不能少，>>优先级较低
                right=mid;
            }else{//在mid右边
                left=mid+1;
            }
        }
        if(arr[left]>=key){
            return left;
        }
        else return -1;
    }
}
```

