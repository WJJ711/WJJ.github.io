---
title: 内部类
date: 2019-04-06 10:20:33
tags:
	- Java
	- JavaSE
categories: JavaSE
---

# 定义

把类定义在其他类的内部，这个类就被称为内部类。即在类A中定义了一个类B，类B就是内部类。

由于内部类提供了更好的封装特性，并且可以很方便的访问外部类的属性，所以**通常内部类在只为所在外部类提供服务的情况下优先使用**

举例：电脑+CPU：CPU是电脑的一个成员，cpu还得和其它成员打交道

第一个作用：隐藏内部类

第二个作用：为了更好的和外部类的其它成员交流

# 内部类的访问特点：

1. 内部类可以直接访问外部类的成员，包括私有。

2. 外部类要访问内部类的成员，必须创建对象。

# 注意

一般情况下，内部类都会用private进行修饰，不对外部开放。

# 内部类的分类：

成员内部类： 非静态内部类 和 静态内部类

局部内部类

匿名内部类

# 非静态内部类（inner class）

**非静态内部类的对象是外部类对象的一个成员**

1. 非静态内部类怎么访问外部类？

答：直接访问，好像定义在自己类中的一样，并且可以访问外部类的私有成员

2. 外部类怎么访问非静态内部类？

答：创建非静态内部类对象，并且可以访问非静态内部类的私有成员

3. 其他类怎么访问非静态内部类？

答：创建非静态内部类对象，并且受访问权限限制（不能访问private）

格式：`Outer.Inner inner =new Outer().new Inner();`

4. 为什么非静态内部类可以直接访问外部类成员，就像定义在自己里面

答：非静态内部类对象秘密捕获了一个外部类对象

## 使用要点

  i. 非静态内部类必须寄存在一个外部类对象里。因此，如果有一个非静态内部类对象那么一定存在对应的外部类对象。非静态内部类对象单独属于外部类的某个对象。

  ii. 非静态内部类可以直接访问外部类的成员，但是外部类不能直接访问非静态内部类成员。

  iii. 非静态内部类不能有静态方法、静态属性和静态初始化块。

  iv. 外部类的静态方法、静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例。

```java
class Outer {
    private int age = 10;
    class Inner {
        int age = 20;
        public void show() {
            int age = 30;
            System.out.println("内部类方法里的局部变量age:" + age);// 30
            System.out.println("内部类的成员变量age:" + this.age);// 20
            System.out.println("外部类的成员变量age:" + Outer.this.age);// 10
        }
    }
}
```



# 静态内部类（nest class）

**静态内部类对象是外部类的成员**（属于类，不是属于对象）

1. 内部类怎么访问外部类？

   答：可以直接访问外部类私有的成员，就像定义在自己里面一样。**但是只能访问外部类静态成员**

2. 外部类怎么访问内部类？

   创建内部类对象，并且能够访问内部类私有成员

3. 其他类怎么访问内部类：

   创建内部类对象：`Outer.Inner inner = new Outer.Inner();`

   但是受到权限修饰符的限制（不能访问private）

## 使用要点

1. 当一个静态内部类对象存在，并不一定存在对应的外部类对象。 因此，静态内部类的实例方法不能直接访问外部类的实例方法。

2. 静态内部类看做外部类的一个静态成员。 因此，外部类的方法中可以通过：“静态内部类.名字”的方式访问静态内部类的静态成员，通过 new 静态内部类()访问静态内部类的实例。

# 局部内部类

1. 内部类怎么访问外部类：

   答：直接访问，就像定义在自己里面一样，并且能够访问外部类私有的成员

2. 外部类怎么访问内部类

   外部类不能访问**。**只能在定义这个类的方法里面访问。**并且只能通过创建对象访问。能够访问所有私有的成员

3. 其他类怎么访问内部类

   不能

4. 注意事项：

   局部内部类访问局部变量必须被final修饰。：must be final or effectively final

   一旦被局部内部类访问了，该局部变量自动变成final类型，写不写final都是final

   **推荐加上final**

   为什么呢？

   因为局部变量会随着方法的调用完毕而消失，这个时候，局部对象并没有立马从堆内存中消失，还要使用那个变量。为了让数据还能继续被使用，就用final修饰，这样，在堆内存里面存储的其实是一个常量值。
   

|                          |                                                            | 怎么访问外部类                                               | 外部类怎么访问内部类？                                       | 其他类怎么访问内部类                                         | 注意事项                                                     |
| ------------------------ | ---------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 非静态内部类             | 非静态内部类的对象是外部类**对象**的一个成员               | 直接访问，好像定义在自己类中的一样，并且可以访问外部类的私有成员 | 创建非静态内部类对象，并且可以访问内部类的私有成员           | `Outer.Inner inner =new Outer().new Inner();`创建非静态内部类对象，并且受访问权限限制（不能访问private） | 非静态的内部类的成员只能是非静态的。                         |
| 静态内部类（nest class） | 静态内部类对象是外部类的成员                               | 可以直接访问外部类私有的成员，就像定义在自己里面一样。**但是只能访问外部类静态成员** | 创建内部类对象，并且能够访问内部类私有成员                   | `Outer.Inner inner =new Outer.Inner()`；但是受到权限修饰符的限制（不能访问private） | 静态内部类成员有静态的和非静态的                             |
| 局部内部类               | 它是定义在方法内部的，作用域只限于本方法，称为局部内部类。 | 直接访问，好像定义在自己类中的一样，并且可以访问外部类的私有成员 | **外部类不能访问**。**只能在定义这个类的方法里面访问。**并且只能通过创建对象访问。能够访问所有私有的成员 | 不能                                                         | 局部内部类访问局部变量必须被final修饰。：must be final or effectively final |
|                          |                                                            |                                                              |                                                              |                                                              |                                                              |



# 内部类举例

```java
class Face{
    String type="瓜子脸";
    private class Nose{
        String type="鹰钩鼻";
        public void breath() {
            System.out.println("吸一口氧气");
            System.out.println("脸型："+Face.this.type);//内部类可直接访问外部类成员
        }
    }
    Nose nose =new Nose();//外部类访问内部类需要创建对象
    public String toString(){
        return "脸型:"+type+",鼻型:"+nose.type;
    }
    public void getBreath(){
        nose.breath();//因为内部类是私有的，需要用get执行内部类的方法
    }
}
public class InnerClass{
    public static void main(String[] args) {
        Face face = new Face();
        System.out.println(face);
        face.getBreath();
    }
}
```

执行结果：

```java
脸型:瓜子脸,鼻型:鹰钩鼻
吸一口氧气
脸型：瓜子脸
```

# 匿名内部类

## 概述

就是内部类的简化写法。



## 前提：

存在一个类或者接口

这里的类可以是具体类也可以是抽象类。



## 格式：

```java
new  父类构造器(实参类表) \实现接口 () {
    @override
           //匿名内部类类体！
}
```

重写方法;

}//前面是创建对象，后面是重写父类或接口

## 本质：

**是一个继承了类或者实现了接口的子类匿名对象**

本质是一个**对象**！！！

理解：

我要创建一个类或者接口，但是我又不想重写一个类去继承该类或者实现该接口，这时可以用匿名类

## **注意**

1.  匿名内部类没有访问修饰符。

2.  匿名内部类没有构造方法。因为它连名字都没有那又何来构造方法呢。

## 匿名内部类示例
```java
interface Inter {//定义接口
    void show();
}
class Outer{
    public static Inter method(){
        return  new Inter() {
            @Override//匿名内部类
            public void show() {
                System.out.println("Hello world");
            }
        };
    }
}
public class TestDemo {
    public static void main(String[] args) {
        Outer.method().show();
    }
}
```

## 示例2

```java
interface A {
    void show();
}
public class TestDemo {
    public static void test(A a){
        a.show();
    }
    public static void main(String[] args) {
        TestDemo.test(new A(){//匿名内部类
            @Override
            public void show(){
                System.out.println("Hello world");
            }
        });
    }
}
```

