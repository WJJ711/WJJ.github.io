---
title: 字节流
date: 2019-04-22 14:57:27
tags:
	- JavaSE
	- Java
categories: JavaSE
---

# 第一章 IO流的四个基类

|            |           **输入流**            |              输出流              |
| :--------: | :-----------------------------: | :------------------------------: |
| **字节流** | 字节输入流<br />**InputStream** | 字节输出流<br />**OutputStream** |
| **字符流** |   字符输入流<br />**Reader**    |    字符输出流<br />**Writer**    |

# 第二章 字节流

{%asset_img 字节流各个类.jpg%}

## 2.1 一切皆为字节

一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。

## 2.2 字节输出流【OutputStream】

`java.io.OutputStream `抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。

- `public void close()` ：关闭此输出流并释放与此流相关联的任何系统资源。  
- `public void flush() ` ：刷新此输出流并强制任何缓冲的输出字节被写出。  
- `public void write(byte[] b)`：将 b.length字节从指定的字节数组写入此输出流。  
- `public void write(byte[] b, int off, int len)` ：从指定的字节数组写入 len个字节，从偏移量 off开始输出到此输出流。  
- `public abstract void write(int b)` ：将指定的字节输出流。

> 小贴士：
>
> close方法，当完成流的操作时，必须调用此方法，释放系统资源。



## 2.3 FileOutputStream类

### 字节流写数据的常见问题



```java
 OutputStream os=new FileOutputStream(dest);
```

这句话做了以下事情

1. 判断流的指向的文件是否存在，如果不存在，就创建该文件
2. 在内存中创建流对象
3. 在流对象和文件之间创建数据流通的通道



`OutputStream`有很多子类，我们从最简单的一个子类开始。

`java.io.FileOutputStream `类是文件输出流，用于将数据写出到文件。

### 构造方法

- `public FileOutputStream(File file)`：创建文件输出流以写入由指定的 File对象表示的文件。 
- `public FileOutputStream(String name)`： 创建文件输出流以指定的名称写入文件。  

当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。

### 写出字节数据

```java
public class IO02 {
    public static void main(String[] args) throws IOException {
        //1创建源
        File dest=new File("a.txt");
        //2创建流
        OutputStream os=new FileOutputStream(dest);
        //3操作
        os.write(97);//0011 0001
        //4关流，释放资源
        os.close();
    }
}
```



小贴士：

1. 虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。
2. 流操作完毕后，必须释放系统资源，调用close方法，千万记得。

### 写出字节数组

：`write(byte[] b)`，每次可以写出数组中的数据，代码使用演示：

```java
public class IO02 {
    public static void main(String[] args) throws IOException {
        //1创建源
        File dest=new File("a.txt");
        //2创建流
        OutputStream os=new FileOutputStream(dest);
        //3操作
        byte[] bytes="hello io".getBytes();
        os.write(bytes);
        //4关流，释放资源
        os.close();

    }
}
```

### 写出指定长度字节数组

：`write(byte[] b, int off, int len)` ,每次写出从off索引开始，len个字节，代码使用演示：

```java
public class IO02 {
    public static void main(String[] args) throws IOException {
        //1创建源
        File dest=new File("a.txt");
        //2创建流
        OutputStream os=new FileOutputStream(dest);
        //3操作
        byte[] bytes="hello io".getBytes();
        os.write(bytes,6,2);//只写入io
        //4关流，释放资源
        os.close();
    }
}
输出结果：
io
```

### 数据追加续写

经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？

- `public FileOutputStream(File file, boolean append)`： 创建文件输出流以写入由指定的 File对象表示的文件。  
- `public FileOutputStream(String name, boolean append)`： 创建文件输出流以指定的名称写入文件。  

这两个构造方法，参数中都需要传入一个boolean类型的值，`true` 表示追加数据，`false` 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示：

```java
public class IO02 {
    public static void main(String[] args) throws IOException {
        //1创建源
        File dest=new File("a.txt");
        //2创建流
        OutputStream os=new FileOutputStream(dest,true);
        //3操作
        byte[] bytes="hello io\r\n".getBytes();
        os.write(bytes);
        //4关流，释放资源
        os.close();
    }
}
```



### 写出换行

- 回车符`\r`和换行符`\n` ：
  - 回车符：回到一行的开头（return）。
  - 换行符：下一行（newline）。
- 系统中的换行：
  - Windows系统里，每行结尾是 `回车+换行` ，即`\r\n`；
  - Unix系统里，每行结尾只有 `换行` ，即`\n`；
  - Mac系统里，每行结尾是 `回车` ，即`\r`。从 Mac OS X开始与Linux统一。

## 经典IO代码

```java
import java.io.*;

public class IO02 {
    public static void main(String[] args) {
        //1创建源
        File dest = new File("a.txt");
        //2创建流
        OutputStream os = null;
        try {
            os = new FileOutputStream(dest, true);
            //3操作
            // os.write(97);//0011 0001
            byte[] bytes = "hello io\r\n".getBytes();
            os.write(bytes);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {

            //4关流，释放资源
            if (null != os) {

                try {
                    os.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

# try-with-resources

JDK1.7以后

`public interface AutoCloseable`

()中里面放的是资源的申明，什么是资源呢？实现了AutoCloseable接口的对象就是资源

格式：

```java
try (创建流对象语句，如果多个,使用';'隔开) {
	// 读写数据
} catch (IOException e) {
	e.printStackTrace();
}
```

代码使用演示：

```java
import java.io.*;

public class IO02 {
    public static void main(String[] args) {
        String s="hello io\r\n";
        try (OutputStream os=new FileOutputStream("a.txt",true)){
            os.write(s.getBytes());

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
```

## 2.4 字节输入流【InputStream】

`java.io.InputStream `抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。

- `public void close()` ：关闭此输入流并释放与此流相关联的任何系统资源。    
- `public abstract int read()`： 从输入流读取数据的下一个字节。 
- `public int read(byte[] b)`： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。

> 小贴士：
>
> close方法，当完成流的操作时，必须调用此方法，释放系统资源。

## 2.5 FileInputStream类

`java.io.FileInputStream `类是文件输入流，从文件中读取字节。

### 构造方法

- `FileInputStream(File file)`： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 
- `FileInputStream(String name)`： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。  

当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出`FileNotFoundException` 。

### 读取字节数据

1. **读取字节**：`read`方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回`-1`，代码使用演示：

```java
public class IO03 {
    public static void main(String[] args) {
        try (InputStream is=new FileInputStream("a.txt")){
            int read;
            while ((read=is.read())!=-1){
                System.out.print((char) read);

            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

小贴士：

1. 虽然读取了一个字节，但是会自动提升为int类型。
2. 流操作完毕后，必须释放系统资源，调用close方法，千万记得。

2 **使用字节数组读取**：`read(byte[] b)`，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回`-1` ，代码使用演示：

```java
public class IO03 {
    public static void main(String[] args) {
        try (InputStream is=new FileInputStream("a.txt")){
            byte[] bytes=new byte[1024];
            int len=-1;
            while ((len=is.read(bytes))!=-1){
                System.out.print(new String(bytes,0,len));
			//  len 每次读取的有效字节个数
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```



小贴士：

使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。

`InputStream is=new FileInputStream("a.txt")`

做了以下3件事

1. 判断文件是不是存在，如果不存在，就抛出异常。
2. 在内存中创建FileInputStream对象
3. 在对象和文件之间，构建数据传输通道

# 文件复制

图片复制：

```java
public class Copy {
    public static void main(String[] args) {
        //创建源，选择流
        try (InputStream is=new FileInputStream("D:/picture/my.jpg");
             OutputStream os=new FileOutputStream("mygirl.jpg")){
            //读数据，写数据
            byte[] bytes=new byte[1024];
            int len;
            while ((len=is.read(bytes))!=-1){
                os.write(bytes,0,len);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```



# 第三章 缓冲流

## 1.1 概述

缓冲流,也叫高效流，是对4个基本的`FileXxx` 流的增强，所以也是4个流，按照数据类型分类：

- **字节缓冲流**：`BufferedInputStream`，`BufferedOutputStream` 
- **字符缓冲流**：`BufferedReader`，`BufferedWriter`

缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。

## 1.2 字节缓冲流

### 构造方法

- `public BufferedInputStream(InputStream in)` ：创建一个 新的缓冲输入流。 
- `public BufferedOutputStream(OutputStream out)`： 创建一个新的缓冲输出流。

构造举例，代码如下：

```java
// 创建字节缓冲输入流
BufferedInputStream bis = new BufferedInputStream(new FileInputStream("bis.txt"));
// 创建字节缓冲输出流
BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("bos.txt"));
```

如图所示，缓冲流在磁盘到端口（端口到磁盘）进行加速，默认size为8k缓存。

bytes数组，在端口和应用程序（内存）进行加速。二次加速

{%asset_img 缓冲区流.png%}

### 效率测试

```java
import java.io.*;

public class Copy {
    public static void main(String[] args) {
        long time1=System.currentTimeMillis();
        //copy1("D:/picture/mygirl.jpg","p1.jpg");//18225ms
        //copy2("D:/picture/mygirl.jpg","p1.jpg");//67ms,//加入BufferedInputStream、BufferedOutputSteam
        copy3("D:/picture/mygirl.jpg","p1.jpg");//17ms     //加入BufferedInputStream、BufferedOutputSteam和缓存数组

        long time2=System.currentTimeMillis();
        System.out.println(time2-time1+"ms");

    }
    //一个字节一个字节的拷
    public static void copy1(String src,String dest){
        //创建源，选择流
        try (InputStream is=new FileInputStream(src);
             OutputStream os=new FileOutputStream(dest)){
            //读数据，写数据
            int data;
            while ((data=is.read())!=-1){
                os.write(data);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    //加入BufferedInputStream、BufferedOutputSteam
    public static void copy2(String src,String dest){
        //12选择源创建流
        try (InputStream is=new BufferedInputStream(new FileInputStream(src));
        OutputStream os=new BufferedOutputStream(new FileOutputStream(dest))){
            //操作
            int data;
            while ((data=is.read())!=-1){
                os.write(data);
            }

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
     //加入BufferedInputStream、BufferedOutputSteam和缓存数组
    public static void copy3(String src,String dest){
        //12创建源，选择流
        try (InputStream is=new BufferedInputStream(new FileInputStream(src));
        OutputStream os=new BufferedOutputStream(new FileOutputStream(dest))){
            byte[] bytes=new byte[1024];
            int len=-1;
            while ((len=is.read(bytes))!=-1){
                os.write(bytes,0,len);
            }

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

