---
title: 4.生产者消费者模式
date: 2019-04-26 21:28:27
tags:
	- JavaSE
	- Java
categories: JavaSE
---

# 案例一

采用Java 多线程技术，设计实现一个符合生产者和消费者问题的程序。
对一个对象（枪膛）进行操作，其最大容量是10颗子弹。
生产者线程是一个压入线程，它不断向枪膛中压入子弹；消费者线程是一个射出线程，它不断从枪膛中射出子弹。   
要求：    
（1）给出分析过程说明。     
   （提示：这是个生产者与消费者问题，也是线程的同步问题， 为了防止两个线程访问一个资源时出现忙等待，要使用的wait-notify函数，是两个线程交替执行; ）   
（2）程序输出，要模拟体现对枪膛的压入和射出操作；    
（3）设计程序时应考虑到两个线程的同步问题。

```java
package Day29_Thread02;

public class Gun {
    //子弹
    static class Bullet{
        int id;
        public Bullet(int id) {
            this.id = id;
        }
    }
    //枪膛有10发子弹
    Bullet[] container=new Bullet[10];
    int count=0;
    public synchronized void push(Bullet bullet){
        while (count==container.length){//注意：这里要用while，如果有多个生产者，则用if会线程不安全
            try {
                this.wait();//线程阻塞，等待消费者射出子弹
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(Thread.currentThread().getName()+"第"+bullet.id+"发子弹上膛");
        container[count++]=bullet;
        this.notifyAll();
    }
    public synchronized Bullet pop(){
        while (count==0){//注意：这里要用while，如果有多个消费者，则用if会线程不安全
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        count--;
        this.notifyAll();
        System.out.println(Thread.currentThread().getName()+"射出了"+container[count].id+"发子弹");
        return container[count];
    }

}

```

```java
package Day29_Thread02;

public class Productor implements Runnable{
    Gun gun;

    public Productor(Gun gun) {
        this.gun = gun;
    }

    @Override
    public void run() {
        for (int i=0;i<100;i++){
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            gun.push(new Gun.Bullet(i));
        }
    }
}
```

```java
package Day29_Thread02;

public class Consumer implements Runnable {
    Gun gun;

    public Consumer(Gun gun) {
        this.gun = gun;
    }

    @Override
    public void run() {
        for (int i=0;i<100;i++){
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            gun.pop();
        }
    }
}
```

```java
package Day29_Thread02;

public class CoTest {
    public static void main(String[] args) {
        Gun gun=new Gun();
        new Thread(new Consumer(gun)).start();//可以有多个消费者
        new Thread(new Consumer(gun)).start();
        new Thread(new Consumer(gun)).start();
        new Thread(new Consumer(gun)).start();
        new Thread(new Productor(gun)).start();
    }
}

```

