<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面向对象与面向过程]]></title>
    <url>%2F2019%2F04%2F01%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[我们千万不要把面向过程和面向对象对立起来。他们是相辅相成的。面向对象离不开面向过程! 总结 都是解决问题的思维方式，都是代码组织的方式。 解决简单问题可以使用面向过程 解决复杂问题：宏观上使用面向对象把握，微观处理上仍然是面向过程。 面向对象思考方式 遇到复杂问题，先从问题中找名词，然后确立这些名词哪些可以作为类，再根据问题需求确定的类的属性和方法，确定类之间的关系。 建议 面向对象具有三大特征：封装性、继承性和多态性，而面向过程没有继承性和多态性，并且面向过程的封装只是封装功能，而面向对象可以封装数据和功能。所以面向对象优势更明显。 对象说白了也是一种数据结构(对数据的管理模式)，将数据和数据的行为放到了一起。即将相关数据和相关方法封装到一个独立的实体 在内存上，对象就是一个内存块，存放了相关的数据集合! 对象的本质就一种数据的组织方式! 面向过程(Procedure Oriented)面向过程思想思考问题时，我们首先思考“怎么按步骤实现?”并将步骤对应成方法，一步一步，最终完成。 这个适合简单任务，不需要过多协作的情况下。比如，如何开车?我们很容易就列出实现步骤： 发动车 2. 挂挡 3.踩油门 4. 走你 面向对象(Object Oriented,OO)面向过程适合简单、不需要协作的事务。 但是当我们思考比较复杂的问题，比如“如何造车?”，就会发现列出1234这样的步骤，是不可能的。那是因为，造车太复杂，需要很多协作才能完成。此时面向对象思想就应运而生了。 面向对象(Object Oriented)思想更契合人的思维模式。我们首先思考的是“怎么设计这个事物?” 比如思考造车，我们就会先思考“怎么设计车?”，而不是“怎么按步骤造车的问题”。这就是思维方式的转变。 一、面向对象思想思考造车，发现车由如下对象组成： 轮胎 发动机 车壳 座椅 挡风玻璃 为了便于协作，我们找轮胎厂完成制造轮胎的步骤，发动机厂完成制造发动机的步骤;这样，发现大家可以同时进行车的制造，最终进行组装，大大提高了效率。但是，具体到轮胎厂的一个流水线操作，仍然是有步骤的，还是离不开面向过程思想! 因此，面向对象可以帮助我们从宏观上把握、从整体上分析整个系统。 但是，具体到实现部分的微观操作(就是一个个方法)，仍然需要面向过程的思路去处理。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组]]></title>
    <url>%2F2019%2F03%2F29%2F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组数组变量属引用类型，实例化的数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，数组对象本身是在堆中存储的。 数组概念 数组是存储同一种数据类型多个元素的集合。也可以看成是一个容器。 数组既可以存储基本数据类型，也可以存储引用数据类型。（对象的地址）（对象数组） 长度是确定的。数组一旦被创建，它的大小就是不可以改变的。 数组定义格式12type[] arr_name; //（推荐使用这种方式）type arr_name[]; 注意事项 ​ 1. 声明的时候并没有实例化任何对象，只有在实例化数组对象时，JVM才分配空间，这时才与长度有关。 ​ 2. 声明一个数组的时候并没有数组真正被创建。 ​ 3. 构造一个数组，必须指定长度。 数组初始化 Java中的数组必须先初始化,然后才能使用。 所谓初始化：就是为数组中的数组元素分配内存空间，并为每个数组元素赋初值。 数组的初始化方式 动态初始化：初始化时程序猿只指定数组长度，由系统为数组分配默认初始值。 123int[] a1 = new int[2];//动态初始化数组，先分配空间；a1[0]=1;//给数组元素赋值；a1[1]=2;//给数组元素赋值； 静态初始化：初始化时指定每个数组元素的初始值，由系统决定数组长度。 123int[] a=new int[]&#123;1,2,3&#125;;//完整格式,可以简化为下int[] a = &#123; 1, 2, 3 &#125;;// 静态初始化基本类型数组；注意这种方式不能先声明，再简洁初始化。Man[] mans = &#123; new Man(1, 1), new Man(2, 2) &#125;;// 静态初始化引用类型数组； 默认初始化：数组是引用类型，它的元素相当于类的实例变量（实例化的数组可以看成一个对象，数组中的每个元素相当于该对象的成员变量），因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。 123int a2[] = new int[2]; // 默认值：0,0boolean[] b = new boolean[2]; // 默认值：false,falseString[] s = new String[2]; // 默认值：null, null byte,short,int,long ：0 float,double：0.0 char：‘\u0000’ boolean：false 引用类型：null 0x0000(4字节) 但是一定要注意不能同时进行动态初始化和静态初始化。就是不能在给定数组长度的同时给出元素。 例如 1int data[]=new int[3]&#123;1,2,3&#125;;///编译错误！ 数组的内存分配12345678public class TestDemo&#123; public static void main(String[] args) &#123; int data[]=new int[3];//声明数组并分配空间 data[0]=10; data[1]=20; data[2]=30; &#125;&#125; 二维数组java中二维数组内存不是连续的，相当于一个链表，(和C语言不一样)【不建议使用】 二维数组的声明12345678910public class Test &#123; public static void main(String[] args) &#123; // Java中多维数组的声明和初始化应按从低维到高维的顺序进行 int[][] a = new int[3][]; a[0] = new int[2]; a[1] = new int[4]; a[2] = new int[3]; // int a1[][]=new int[][4];//非法 &#125;&#125; 二维数组的动态初始化1234567891011121314import java.util.Arrays;public class Test &#123; public static void main(String[] args) &#123; int[][] a = new int[3][]; // a[0] = &#123;1,2,5&#125;; //错误，没有声明类型就初始化 a[0] = new int[] &#123; 1, 2 &#125;; a[1] = new int[] &#123; 2, 2 &#125;; a[2] = new int[] &#123; 2, 2, 3, 4 &#125;; System.out.println(a[2][3]); System.out.println(Arrays.toString(a[0])); System.out.println(Arrays.toString(a[1])); System.out.println(Arrays.toString(a[2])); &#125;&#125; 二维数组的静态初始化12345678public class Test &#123; public static void main(String[] args) &#123; int[][] a = &#123; &#123; 1, 2, 3 &#125;, &#123; 3, 4 &#125;, &#123; 3, 5, 6, 7 &#125; &#125;; System.out.println(a[2][3]); &#125;&#125; 二维数组的内存分配 对象数组123456789101112131415161718192021222324class Book&#123; private String title; private double price; public Book(String t,double p) &#123; title=t; price=p; &#125; public String toString() &#123; return "titile= "+this.title+",price= "+this.price; &#125;&#125;public class Test01&#123; public static void main(String[] args) &#123; Book books[]=new Book[] &#123; new Book("Java",79.8), new Book("JSP",69.8), new Book("Android",89.8) &#125;; for(Book temp:books) &#123; System.out.println(temp); &#125; &#125;&#125; 1234程序执行结果：titile= Java,price= 79.8titile= JSP,price= 69.8titile= Android,price= 89.8]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位运算符面试问题]]></title>
    <url>%2F2019%2F03%2F28%2F%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[位运算符面试问题请用最有效率的方式写出计算2乘以8的结果答：2&lt;&lt;3 请自己实现两个整数变量的交换 法一 123int temp=a;a=b;b=temp; 法二 123a=a+b;b=a-b;a=a-b; 法三 123a=a^b;b=a^b;//b=a^b^b=a 主要利用性质 x^x=0a=a^b;//a=a^b^a=b x^0=x 法四 1a=(a+b)-(b=a);//不推荐 判断一个数是否是2的n次幂分析：2^n：素数因子只有2 法一:使用循环，若为偶数，一直除以2，最后为1，则为2^n，时间复杂度logn 法二：位运算2^n的数有一特点，转为2进制形式为：只有一个1，其余全为0，因此只需要判断二进制形式是否只有1个1 ​ a: 0000 1000 ​ a-1: 0000 0111 若a不为2^n次，则至少有2个1，例如 ​ b: 0000 1100 ​ b-1: 0000 1011 显然若a是2^n的数，则a&amp;(a-1)=0 123456class TestDemo&#123; public static void main(String[] args)&#123; int a=1024; System.out.println((a&amp;(a-1))==0); &#125;&#125; 一堆整数中都是成双存在，只有一个数是单独存在，请找出这个数？分析：因为一个整数x^x=0 ​ x^0=x 所以，相同的部分^运算后全变成了0，最后一个单独存在的^0得到本身 答：例如有数a,b,c,d,e 用a^b得到a1 a1^c得到a2 以此往复，得到的最后一个数，就是单独的数]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java变量的分类与自动类型转换]]></title>
    <url>%2F2019%2F03%2F26%2FJava%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Java变量的分类与自动类型转换变量的分类 类型 声明位置 从属于 生命周期 局部变量 方法或者语句块内 方法/语句块 从声明位置开始，直到方法或语句块执行完毕，局部变量消失 成员变量（实例变量） 类内部，方法外部 对象 对象创建，成员变量也跟着创建。对象消失，成员变量也跟着消失； 静态变量（类变量） 类内部（不能定义在方法或者语句块中），static修饰 类 类被加载，静态变量就有效；类被卸载，静态变量就消失 局部变量（local variable）方法或语句块内部定义的变量。生命周期是从声明位置开始到到方法或语句块执行完毕为止。局部变量在使用前必须先声明、初始化(赋初值)再使用。 成员变量（也叫实例变量 member variable）方法外部、类的内部定义的变量。从属于对象，生命周期伴随对象始终。如果不自行初始化，它会自动初始化成该类型的默认初始值。 数据类型 默认初始值 int 0 double 0.0 char ‘\u0000’ boolean false 静态变量（类变量 static variable） 使用static定义。 从属于类，生命周期伴随类始终，从类加载到卸载。 如果不自行初始化，与成员变量相同会自动初始化成该类型的默认初始值，如上表所示。 123456789101112public class TestVariable&#123; int a;//成员变量，从属于对象；成员变量会自动被初始化 static int size; //静态变量，从属于类 public static void main(String[] args) &#123; &#123; int age=18;//局部变量，从属于语句块 &#125; int salary=3000;//局部变量，从属于方法 int i;//局部变量，必须初始化 int j=i+5;//编译出错，变量i还未被初始化 &#125;&#125; 自动类型转换 数据范围小的数据与数据范围大的数据进行数学计算时，自动向大范围的数据类型转换后计算。（例如int和long计算，则int类型先自动变为long类型，再计算） 常量也有类型，常整数为int，常浮点数为double 12long a = 55555555; //编译成功，在int表示的范围内(2.1e9内)。long b = 55555555555;//不加L编译可通过，但是结果不正确，已经超过int表示的范围，数据溢出。 我们修改成long类型的常量即可 1long b = 55555555555L; 1234567public class Test02 &#123; public static void main(String[] args) &#123; int microPerDay=24*60*60*1000; long nanosPerDay=24*60*60*1000*1000*1000L; System.out.print(nanosPerDay/microPerDay); &#125;&#125; 输出： 15794//显然溢出了 这是因为24*60*60*1000*1000数据已经溢出，需要修改如下 1long nanosPerDay=24L*60*60*1000*1000*1000; 此时第一个数就变成long类型，计算正确 11000000//结果正确 12float f=(float)1.24;float f=1.24f; 问：这两种赋值方式一样么？ 答：不一样。 第一种方式，底层存储double类型，占8字节，再强制类型转换成float 第二种方式，底层 存储float类型，占4字节（推荐使用） 注意事项 byte,short,char参与运算的时候默认会转换成int类型，即使是统一数据类型相加也会转成int型 1234567public static void main(String[] args) &#123; byte b=10; byte c=10;//编译器会自动判断是否处于byte范围内。若属于，则编译通过 short a=10;//同理 byte d=b+c;//此处报错，Type mismatch: cannot convert from int to byte，b+c时候，自动转换成int类型 short s=b;//此处没问题&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java命名规范]]></title>
    <url>%2F2019%2F03%2F26%2FJava%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[Java命名规范只是建议 类和接口名称：每一个单词首字母大写，例如：TestDemo; 变量/方法名称：第一个单词首字母小写，之后每个单词的首字母大写，例如：studentName;printInfo();【驼峰原则】 常量名称：每个字母大写,若有多个单词，以_分割，例如：FLAG，MAX_VALUE; 包名称：所有字母小写 ​ 多级包： 域名反转，例如：www.zju.edu.cn –&gt; cn.edu.zju]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Typora快速编辑Markdown]]></title>
    <url>%2F2019%2F03%2F23%2F%E4%BD%BF%E7%94%A8Typora%E5%BF%AB%E9%80%9F%E7%BC%96%E8%BE%91Markdown%2F</url>
    <content type="text"><![CDATA[标题标题是用“#”实现的，标题前面加一个“#”，代表一级标题；依次类推，标题前面加六个“#”代表六级标题；一共有六级标题，编辑各种文档完全够用。 #+空格+标题内容 下划线快捷键Ctrl+u，即可实现下划线功能。 强调内容的前后分别加两个*号 斜体内容前后分别加一个\号* 斜体加粗*前后加3个** 删除线先转化成英文输入法，再把内容前后分别加上两个~号 特别注意是2个~ 列表有序列表输入数字“1”+“.”+”空格”，自动开始有序列表。 步骤1 步骤2 步骤3 无序列表输入“+”或者“-”或者“*”+空格，自动开始无序列表 步骤1 步骤2 步骤3 tableCtrl+T,在弹出的对话框中选择行列数，自动生成列表。还可以很方便地对表格进行编辑。 学号 姓名 成绩 xxx xxx xxx asd 分割线有时候，为了排版漂亮，可能会加入分隔线。Markdown加入分隔线非常简单，使用下面任意一种形式都可以 12***--- 插入图片插入本地图片设置主题_config.ymlpost_asset_folder: true当资源文件管理功能打开后，Hexo将会在你每一次通过hexo new post &lt;title&gt;命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个markdown文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹之中，你可以通过相对路径来引用它们，这样你就得到了一个简单而且方便很多的工作流。123&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; 例如本例中，将ZJU.jpg放到资源文件夹中。通过 1&#123;% asset_img ZJU.jpg 测试%&#125; 命令插入，其中[title]可省略 插入代码`System.out.println(“Hello World!”);`System.out.println(&quot;Hello World!&quot;);```System.out.println(“Hello Hexo”);System.out.println(“Hello World!”);``` 12System.out.println("Hello Hexo");System.out.println("Hello World!"); 行内代码引用，使用单个反引号进行包裹（Tab上面那个），代码块用三个反引号包裹。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Markdown 编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo写博客攻略]]></title>
    <url>%2F2019%2F03%2F22%2F%E4%BD%BF%E7%94%A8hexo%E5%86%99%E5%8D%9A%E5%AE%A2%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[新建文章在站点的根目录下执行以下命令：(本博客站点根目录为D:\blog\WJJ711)$ hexo new post &lt;title&gt;//此处title不需要加双引号例如$ hexo new post 使用hexo写攻略可以简写为$ hexo n &lt;title&gt;例如$ hexo n 使用hexo写攻略 给文章添加分类，标签 1 使用Subline Text 打开《使用hexo写博客攻略》 2 设置如下：12345678---title: 使用hexo写博客攻略date: 2019-03-22 19:34:50tags: - hexo - Markdown 编辑器categories: hexo--- 注意 - 后面的空格！ 3 博客正文需要在---下面撰写 一级标题使用一个#+空格+内容 二级标题使用2个#+空格+内容 三级标题使用3个#+空格+内容 设置列表Markdown支持有序列表和无序列表两种形式：无序列表用*或+或-标识有序列表用数字加.标识，例如1. 列表1 列表2 a 子列表1 b 子列表2 列表312345- 列表1- 列表2 a 子列表1 b 子列表2- 列表3 注意- 后面的空格 添加网站链接B站导航[B站导航](https://www.bilibili.com/)注意：https://不能少 插入图片插入本地图片设置主题_config.ymlpost_asset_folder: true当资源文件管理功能打开后，Hexo将会在你每一次通过hexo new post &lt;title&gt;命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个markdown文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹之中，你可以通过相对路径来引用它们，这样你就得到了一个简单而且方便很多的工作流。 123&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; 例如本例中，将ZJU.jpg放到资源文件夹中。通过1&#123;% asset_img ZJU.jpg 测试%&#125; 命令插入，其中[title]可省略注意，此处必须用```加换行的方式插入上面代码 制表语法如下：123表头|条目一|条目二:---:|:---:|:---:项目|项目一|项目二 以上标记效果显示如下： 表头 条目一 条目二 项目 项目一 项目二 语法说明 |、-、:之间多余的空格会被忽略，不影响布局。 三个短斜杠左右的冒号用于控制对齐方式，只放置左边冒号表示文字居左，只放置右边冒号表示文字居右，如果两边都放置冒号表示文字居中。 表格的语句上一行必须为空行，不然表格不生效 强调有时候，我们希望对某一部分文字进行强调，使用*或_包裹即可。使用单一符号标记的效果是斜体，使用两个符号标记的效果是加粗12345*这里是斜体*_这里是斜体_**这里是加粗**__这里是加粗__ 这里是斜体这里是斜体 这里是加粗这里是加粗 分割线有时候，为了排版漂亮，可能会加入分隔线。Markdown加入分隔线非常简单，使用下面任意一种形式都可以 12***--- 插入代码`System.out.println(“Hello World!”);`System.out.println(&quot;Hello World!&quot;);```System.out.println(“Hello Hexo”);System.out.println(“Hello World!”);```12System.out.println(&quot;Hello Hexo&quot;);System.out.println(&quot;Hello World!&quot;); 行内代码引用，使用单个反引号进行包裹（Tab上面那个），代码块用三个反引号包裹。 使用反斜杠\插入语法中用到的特殊符号在Markdown中，主要有以下几种特殊符号需要处理：123456789101112\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 例如要输出```需要1\`\`\`]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Markdown 编辑器</tag>
      </tags>
  </entry>
</search>
