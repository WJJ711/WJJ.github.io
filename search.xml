<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[序列化流]]></title>
    <url>%2F2019%2F04%2F24%2F%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[打印流]]></title>
    <url>%2F2019%2F04%2F24%2F%E6%89%93%E5%8D%B0%E6%B5%81%2F</url>
    <content type="text"><![CDATA[第四章 打印流4.1 概述平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。 4.2 PrintStream类构造方法 public PrintStream(String fileName)： 使用指定的文件名创建一个新的打印流。 构造举例，代码如下： 1PrintStream ps = new PrintStream("ps.txt")； 改变打印流向System.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个”小把戏”，改变它的流向。 1234567891011121314public class PrintDemo &#123; public static void main(String[] args) throws IOException &#123; // 调用系统的打印流,控制台直接输出97 System.out.println(97); // 创建打印流,指定文件的名称 PrintStream ps = new PrintStream("ps.txt"); // 设置系统的打印流流向,输出到ps.txt System.setOut(ps); // 调用系统的打印流,ps.txt中输出97 System.out.println(97); &#125;&#125; 4.3 标准输入输出流System类中的字段：in，out。 它们各代表了系统标准的输入和输出设备。 默认输入设备是键盘，输出设备是显示器。 System.in的类型是InputStream. System.out的类型是PrintStream是OutputStream的子类FilterOutputStream 的子类. 4.4流的重定向 输入流重定向 12345678public class IO10 &#123; public static void main(String[] args) throws IOException &#123; System.setIn(new FileInputStream("in.txt"));//重定向，读该文件中的第一行数据 Scanner scanner = new Scanner(System.in); String s = scanner.nextLine(); System.out.println(s); &#125;&#125; 2.输出流重定向 1234567891011public class IO10 &#123; public static void main(String[] args) throws IOException &#123; System.setIn(new FileInputStream("in.txt"));//输入流重定向 System.setOut(new PrintStream("copy.txt"));//输出流重定向 Scanner scanner = new Scanner(System.in); while (scanner.hasNext())&#123; String s = scanner.nextLine(); System.out.println(s); &#125; &#125;&#125; 重定向回控制台 123456789101112public class IO10 &#123; public static void main(String[] args) throws IOException &#123; //重定向到文件 System.setOut(new PrintStream("dest.txt")); System.out.println("i love you"); System.out.println("i miss you"); //重定向回控制台,用FileDescriptor.out重定向回控制台 System.setOut(new PrintStream(new FileOutputStream(FileDescriptor.out))); System.out.println("i love you"); System.out.println("i miss you"); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符流]]></title>
    <url>%2F2019%2F04%2F23%2F%E5%AD%97%E7%AC%A6%E6%B5%81%2F</url>
    <content type="text"><![CDATA[字符流=字节流+编码表。字符编码和字符集字符编码计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为编码 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。 编码:字符(能看懂的)–字节(看不懂的) 解码:字节(看不懂的)–&gt;字符(能看懂的) 字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。 编码表:生活中文字和计算机中二进制的对应规则 字符集 字符集 Charset：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。 计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。 可见，当指定了编码，它所对应的字符集自然就指定了，所以编码才是我们最终要关心的。 ASCII字符集 ： ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。 基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。 ISO-8859-1字符集： 拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。 ISO-8859-1使用单字节编码，兼容ASCII编码。 GBxxx字符集： GB就是国标的意思，是为了显示中文而设计的一套字符集。 GB2312：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。 GB18030：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。 Unicode字符集 ： Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。 它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。 UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则： 128个US-ASCII字符，只需一个字节编码。 拉丁文等字符，需要二个字节编码。 大部分常用字（含中文），使用三个字节编码。 其他极少使用的Unicode辅助字符，使用四字节编码。 UTF-8：可变长度来表示一个字符。 UTF-8，它定义了一种“区间规则”，这种规则可以和ASCII编码保持最大程度的兼容： 它将Unicode编码为00000000-0000007F的字符，用单个字节来表示 0111 1111 = 7F 它将Unicode编码为00000080-000007FF的字符用两个字节表示 它将Unicode编码为00000800-0000FFFF的字符用3字节表示 1字节 0xxxxxxx 2字节 110xxxxx 10xxxxxx 3字节 1110xxxx 10xxxxxx 10xxxxxx 第三章 字符流 当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。 3.1字符输出流【Writer】java.io.Writer抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。 void write(int c) 写入单个字符。 void write(char[] cbuf)写入字符数组。 abstract void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 void write(String str)写入字符串。 void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。 void flush()刷新该流的缓冲。 void close() 关闭此流，但要先刷新它。 3.2 FileWriter类java.io.FileWriter类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 构造方法 FileWriter(File file)： 创建一个新的 FileWriter，给定要读取的File对象。 FileWriter(String fileName)： 创建一个新的 FileWriter，给定要读取的文件的名称。 当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。 构造举例，代码如下： 12345678910public class FileWriterConstructor &#123; public static void main(String[] args) throws IOException &#123; // 使用File对象创建流对象 File file = new File("a.txt"); FileWriter fw = new FileWriter(file); // 使用文件名称创建流对象 FileWriter fw = new FileWriter("b.txt"); &#125;&#125; 3.3 转换流 OutputStreamWriter类转换流java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。 构造举例，代码如下： 12OutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream("out.txt"));OutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream("out.txt") , "GBK"); 指定编码写出12345678910111213141516171819public class OutputDemo &#123; public static void main(String[] args) throws IOException &#123; // 定义文件路径 String FileName = "E:\\out.txt"; // 创建流对象,默认UTF8编码 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName)); // 写出数据 osw.write("你好"); // 保存为6个字节 osw.close(); // 定义文件路径 String FileName2 = "E:\\out2.txt"; // 创建流对象,指定GBK编码 OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),"GBK"); // 写出数据 osw2.write("你好");// 保存为4个字节 osw2.close(); &#125;&#125; 转换流理解图解转换流是字节与字符间的桥梁！ 3.4 字符输入流【Reader】java.io.Reader抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。 public void close() ：关闭此流并释放与此流相关联的任何系统资源。 public int read()： 从输入流读取一个字符。 public int read(char[] cbuf)： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。 3.5 FileReader类java.io.FileReader类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 小贴士： 字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。 idea中UTF-8 字节缓冲区：一个字节数组，用来临时存储字节数据。 构造方法 FileReader(File file)： 创建一个新的 FileReader ，给定要读取的File对象。 FileReader(String fileName)： 创建一个新的 FileReader ，给定要读取的文件的名称。 当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。 构造举例，代码如下： 12345678910public class FileReaderConstructor throws IOException&#123; public static void main(String[] args) &#123; // 使用File对象创建流对象 File file = new File("a.txt"); FileReader fr = new FileReader(file); // 使用文件名称创建流对象 FileReader fr = new FileReader("b.txt"); &#125;&#125; 3.6 转换流 InputStreamReader类转换流java.io.InputStreamReader，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。 构造举例，代码如下： 12InputStreamReader isr = new InputStreamReader(new FileInputStream("in.txt"));InputStreamReader isr2 = new InputStreamReader(new FileInputStream("in.txt") , "GBK"); 指定编码读取指定编码读取1234567891011121314151617181920212223public class ReaderDemo2 &#123; public static void main(String[] args) throws IOException &#123; // 定义文件路径,文件为gbk编码 String FileName = "E:\\file_gbk.txt"; // 创建流对象,默认UTF8编码 InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName)); // 创建流对象,指定GBK编码 InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , "GBK"); // 定义变量,保存字符 int read; // 使用默认编码字符流读取,乱码 while ((read = isr.read()) != -1) &#123; System.out.print((char)read); // ��Һ� &#125; isr.close(); // 使用指定编码字符流读取,正常解析 while ((read = isr2.read()) != -1) &#123; System.out.print((char)read);// 大家好 &#125; isr2.close(); &#125;&#125; 3.7 练习：转换文件编码将GBK编码的文本文件，转换为UTF-8编码的文本文件。 案例分析 指定GBK编码的转换流，读取文本文件。 使用UTF-8编码的转换流，写出文本文件。 123456789101112131415161718192021222324252627282930313233343536package day24_IO;import java.io.*;public class IO04 &#123; public static void main(String[] args) &#123; // 1.定义文件路径 String srcFile = "a.txt"; String destFile = "file_utf8.txt"; // 2.创建流对象 // 2.1 转换输入流,指定GBK编码 try(Reader isr = new InputStreamReader(new FileInputStream(srcFile),"GBK"); // 2.2 转换输出流,默认utf8编码 Writer osw = new OutputStreamWriter(new FileOutputStream(destFile),"UTF-8"))&#123; // 3.读写数据 // 3.1 定义数组 char[] cbuf = new char[1024]; // 3.2 定义长度 int len; // 3.3 循环读取 while ((len = isr.read(cbuf))!=-1) &#123; // 循环写出 System.out.print(new String(cbuf,0,len)); osw.write(cbuf,0,len); &#125; &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 3.8 字符缓冲流构造方法 public BufferedReader(Reader in) ：创建一个 新的缓冲输入流。 public BufferedWriter(Writer out)： 创建一个新的缓冲输出流。 构造举例，代码如下： 1234// 创建字符缓冲输入流BufferedReader br = new BufferedReader(new FileReader("br.txt"));// 创建字符缓冲输出流BufferedWriter bw = new BufferedWriter(new FileWriter("bw.txt")); 特有方法字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。 BufferedReader：public String readLine(): 读一行文字。 BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。 readLine方法演示，代码如下： 1234567891011121314151617181920212223package day24_IO;import java.io.*;public class IO05 &#123; public static void main(String[] args) &#123; try (BufferedReader reader=new BufferedReader(new FileReader("a.txt")); BufferedWriter writer=new BufferedWriter(new FileWriter("dest.txt")))&#123; String s; while ((s=reader.readLine())!=null)&#123; writer.write(s); writer.newLine(); &#125; writer.flush(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字节流]]></title>
    <url>%2F2019%2F04%2F22%2F%E5%AD%97%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[第一章 IO流的四个基类 输入流 输出流 字节流 字节输入流InputStream 字节输出流OutputStream 字符流 字符输入流Reader 字符输出流Writer 第二章 字节流 2.1 一切皆为字节一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。 2.2 字节输出流【OutputStream】java.io.OutputStream抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。 public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。 public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len个字节，从偏移量 off开始输出到此输出流。 public abstract void write(int b) ：将指定的字节输出流。 小贴士： close方法，当完成流的操作时，必须调用此方法，释放系统资源。 2.3 FileOutputStream类字节流写数据的常见问题1OutputStream os=new FileOutputStream(dest); 这句话做了以下事情 判断流的指向的文件是否存在，如果不存在，就创建该文件 在内存中创建流对象 在流对象和文件之间创建数据流通的通道 OutputStream有很多子类，我们从最简单的一个子类开始。 java.io.FileOutputStream类是文件输出流，用于将数据写出到文件。 构造方法 public FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name)： 创建文件输出流以指定的名称写入文件。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。 写出字节数据123456789101112public class IO02 &#123; public static void main(String[] args) throws IOException &#123; //1创建源 File dest=new File("a.txt"); //2创建流 OutputStream os=new FileOutputStream(dest); //3操作 os.write(97);//0011 0001 //4关流，释放资源 os.close(); &#125;&#125; 小贴士： 虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。 流操作完毕后，必须释放系统资源，调用close方法，千万记得。 写出字节数组：write(byte[] b)，每次可以写出数组中的数据，代码使用演示： 1234567891011121314public class IO02 &#123; public static void main(String[] args) throws IOException &#123; //1创建源 File dest=new File("a.txt"); //2创建流 OutputStream os=new FileOutputStream(dest); //3操作 byte[] bytes="hello io".getBytes(); os.write(bytes); //4关流，释放资源 os.close(); &#125;&#125; 写出指定长度字节数组：write(byte[] b, int off, int len) ,每次写出从off索引开始，len个字节，代码使用演示： 123456789101112131415public class IO02 &#123; public static void main(String[] args) throws IOException &#123; //1创建源 File dest=new File("a.txt"); //2创建流 OutputStream os=new FileOutputStream(dest); //3操作 byte[] bytes="hello io".getBytes(); os.write(bytes,6,2);//只写入io //4关流，释放资源 os.close(); &#125;&#125;输出结果：io 数据追加续写经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？ public FileOutputStream(File file, boolean append)： 创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name, boolean append)： 创建文件输出流以指定的名称写入文件。 这两个构造方法，参数中都需要传入一个boolean类型的值，true 表示追加数据，false 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示： 12345678910111213public class IO02 &#123; public static void main(String[] args) throws IOException &#123; //1创建源 File dest=new File("a.txt"); //2创建流 OutputStream os=new FileOutputStream(dest,true); //3操作 byte[] bytes="hello io\r\n".getBytes(); os.write(bytes); //4关流，释放资源 os.close(); &#125;&#125; 写出换行 回车符\r和换行符\n ： 回车符：回到一行的开头（return）。 换行符：下一行（newline）。 系统中的换行： Windows系统里，每行结尾是 回车+换行 ，即\r\n； Unix系统里，每行结尾只有 换行 ，即\n； Mac系统里，每行结尾是 回车 ，即\r。从 Mac OS X开始与Linux统一。 经典IO代码1234567891011121314151617181920212223242526272829303132import java.io.*;public class IO02 &#123; public static void main(String[] args) &#123; //1创建源 File dest = new File("a.txt"); //2创建流 OutputStream os = null; try &#123; os = new FileOutputStream(dest, true); //3操作 // os.write(97);//0011 0001 byte[] bytes = "hello io\r\n".getBytes(); os.write(bytes); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4关流，释放资源 if (null != os) &#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; try-with-resourcesJDK1.7以后 public interface AutoCloseable ()中里面放的是资源的申明，什么是资源呢？实现了AutoCloseable接口的对象就是资源 格式： 12345try (创建流对象语句，如果多个,使用';'隔开) &#123; // 读写数据&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 代码使用演示： 12345678910111213141516import java.io.*;public class IO02 &#123; public static void main(String[] args) &#123; String s="hello io\r\n"; try (OutputStream os=new FileOutputStream("a.txt",true))&#123; os.write(s.getBytes()); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2.4 字节输入流【InputStream】java.io.InputStream抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。 public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。 public abstract int read()： 从输入流读取数据的下一个字节。 public int read(byte[] b)： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。 小贴士： close方法，当完成流的操作时，必须调用此方法，释放系统资源。 2.5 FileInputStream类java.io.FileInputStream类是文件输入流，从文件中读取字节。 构造方法 FileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 FileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出FileNotFoundException 。 读取字节数据 读取字节：read方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回-1，代码使用演示： 123456789101112131415public class IO03 &#123; public static void main(String[] args) &#123; try (InputStream is=new FileInputStream("a.txt"))&#123; int read; while ((read=is.read())!=-1)&#123; System.out.print((char) read); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 小贴士： 虽然读取了一个字节，但是会自动提升为int类型。 流操作完毕后，必须释放系统资源，调用close方法，千万记得。 2 使用字节数组读取：read(byte[] b)，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回-1 ，代码使用演示： 12345678910111213141516public class IO03 &#123; public static void main(String[] args) &#123; try (InputStream is=new FileInputStream("a.txt"))&#123; byte[] bytes=new byte[1024]; int len=-1; while ((len=is.read(bytes))!=-1)&#123; System.out.print(new String(bytes,0,len)); // len 每次读取的有效字节个数 &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 小贴士： 使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。 InputStream is=new FileInputStream(&quot;a.txt&quot;) 做了以下3件事 判断文件是不是存在，如果不存在，就抛出异常。 在内存中创建FileInputStream对象 在对象和文件之间，构建数据传输通道 文件复制图片复制： 123456789101112131415161718public class Copy &#123; public static void main(String[] args) &#123; //创建源，选择流 try (InputStream is=new FileInputStream("D:/picture/my.jpg"); OutputStream os=new FileOutputStream("mygirl.jpg"))&#123; //读数据，写数据 byte[] bytes=new byte[1024]; int len; while ((len=is.read(bytes))!=-1)&#123; os.write(bytes,0,len); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 第三章 缓冲流1.1 概述缓冲流,也叫高效流，是对4个基本的FileXxx 流的增强，所以也是4个流，按照数据类型分类： 字节缓冲流：BufferedInputStream，BufferedOutputStream 字符缓冲流：BufferedReader，BufferedWriter 缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。 1.2 字节缓冲流构造方法 public BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。 public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。 构造举例，代码如下： 1234// 创建字节缓冲输入流BufferedInputStream bis = new BufferedInputStream(new FileInputStream("bis.txt"));// 创建字节缓冲输出流BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("bos.txt")); 如图所示，缓冲流在磁盘到端口（端口到磁盘）进行加速，默认size为8k缓存。 bytes数组，在端口和应用程序（内存）进行加速。二次加速 效率测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.io.*;public class Copy &#123; public static void main(String[] args) &#123; long time1=System.currentTimeMillis(); //copy1("D:/picture/mygirl.jpg","p1.jpg");//18225ms //copy2("D:/picture/mygirl.jpg","p1.jpg");//67ms,//加入BufferedInputStream、BufferedOutputSteam copy3("D:/picture/mygirl.jpg","p1.jpg");//17ms //加入BufferedInputStream、BufferedOutputSteam和缓存数组 long time2=System.currentTimeMillis(); System.out.println(time2-time1+"ms"); &#125; //一个字节一个字节的拷 public static void copy1(String src,String dest)&#123; //创建源，选择流 try (InputStream is=new FileInputStream(src); OutputStream os=new FileOutputStream(dest))&#123; //读数据，写数据 int data; while ((data=is.read())!=-1)&#123; os.write(data); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //加入BufferedInputStream、BufferedOutputSteam public static void copy2(String src,String dest)&#123; //12选择源创建流 try (InputStream is=new BufferedInputStream(new FileInputStream(src)); OutputStream os=new BufferedOutputStream(new FileOutputStream(dest)))&#123; //操作 int data; while ((data=is.read())!=-1)&#123; os.write(data); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //加入BufferedInputStream、BufferedOutputSteam和缓存数组 public static void copy3(String src,String dest)&#123; //12创建源，选择流 try (InputStream is=new BufferedInputStream(new FileInputStream(src)); OutputStream os=new BufferedOutputStream(new FileOutputStream(dest)))&#123; byte[] bytes=new byte[1024]; int len=-1; while ((len=is.read(bytes))!=-1)&#123; os.write(bytes,0,len); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找模板]]></title>
    <url>%2F2019%2F04%2F19%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[第一个与key值相等的元素1234567891011121314151617181920/** * 第一个与key值相等的元素 */public class BinarySearch01 &#123; public static int search(int[] arr,int key)&#123; int left=0; int right=arr.length-1; while (left&lt;right)&#123; int mid=left+((right-left)&gt;&gt;1);//因为这里是right=mid所以不用+1,注意，这里括号一个都不能少&gt;&gt;优先级较低 if(arr[mid]&gt;=key)&#123;//说明第一个与key相等的值在mid或者mid左边 right=mid; &#125;else&#123; left=mid+1;//说明第一个与key相等的值在mid右边 &#125; &#125; if(arr[left]==key) return left; else return -1; &#125;&#125; 最后一个等于key的元素123456789101112131415161718192021/** * 最后一个等于key的元素 */public class BinarySearch02 &#123; public static int search(int[] arr,int key)&#123; int left=0; int right=arr.length-1; while (left&lt;right)&#123; int mid=left+((right-left+1)&gt;&gt;1);//因为求最后一个等于key的元素，left要向右边逼近，是left=mid //这里如果不加1会死循环，因为mid向下取整，例如right=9，mid永远=8，left永远等于8 if(arr[mid]&lt;=key)&#123;//该位置在mid右边或者mid left=mid; &#125;else &#123; right=mid-1;//该位置在mid左边 &#125; &#125; if(arr[left]==key) return left; else return -1; &#125;&#125; 查找最后一个小于等于key值的元素1234567891011121314151617181920212223/** * 查找最后一个小于等于key值的元素 */public class BinarySearch03 &#123; public static int search(int[] arr,int key)&#123; int left=0; int right=arr.length-1; while (left&lt;right)&#123; int mid=left+((right-left+1)&gt;&gt;1);//这里括号一个都不能少&gt;&gt;优先级较低，这里必须+1,因为找的最后一个，left向右边逼近，如果没有+1，right=9，left=8，则mid和left永远等于8，死循环 if(arr[mid]&lt;=key)&#123;//在mid处或者mid的右边 left=mid; &#125;else &#123;//在mid左边 right=mid-1; &#125; &#125; if(arr[left]&lt;=key)&#123; return left; &#125;else &#123; return -1; &#125; &#125;&#125; 查找第一个大于等于key的值123456789101112131415161718192021/** * 查找第一个大于等于key的值 */public class BinarySearch04 &#123; public static int search(int[] arr,int key)&#123; int left=0; int right=arr.length-1; while (left&lt;right)&#123; int mid=left+((right-left)&gt;&gt;1); if(arr[mid]&gt;=key)&#123;//在mid处，或者mid的左边,right向左边逼近，这里括号一个都不能少，&gt;&gt;优先级较低 right=mid; &#125;else&#123;//在mid右边 left=mid+1; &#125; &#125; if(arr[left]&gt;=key)&#123; return left; &#125; else return -1; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7种排序算法]]></title>
    <url>%2F2019%2F04%2F19%2F7%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[​ 从理论上讲：快排速度会高于堆排 快排移动指针都是连续的，但是堆排每次都是父子节点进行比较，它们不是连续的，不能很好的利用CPU的缓存机制 堆排的堆化操作会打乱本来可能已经有序的序列，所以比较操作比快排多 快速排序123456789101112131415161718192021222324252627public class QuickSort &#123; public static void sort(int[] arr)&#123; if(arr==null||arr.length&lt;=1) return; sort(arr,0,arr.length-1); &#125; private static void sort(int[] arr, int left, int right) &#123; if(left&gt;=right) return; int pivotPos=partition(arr,left,right); sort(arr,left,pivotPos-1); sort(arr,pivotPos+1,right); &#125; private static int partition(int[] arr, int left, int right) &#123; int pivot=arr[left]; while (left&lt;right)&#123; //必须从右边开始 while (arr[right]&gt;=pivot&amp;&amp;left&lt;right) right--; arr[left]=arr[right]; while (arr[left]&lt;=pivot&amp;&amp;left&lt;right)left++; arr[right]=arr[left]; &#125; arr[left]=pivot; return left; &#125; 堆排序1234567891011121314151617181920212223242526272829303132333435public class HeapSort &#123; public static void sort(int[] arr)&#123; int len=arr.length-1; buildMaxHeap(arr,len); for(int i=0;i&lt;len-1;i++)&#123; int temp=arr[1]; arr[1]=arr[len-i]; arr[len-i]=temp; adjustDown(arr,1,len-i-1); &#125; &#125; //建堆 private static void buildMaxHeap(int[] arr,int len) &#123; for(int i=len/2;i&gt;=1;i--)&#123; adjustDown(arr,i,len); &#125; &#125;//调整 private static void adjustDown(int[] arr, int parent,int len) &#123; arr[0]=arr[parent]; for(int child=parent*2;child&lt;=len;child*=2)&#123; if(child+1&lt;=len&amp;&amp;arr[child]&lt;arr[child+1])&#123; child++; &#125; if(arr[0]&gt;=arr[child])&#123;//注意这里一定是arr[0]，之前写成了arr[parent]调了好久。。。 break; &#125; else &#123; arr[parent]=arr[child]; parent=child; &#125; &#125; arr[parent]=arr[0]; &#125;&#125; 归并排序123456789101112131415161718192021222324252627282930313233343536public class MergeSort &#123; public static void sort(int[] arr)&#123; sort(arr,0,arr.length-1); &#125; private static void sort(int[] arr, int low, int high) &#123; if(low&lt;high)&#123; int mid=(low+high)&gt;&gt;1; sort(arr,low,mid);//左边排序 sort(arr,mid+1,high);//右边排序 merge(arr,low,mid,high); &#125; &#125; private static void merge(int[] arr, int low, int mid, int high) &#123; int[] temp=new int[high-low+1]; int k=0; int i=low,j=mid+1; while (i&lt;=mid&amp;&amp;j&lt;=high)&#123; if(arr[i]&lt;=arr[j])&#123; temp[k++]=arr[i++]; &#125;else &#123; temp[k++]=arr[j++]; &#125; &#125; while (i&lt;=mid)&#123; temp[k++]=arr[i++]; &#125; while (j&lt;=high)&#123; temp[k++]=arr[j++]; &#125; for(i=0;i&lt;k;i++)&#123; arr[low+i]=temp[i]; &#125; &#125;&#125; 希尔排序缩小增量排序 123456789101112131415161718public class ShellSort &#123; public static void sort(int[] arr)&#123; if(arr==null||arr.length&lt;=1)return; for(int gap=arr.length/2;gap!=0;gap/=2)&#123; for(int i=gap;i&lt;arr.length;i++)&#123; int j; int current=arr[i]; for(j=i-gap;j&gt;=0;j-=gap)&#123; if(current&gt;arr[j]) break; arr[j+gap]=arr[j]; &#125; arr[j+gap]=current; &#125; &#125; &#125;&#125; 插入排序123456789101112131415161718public class InsertSort &#123; public static void sort(int[] arr) &#123; if (arr == null || arr.length &lt;= 1) return; //要插入的次数 for (int i = 0; i &lt; arr.length - 1; i++) &#123; int current = arr[i + 1]; int j; for (j = i; j &gt;= 0; j--) &#123; if (current &gt;= arr[j]) &#123; break; &#125; arr[j + 1] = arr[j]; &#125; arr[j + 1] = current; &#125; &#125;&#125; 冒泡排序123456789101112131415161718public class BubbleSort &#123; public static void sort(int[] arr)&#123; if(arr==null||arr.length&lt;=1) return; for(int i=0;i&lt;arr.length-1;i++)&#123; boolean flg=true; for(int j=0;j&lt;arr.length-1-i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; int temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; flg=false; &#125; &#125; if(flg==true) break; &#125; &#125;&#125; 选择排序12345678910111213141516171819public class SelectSort &#123; public static void sort(int[] arr) &#123; if (arr == null || arr.length &lt;= 1) return; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int min = arr[i]; int index = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; min) &#123; min=arr[j]; index=j; &#125; &#125; int temp=arr[i]; arr[i]=min; arr[index]=temp; &#125; &#125;&#125; 测试与性能分析12345678910111213141516171819202122232425262728293031323334public class Test &#123; public static void main(String[] args) &#123; Random random = new Random(); int num = 10; int[] arr = new int[num]; for (int i = 0; i &lt; num; i++) &#123; arr[i] = random.nextInt(num * 10); &#125; long time1 = System.currentTimeMillis(); QuickSort.sort(arr); //SelectSort.sort(arr); // ShellSort.sort(arr); // System.out.println(Arrays.toString(arr)); // HeapSort.sort(arr); //MergeSort.sort(arr); long time2 = System.currentTimeMillis(); System.out.println(Arrays.toString(arr)); //System.out.println(num+"个数据冒泡排序用时："+(time2-time1)+"ms"); //1000000个数据冒泡排序用时：2004758ms // System.out.println(num+"个数据选择排序用时："+(time2-time1)+"ms"); //1000000个数据选择排序用时：453256ms // System.out.println("插入排序用时："+(time2-time1)); //1000000个数据插入排序用时：119165ms // System.out.println(num+"个数据希尔排序用时："+(time2-time1)+"ms"); //1000000个数据希尔排序用时：447ms // System.out.println(num + "个数据归并排序排序用时：" + (time2 - time1) + "ms"); //1000000个数据归并排序排序用时：391ms // System.out.println(num-1+"个数据堆排序排序用时："+(time2-time1)+"ms"); //999999个数据堆排序排序用时：353ms //System.out.println(num+"个数据快速排序用时："+(time2-time1)+"ms"); //1000000个数据快速排序用时：280ms &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[增强for循环与可变参数]]></title>
    <url>%2F2019%2F04%2F13%2F%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF%E4%B8%8E%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[增强for概述简化数组和Collection集合的遍历，内部使用迭代器实现 public interface Iterable&lt;T&gt;实现这个接口允许对象成为“foreach” 语句的目标。 格式：1234for(元素数据类型 变量 : 数组或者Collection集合) &#123; 使用变量即可，该变量就是元素&#125; 可变参数定义方法的时候不知道该定义多少个参数 格式1修饰符 返回值类型 方法名(数据类型… 变量名)&#123;&#125; 1234567891011public static int add(int... a)&#123; int sum=0; for(int i:a)&#123; sum+=i; &#125; return sum;&#125; public static void main(String[] args) &#123; System.out.println(add(1,2,3)); &#125; 注意： 这里的变量其实是一个数组 如果一个方法有可变参数，并且有多个参数，那么，可变参数肯定是最后一个. 解释：可变参数的参数个数不一定，编译器自动将传递过来的参数封装成数组，如果像下面这样，则参数全都赋值给了可变参数a。b和c没有进行赋值。所以可变参数a必须放在最后面 12public static int add(int... a,int b,int c)&#123;&#125;//这样定义是错误的 Arrays工具类中的一个方法public static &lt;T&gt; List&lt;T&gt; asList(T... a)//其实是一个视图 得到的List集合只能查改，不能增删。 而且List改变，其数组也会改变。 123456789101112131415161718192021public static void main(String[] args) &#123; String[] arr=&#123;"aa","bb","cc"&#125;; List&lt;String&gt; items=Arrays.asList(arr);//视图技术 //List&lt;String&gt; items= Arrays.asList("aa","bb","cc");//也可以这样 System.out.println(items.size()); //查，可以 for (String s:items)&#123; System.out.println(s+"---"+s.length()); &#125; //增，出现异常 // items.add("dd");//UnsupportedOperationException //删除，出现异常 //items.remove(0);//UnsupportedOperationException //改,可以 items.set(0,"wjj"); System.out.println(items);//[wjj, bb, cc] System.out.println(arr[0]);//wjj,也改变了原数组 &#125; 集合和数组的相互转换集合——-&gt;数组 1、Object[] toArray()//强烈不推荐！ 2、 &lt;T&gt; T[] toArray(T[] a)强烈推荐！ 数组——-&gt;集合 public static &lt;T&gt; List&lt;T&gt; asList(T... a)]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型Generics]]></title>
    <url>%2F2019%2F04%2F13%2F%E6%B3%9B%E5%9E%8BGenerics%2F</url>
    <content type="text"><![CDATA[概念​ 泛型是JDK1.5以后增加的，它可以帮助我们建立类型安全的集合。在使用了泛型的集合中，遍历时不必进行强制类型转换。JDK提供了支持泛型的编译器，将运行时的类型检查提前到了编译时执行，提高了代码可读性和安全性。 ​ 泛型的本质就是“数据类型的参数化”。 我们可以把“泛型”理解为数据类型的一个占位符(形式参数)，即告诉编译器，在调用泛型时必须传入实际类型。 泛型的好处A:提高了程序的安全性 B:将运行期遇到的问题转移到了编译期 C:省去了类型强转的麻烦 自定义泛型 我们可以在类的声明处增加泛型列表，如：&lt;T,E,K,V&gt;。 ​ 此处，字符可以是任何标识符，一般采用这4个字母。 泛型E像一个占位符一样表示“未知的某个数据类型”，我们在真正调用的时候传入这个“数据类型”。 泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。 泛型类›注意:泛型类型必须是引用类型 定义格式： 1修饰符 class 类名&lt;代表泛型的变量&gt; &#123; &#125; 例如，API中的ArrayList集合： 123456class ArrayList&lt;E&gt;&#123; public boolean add(E e)&#123; &#125; public E get(int index)&#123; &#125; ....&#125; 使用泛型： 即什么时候确定泛型。 在创建对象的时候确定泛型 例如，ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 此时，变量E的值就是String类型,那么我们的类型就可以理解为： 123456class ArrayList&lt;String&gt;&#123; public boolean add(String e)&#123; &#125; public String get(int index)&#123; &#125; ...&#125; 再例如，ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); 此时，变量E的值就是Integer类型,那么我们的类型就可以理解为： 123456class ArrayList&lt;Integer&gt; &#123; public boolean add(Integer e) &#123; &#125; public Integer get(int index) &#123; &#125; ...&#125; 含有泛型的方法定义格式： 1修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123; &#125; 例如， 123456class MyGenericMethod &#123; public &lt;T&gt; void show(T mvp) &#123; System.out.println(mvp); System.out.println(mvp.getClass());//返回T的类型 &#125;&#125; 使用格式：调用方法时，确定泛型的类型 123456789101112131415161718public class Test &#123; public static void main(String[] args) &#123; MyGenericMethod mm = new MyGenericMethod(); // 演示看方法提示 mm.show("aaa"); //输出结果 //aaa //class java.lang.String mm.show(123); //输出结果 // 123 //class java.lang.Integer mm.show(12.45); //输出结果 //12.45 //class java.lang.Double &#125;&#125; 含有泛型的接口定义格式： 1修饰符 interface接口名&lt;代表泛型的变量&gt; &#123; &#125; 例如， 12345public interface MyGenericInterface&lt;E&gt;&#123; public abstract void add(E e); public abstract E getE(); &#125; 使用格式： 1、定义类时确定泛型的类型 例如 1234567891011public class MyImp1 implements MyGenericInterface&lt;String&gt; &#123; @Override public void add(String e) &#123; // 省略... &#125; @Override public String getE() &#123; return null; &#125;&#125; 此时，泛型E的值就是String类型。 2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型 例如 1234567891011public class MyImp2&lt;E&gt; implements MyGenericInterface&lt;E&gt; &#123; @Override public void add(E e) &#123; // 省略... &#125; @Override public E getE() &#123; return null; &#125;&#125; 确定泛型： 123456789/* * 使用 */public class GenericInterface &#123; public static void main(String[] args) &#123; MyImp2&lt;String&gt; my = new MyImp2&lt;String&gt;(); my.add("aa"); &#125;&#125; 泛型通配符12345678class Animal &#123;&#125;class Dog extends Animal &#123;&#125;class Cat extends Animal &#123;&#125; 泛型通配符&lt;?&gt; 任意类型，如果没有明确，那么就是Object以及任意的Java类了 1234Collection&lt;?&gt; c1 = new ArrayList&lt;Animal&gt;();Collection&lt;?&gt; c2 = new ArrayList&lt;Dog&gt;();Collection&lt;?&gt; c3 = new ArrayList&lt;Cat&gt;();Collection&lt;?&gt; c4 = new ArrayList&lt;Object&gt;();//均可编译通过 ? extends E 向下限定，E及其子类 1234Collection&lt;? extends Animal&gt; c5 = new ArrayList&lt;Animal&gt;();Collection&lt;? extends Animal&gt; c6 = new ArrayList&lt;Dog&gt;();Collection&lt;? extends Animal&gt; c7 = new ArrayList&lt;Cat&gt;();Collection&lt;? extends Animal&gt; c8 = new ArrayList&lt;Object&gt;();//报错 ? super E 向上限定，E及其父类 1234 Collection&lt;? super Animal&gt; c9 = new ArrayList&lt;Animal&gt;();Collection&lt;? super Animal&gt; c10 = new ArrayList&lt;Dog&gt;();//报错 Collection&lt;? super Animal&gt; c11 = new ArrayList&lt;Cat&gt;();//报错Collection&lt;? super Animal&gt; c12 = new ArrayList&lt;Object&gt;(); Collection接口中的泛型方法&lt;T&gt; T[] toArray(T[] a) a表示要存储此集合的数组，如果它足够大（大于集合长度），则存储到a 否则将重新分配T类型的新数组 123456789101112public class Demo &#123; public static void main(String[] args) &#123; List&lt;String&gt; c = new ArrayList&lt;&gt;(); ((ArrayList&lt;String&gt;) c).add("hello"); ((ArrayList&lt;String&gt;) c).add("hello"); ((ArrayList&lt;String&gt;) c).add("hello"); String[] arr1=new String[3]; String[] arr2=c.toArray(arr1); System.out.println(arr2==arr1);//true。若arr1长度小于c中的长度，则结果为flase &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用链表实现LRU缓存淘汰算法]]></title>
    <url>%2F2019%2F04%2F12%2F%E7%94%A8%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0LRU%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[原理LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。 实现最常见的实现是使用一个链表保存缓存数据，详细算法实现如下： LRU（Least Recently Used）: （缓存大小是n） 链表： 要缓存的数据已经在链表中存在 在链表中将该数据删除，并在头结点处添加该结点 要缓存的数据在链表中不存在 a. 链表中空间够用，直接在头结点添加 b.链表空间不够用，删除最后一个结点，并且在头结点添加 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class LRU &#123; private LinkedList cache=null; private int size; public int getSize() &#123; return size; &#125; //设置缓存大小 private int defaultLength; public void setDefaultLength(int defaultLength) &#123; this.defaultLength = defaultLength; &#125;//构造函数 public LRU(int defaultLength) &#123; this.defaultLength = defaultLength; cache=new LinkedList(); &#125; public void add(Object e)&#123; if(cache.contains(e))&#123; cache.remove(e); &#125;else &#123; if(size==defaultLength)&#123; cache.removeLast(); &#125;else&#123; size++; &#125; &#125; cache.addFirst(e); &#125; public static void main(String[] args) &#123; LRU cache=new LRU(3); cache.add("aa"); cache.add("bb"); cache.add("cc"); cache.add("bb"); cache.add("kk"); System.out.println(cache); &#125; @Override public String toString() &#123; return "LRU&#123;" + "cache=" + cache + ", size=" + size + '&#125;'; &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[List接口]]></title>
    <url>%2F2019%2F04%2F12%2FList%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[List接口List是有序、可重复的容器。 ​ 有序：List中每个元素都有索引标记。可以根据元素的索引标记(在List中的位置)访问元素，从而精确控制这些元素。 ​ 可重复：List允许加入重复的元素。更确切地讲，List通常允许满足 e1.equals(e2) 的元素重复加入容器。 Interface ListIterator 用于允许程序员沿任一方向遍历列表的迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置。 其光标位置 始终位于通过调用previous()返回的元素和通过调用next()返回的元素next() 。 长度为n的列表的迭代器具有n+1可能的光标位置（位置为元素之间） 123456789101112131415161718192021public class Test &#123; public static void main(String[] args) &#123; List&lt;String&gt; list=new ArrayList&lt;&gt;(); list.add("hello"); list.add("world"); list.add("java"); ListIterator it=list.listIterator(); while (it.hasNext())&#123; String s = (String) it.next(); System.out.println(s+"---"+ s.length()); &#125; System.out.println("------------"); while (it.hasPrevious())&#123; String s = (String) it.previous(); System.out.println(s+"----"+s.length()); &#125; System.out.println(it.previousIndex());//-1 System.out.println(it.nextIndex());//0 &#125;&#125; previous和next位置只差了1，it指向两元素中间]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collection接口]]></title>
    <url>%2F2019%2F04%2F11%2FCollection%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[容器的接口层次结构图 Collection接口中定义的方法增减的操作返回值：原集合发生改变则返回true，否则返回false Collection 表示一组对象，它是集中、收集的意思。Collection接口的两个子接口是List、Set接口。 由于List、Set是Collection的子接口，意味着所有List、Set的实现类都有上面的方法。我们下一节中，通过ArrayList实现类来测试上面的方法。 Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下： 对集合遍历 Object[] toArray() 把集合转成数组，可以实现集合的遍历 但是对转变后的数组改变，不会对原集合造成影响 Iterator iterator() 迭代器，集合的专用遍历方式 迭代器Iterator()迭代器实现原理在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。 特别注意用迭代器迭代的时候，如果要对集合进行修改，必须要用迭代器修改，不能用集合修改！ 为什么Iterator要设置成一个接口，而不是一个类？ 答：因为有一些集合，是可以存储重复数据的，有些集合不能存储重复数据。有些集合是有序的，有些集合是无序的。原因是具体的集合子类底层实现的数据结构不一样。所以不能使用单独的类来实现对所有集合的遍历，所以应该设置成抽象类或者接口 那为什么不设置成抽象类，而要设置成接口呢？ 答：因为很多集合可能已经继承了其它集合类，就不能再继承这个抽象类。所以才将Iterator设置成一个接口。 那应该怎么去实现Iterator接口？ 答：Iterator iter=c.iterator(); 具体子类对象应该清楚该集合的数据结构。一个类清楚另外一个类的数据结构，那它应该设计出一个内部类。即该集合类的内部类实现Iterator接口。 在ArrayList中实现如下： 123456private class Itr implements Iterator&lt;E&gt; &#123; //重写Iterator接口中的hasNext()，next() remove() &#125;public Iterator&lt;E&gt; iterator() &#123; return new Itr();//重写Iterable接口中的iterator（）方法&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常机制Exception]]></title>
    <url>%2F2019%2F04%2F11%2F%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[世界上最真情的相依,是你在try我在catch,无论你发神马脾气,我都默默接受,静静处理 异常机制的本质就是当程序出现错误，程序安全退出的机制。 JVM的默认处理 jvm发现运算是已经违反了数学运算规则,java将这种常见的问题进行描述,并封装成了对象叫做ArithmeticException 当除0运算发生后,jvm将该问题打包成了一个异常对象. 并将对象抛给调用者main函数,new ArithmeticException(“/by zero”); main函数收到这个问题时,有两种处理方式: 1,自己将该问题处理,然后继续运行 2,自己没有针对的处理方式,只有交给调用main的jvm来处理 JVM有一个默认的异常处理机制,就将该异常进行处理.并将该异常的名称,异常的信息.异常出现的位置打印在了控制台上 同时将程序停止运行 异常分类 ## Error ​ Error是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM(Java 虚拟机)出现的问题。例如，Java虚拟机运行错误(Virtual Machine Error)，当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机(JVM)一般会选择线程终止。 ​ Error表明系统JVM已经处于不可恢复的崩溃状态中。我们不需要管它。 ## Exception Exception是程序本身能够处理的异常，如：空指针异(NullPointerException)、数组下标越界异常(ArrayIndexOutOfBoundsException)、类型转换异常(ClassCastException)、算术异常(ArithmeticException)等。 ​ Exception类是所有异常类的父类，其子类对应了各种各样可能出现的异常事件。 通常Java的异常可分为： ​ 1. RuntimeException 运行时异常——（这种情况一般都是代码不够严谨，所以推荐修改代码逻辑解决） ​ 2. CheckedException 已检查异常 Error与Exception的区别 我在开车之前要检查一下车有没有问题。如果有问题，则是CheckedException 已检查异常 我开着车走在路上，一头猪冲在路中间，我刹车。这叫一个RuntimeException 运行时异常。 我开着车在路上，发动机坏了，我停车，这叫错误。系统处于不可恢复的崩溃状态。发动机什么时候坏?我们普通司机能管吗?不能。发动机什么时候坏是汽车厂发动机制造商的事。 Java是采用面向对象的方式来处理异常的。处理过程： 抛出异常：在执行一个方法时，如果发生异常，则这个方法生成代表该异常的一个对象，停止当前执行路径，并把异常对象提交给JRE。 throws 捕获异常：JRE得到该异常后，寻找相应的代码来处理该异常。JRE在方法的调用栈中查找，从生成异常的方法开始回溯，直到找到相应的异常处理代码为止。基本格式：try是检测异常,catch是用来捕获异常的,finally是用来结束资源的 ​ try...catch...finally 异常的处理方式之一：捕获异常1234567try&#123; //语句&#125;catch(异常类型 异常名)&#123; //处理&#125;finally&#123; &#125; 注意事项 try里面代码越少越好，最好只有可能发生异常的代码 当异常处理的代码执行结束以后，不会回到try语句去执行尚未执行的代码 如果发生了异常，异常对象会依次和catch语句进行匹配，如果匹配到了，就执行相应的catch语句，如果没有，则异常不会得到处理 ## 上面过程详细解析： 1. try： ​ try语句指定了一段代码，该段代码就是异常捕获并处理的范围。在执行过程中，当任意一条语句产生异常时，就会跳过该条语句中后面的代码。代码中可能会产生并抛出一种或几种类型的异常对象，它后面的catch语句要分别对这些异常做相应的处理。 ​ 一个try语句必须带有至少一个catch语句块或一个finally语句块 。 注意事项 ​ 当异常处理的代码执行结束以后，不会回到try语句去执行尚未执行的代码。 2. catch： ​ n-每个try语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常对象。 ​ n-常用方法，这些方法均继承自Throwable类 。 ​ u-toString ()方法，显示异常的类名和产生异常的原因 ​ u-getMessage()方法，只显示产生异常的原因，但不显示类名。 ​ u-printStackTrace()方法，用来跟踪异常事件发生时堆栈的内容。 ​ n-catch捕获异常时的捕获顺序： ​ u-如果异常类之间有继承关系，在顺序安排上需注意。越是顶层的类，越放在下面，再不然就直接把多余的catch省略掉。 也就是先捕获子类异常再捕获父类异常。 2. finally： finally的作用 •用于释放资源，在IO流操作和数据库操作中会见到 ​ n-有些语句，不管是否发生了异常，都必须要执行，那么就可以把这样的语句放到finally语句块中。 ​ n-通常在finally中关闭程序块已打开的资源，比如：关闭文件流、释放数据库连接等。 try-catch-finally语句块的执行过程： ​ try-catch-finally程序块的执行流程以及执行结果比较复杂。 ​ 基本执行过程如下： ​ 程序首先执行可能发生异常的try语句块。如果try语句没有出现异常则执行完后跳至finally语句块执行;如果try语句出现异常，则中断执行并根据发生的异常类型跳至相应的catch语句块执行处理。catch语句块可以有多个，分别捕获不同类型的异常。catch语句块执行完后程序会继续执行finally语句块。finally语句是可选的，如果有的话，则不管是否发生异常，finally语句都会被执行。 注意事项 ​ 1. 即使try和catch块中存在return语句，finally语句也会执行。是在执行完finally语句后再通过return退出。 ​ 2. finally语句块只有一种情况是不会执行的，那就是在执行finally之前遇到了System.exit(0)结束程序运行。 异常的处理方式之二：声明异常(throws子句) 当CheckedException产生时，不一定立刻处理它，可以再把异常throws出去。 在方法中使用try-catch-finally是由这个方法来处理异常。但是在一些情况下，当前方法并不需要处理发生的异常，而是向上传递给调用它的方法处理。 如果一个方法中可能产生某种异常，但是并不能确定如何处理这种异常，则应根据异常规范在方法的首部声明该方法可能抛出的异常。 如果一个方法抛出多个已检查异常，就必须在方法的首部列出所有的异常，之间以逗号隔开。 注意事项​ 1. 方法重写中声明异常原则：子类重写父类方法时，如果父类方法有声明异常，那么子类声明的异常范围不能超过父类声明的范围。 RuntimeException运行时异常​ 派生于RuntimeException的异常，如被 0 除、数组下标越界、空指针等，其产生比较频繁，处理麻烦，如果显式的声明或捕获将会对程序可读性和运行效率影响很大。 因此由系统自动检测并将它们交给缺省的异常处理程序(用户可不必对其处理)。 这类异常通常是由编程错误导致的，所以在编写程序时，并不要求必须使用异常处理机制来处理这类异常,经常需要通过增加“逻辑处理来避免这些异常” ArithmeticException异常：试图除以0 NullPointerException异常 ClassCastException异常 ArrayIndexOutOfBoundsException异常 NumberFormatException异常 ## 注意事项 ​ 1. 在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器(exception handler)。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。 运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。 CheckedException已检查异常所有不是RuntimeException的异常，统称为Checked Exception，又被称为“已检查异常”，如IOException、SQLException等以及用户自定义的Exception异常。 这类异常在编译时就必须做出处理，否则无法通过编译。 ![异常体系](D:\blog\WJJ711\source_posts\异常机制\异常体系.png 抛出异常throw在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。 在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？ 创建一个异常对象。封装一些提示信息(信息可以自己编写)。 需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。 throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。 使用格式： 1throw new 异常类名(参数); 例如： 123throw new NullPointerException("要访问的arr数组不存在");throw new ArrayIndexOutOfBoundsException("该索引在数组中不存在，已超出范围"); 通过下面程序演示下throw的使用。 123456789101112131415161718192021222324252627public class ThrowDemo &#123; public static void main(String[] args) &#123; //创建一个数组 int[] arr = &#123;2,4,52,2&#125;; //根据索引找对应的元素 int index = 4; int element = getElement(arr, index); System.out.println(element); System.out.println("over"); &#125; /* * 根据 索引找到数组中对应的元素 */ public static int getElement(int[] arr,int index)&#123; //判断 索引是否越界 if(index&lt;0 || index&gt;arr.length-1)&#123; /* 判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。 这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 */ throw new ArrayIndexOutOfBoundsException("角标越界了~~~"); &#125; int element = arr[index]; return element; &#125;&#125; 注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。 那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。 自定义异常 在程序中，可能会遇到JDK提供的任何标准异常类都无法充分描述清楚我们想要表达的问题，这种情况下可以创建自己的异常类，即自定义异常类。 自定义异常类只需从Exception类或者它的子类派生一个子类即可。 自定义异常类如果继承Exception类，则为受检查异常，必须对其进行处理;如果不想处理，可以让自定义异常类继承运行时异常RuntimeException类。 习惯上，自定义异常类应该包含2个构造器：一个是默认的构造器，另一个是带有详细信息的构造器。 异常类如何定义: 自定义一个编译期异常: 自定义类 并继承于Exception。 自定义一个运行时期的异常类:自定义类 并继承于RuntimeException。 提供构造方法：一个无参的，一个有参的 123456public MyException() &#123;//一个无参的 &#125; public MyException(String message) &#123; super(message);//一个有参的 &#125; 123456789101112131415161718192021222324252627public class Test&#123; public static void main(String[] args) &#123; Scanner scanner=new Scanner(System.in); int score=scanner.nextInt(); try &#123; check(score); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; System.out.println("over"); &#125; public static void check(int score) &#123; if(score&lt;0||score&gt;100) throw new MyException("分数不合理~"); &#125;&#125;class MyException extends RuntimeException&#123; public MyException() &#123; &#125; public MyException(String message) &#123; super(message); &#125;&#125; 输出结果 12345输入：120casual.MyException: 分数不合理~ at casual.Test.check(Test.java:21) at casual.Test.main(Test.java:11)over 异常注意事项均是指编译时异常 子类重写父类方法时，子类不能抛出父类没有的异常 如果被重写的方法没有异常抛出,那么子类的方法绝对不可以抛出异常,如果子类方法内有异常发生,那么子类只能try,不能throws 因为多态，父类引用指向子类对象。所以子类只能比父类好！ 面试题123456789101112131415161718192021222324252627282930package casual;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;public class Test &#123; public static void main(String[] args) &#123; int result=f(); System.out.println(result); &#125; public static int f()&#123; String s="2019-04-11"; DateFormat sdf = new SimpleDateFormat("yyyy/MM/dd"); int result=10; try &#123; Date date=sdf.parse(s); &#125;catch (Exception e)&#123; result=30; return result;//返回这条，但是finally也会被执行，result返回值不会改 &#125;finally &#123; System.out.println("我一定会被执行"); result=40; //return result;//如果在finally里有返回，则返回这个，结果为40 &#125; return result; &#125;&#125; 结果是： 12我一定会被执行30 使用异常机制的建议​ 1.要避免使用异常处理代替错误处理，这样会降低程序的清晰性，并且效率低下。 ​ 2.处理异常不可以代替简单测试—只在异常情况下使用异常机制。 ​ 3.不要进行小粒度的异常处理—应该将整个任务包装在一个try语句块中。 ​ 4.异常往往在高层处理]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间处理相关类]]></title>
    <url>%2F2019%2F04%2F10%2F%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[时间处理相关类 获取当前时间 System.currentTimeMillis(); new Date().getTime(); Date类]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String和StringBuffer]]></title>
    <url>%2F2019%2F04%2F09%2FString%E5%92%8CStringBuffer%2F</url>
    <content type="text"><![CDATA[概述 String类又称作不可变字符序列。对于不可变对象，本身就是线程安全的，不需要同步机制去保证。 String面试题1. String s = new String(“hello”);和String s = “hello”;的区别? String s = new String(“hello”);创建了两个对象，常量池中的”hello”，和堆内存中的对象 String s = “hello”;只创建了一个对象 2. 123456789String s1 = "hello";String s2 = "world";String s3 = "helloworld";System.out.println(s3==(s1+s2));//falseSystem.out.println(s3.equals(s1+s2));//true System.out.println(s3==("hello"+"world"));//true"hello"和"world"在编译时会自动拼接并放入常量池。所以常量池中有"helloworld"System.out.println(s3.equals("hello"+"world"));//true String 与其它类型数组转换功能## byte[] 1234String s="abc";byte[] b=s.getBytes();//[97, 98, 99]byte[] m=&#123;97, 98, 99&#125;;String str=new String(m);//abc char[]123456String s="abc";char[] c=s.toCharArray();//[a, b, c]System.out.println(Arrays.toString(c));char[] m=&#123;'a', 'b', 'c'&#125;;String str=new String(m);//abcSystem.out.println(str); StringBuffer线程安全的可变字符序列 添加功能123public StringBuffer append(String str);public StringBuffer insert(int offset,String str); 删除功能123public StringBuffer deleteCharAt(int index);public StringBuffer delete(int start,int end); 替换功能1public StringBuffer replace(int start,int end,String str); 反转功能1public StringBuffer reverse(); 截取功能12public String substring(int start)public String substring(int start,int end) 注意：截取功能和前面几个功能的不同 返回值类型是String类型，本身没有发生改变 StringBuilder一个可变的字符序列。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快 面试题1234567891011121314151617181920212223242526package casual;public class Test &#123; public static void main(String[] args) &#123; String s1="hello"; String s2="world"; change(s1,s2); System.out.println("s1 = " + s1);//s1= hello System.out.println("s2 = " + s2);//s2= world System.out.println("--------------"); StringBuilder sb1=new StringBuilder("hello"); StringBuilder sb2=new StringBuilder("world"); change(sb1,sb2); System.out.println("sb1 = " + sb1);// sb1 = hello System.out.println("sb2 = " + sb2);// sb2 = worldworld &#125; public static void change(StringBuilder sb1,StringBuilder sb2)&#123; sb1=sb2; sb2=sb2.append(sb1); &#125; public static void change(String s1,String s2)&#123; s1=s2; s2+=s1; &#125;&#125; 结论对于不可变对象，他们作为参数的时候，跟基本数据类型作为参数保持一致，相当于C中的基本数据类型传递 对于可变对象，他们作为参数的时候，跟引用数据类型作为参数保持一致。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object类]]></title>
    <url>%2F2019%2F04%2F08%2FObject%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Object类Object类是所有Java类的根基类，也就意味着所有的Java对象都拥有Object类的属性和方法。如果在类的声明中未使用extends关键字指明其父类，则默认继承Object类。 getClass()public final Class getClass() 返回对象的运行时类 Class:类类型，用来描述类型的类 ​ String getName（）：返回该类的全限定名 注意事项 返回的是运行时类 用final修饰，所有对象该方法行为一致(均返回的是运行时类) 重写equals 若父类和子类不能比较，则用getClass(); 若要求父类和子类能比较，则要用，instanceof 123Object s="123";System.out.println(s.getClass());//返回实例化对象的类型System.out.println(s.getClass().getName());//返回该类的全限定名 输出结果： 12class java.lang.Stringjava.lang.String equals(Object)方法重写的一般方法 equals(Objcet obj),的参数类型一定是Object类型，不然就不是Override覆写而是Overloading重载了！！ 对于一个子类添加了一个新的比较属性，就不能同时满足对称性和传递性。一般处理就是父类和子类不能比较，即返回false，使用 this.getClass()==obj.getClass()判断（这也是IDEA自动生成的版本） 对于子类没有添加一个新属性，就可以使用instanceof进行判断 hashCode()public int hashCode() 概述：返回该对象的哈希码值 默认实现：一般是通过将该对象的内存地址转换成一个整数 如果重写了equals方法， 也应该重写hashCode hash算法：1. 看成一个**模拟随机**映射 2. 映射：定义域与值域 hashCode()方法，其实也是一个hash算法 1. 定义域：内存地址 2. 值域：int的表示范围 特点：同一个对象的hashCode肯定一样，不同对象的hashCode一般来说不一样，但是有极小概率一样 对于随机映射而言，两个不同对象的hashCode一样的概率1/(4e9)；（int范围） hash算法是加密算法么？ ​ hash算法不是加密算法 ​ 加密算法肯定能解密，hash算法是一个映射函数，不能解密，只有一对一映射才能有反函数，才能解密。 hashCode的常规协议 一致性：一个对象的值没有改变时，在程序运行期间，不同时刻调用hashCode（）方法，必须返回同一个整数。 如果重写了equals（Object）方法， 也应该重写hashCode，即用equals(Object)方法比较两个对象相等，那么对这两个对象调用hashCode方法都必须生成相同的整数。 ​ 即把对象的属性分成关键域、衍生域、无关域，equals(Object)和hashCode()都应该只根据关键域的属性判定 如果根据equals（Object）方法，两个对象不相等，那么对这两个对象中任一对象调用hashCode()方法不要求一定生成不同的hash值。 但是程序员应该意识到，为不相等的对象生成不同的整数结果可以提高哈希表的性能。 clone()projected Object clone() 因为是projected修饰，所以（如果在同一个包则可以访问）如果在不同包，只能用子类对象访问，且子类需要实现Cloneable接口。 深拷贝和浅拷贝 浅拷贝只是将一个对象的所有属性值全部拷贝过来，若有引用数据类型，则拷贝对应的内存地址。故引用数据类型指向的对象是公用的，并没有在堆中生成新的对象。 Object类默认实现的是浅拷贝。 （即引用数据类型拷贝的只是地址） 如何实现深拷贝例如对该类进行拷贝 12345class People implements Cloneable&#123; int age;//基本数据类型 String name;//引用数据类型 Job job;//引用数据类型&#125; 在重写clone方法中： 实现Cloneable接口 重写clone方法，该方法抛出异常 调用super.clone()方法。完成基本数据类型的拷贝 1People peopleClone = (People) super.clone(); 对引用数据类型进行拷贝，多层的深拷贝，应该在每个类中重写clone 12String nameClone=new String(name);Job jobClone= (Job) job.clone(); 完成引用数据类型的拷贝 12peopleClone.name=nameClone;peopleClone.job=jobClone; 返回clone 1return peopleClone; 一个深拷贝示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import java.util.Objects;public class TestDemo&#123; public static void main(String[] args) throws CloneNotSupportedException &#123; People p=new People(18,"小张",new Job("程序猿",19999)); People clone= (People) p.clone(); System.out.println(p==clone);//false System.out.println(p.equals(clone));//true System.out.println(p.name==clone.name);//false System.out.println(p.name.equals(clone.name));//true System.out.println(p.job==clone.job);//false System.out.println(p.job.equals(clone.job));//true &#125;&#125;class People implements Cloneable&#123; int age; String name; Job job; public People(int age, String name, Job job) &#123; this.age = age; this.name = name; this.job = job; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; People people = (People) o; return age == people.age &amp;&amp; Objects.equals(name, people.name) &amp;&amp; Objects.equals(job, people.job); &#125; @Override public int hashCode() &#123; return Objects.hash(age, name, job); &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; People peopleClone = (People) super.clone(); String nameClone=new String(name); Job jobClone= (Job) job.clone(); peopleClone.name=nameClone; peopleClone.job=jobClone; return peopleClone; &#125;&#125;class Job implements Cloneable&#123; String work; double salary; @Override protected Object clone() throws CloneNotSupportedException &#123; Job jobClone= (Job) super.clone(); String workClone=new String(work); jobClone.work=workClone; return jobClone; &#125; public Job(String work, double salary) &#123; this.work = work; this.salary = salary; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Job job1 = (Job) o; return Double.compare(job1.salary, salary) == 0 &amp;&amp; Objects.equals(work, job1.work); &#125; @Override public int hashCode() &#123; return Objects.hash(work, salary); &#125;&#125;]]></content>
      <categories>
        <category>JaveSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内部类]]></title>
    <url>%2F2019%2F04%2F06%2F%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[定义把类定义在其他类的内部，这个类就被称为内部类。即在类A中定义了一个类B，类B就是内部类。 由于内部类提供了更好的封装特性，并且可以很方便的访问外部类的属性，所以通常内部类在只为所在外部类提供服务的情况下优先使用 举例：电脑+CPU：CPU是电脑的一个成员，cpu还得和其它成员打交道 第一个作用：隐藏内部类 第二个作用：为了更好的和外部类的其它成员交流 内部类的访问特点： 内部类可以直接访问外部类的成员，包括私有。 外部类要访问内部类的成员，必须创建对象。 注意一般情况下，内部类都会用private进行修饰，不对外部开放。 内部类的分类：成员内部类： 非静态内部类 和 静态内部类 局部内部类 匿名内部类 非静态内部类（inner class）非静态内部类的对象是外部类对象的一个成员 非静态内部类怎么访问外部类？ 答：直接访问，好像定义在自己类中的一样，并且可以访问外部类的私有成员 外部类怎么访问非静态内部类？ 答：创建非静态内部类对象，并且可以访问非静态内部类的私有成员 其他类怎么访问非静态内部类？ 答：创建非静态内部类对象，并且受访问权限限制（不能访问private） 格式：Outer.Inner inner =new Outer().new Inner(); 为什么非静态内部类可以直接访问外部类成员，就像定义在自己里面 答：非静态内部类对象秘密捕获了一个外部类对象 使用要点 i. 非静态内部类必须寄存在一个外部类对象里。因此，如果有一个非静态内部类对象那么一定存在对应的外部类对象。非静态内部类对象单独属于外部类的某个对象。 ii. 非静态内部类可以直接访问外部类的成员，但是外部类不能直接访问非静态内部类成员。 iii. 非静态内部类不能有静态方法、静态属性和静态初始化块。 iv. 外部类的静态方法、静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例。 123456789101112class Outer &#123; private int age = 10; class Inner &#123; int age = 20; public void show() &#123; int age = 30; System.out.println("内部类方法里的局部变量age:" + age);// 30 System.out.println("内部类的成员变量age:" + this.age);// 20 System.out.println("外部类的成员变量age:" + Outer.this.age);// 10 &#125; &#125;&#125; 静态内部类（nest class）静态内部类对象是外部类的成员（属于类，不是属于对象） 内部类怎么访问外部类？ 答：可以直接访问外部类私有的成员，就像定义在自己里面一样。但是只能访问外部类静态成员 外部类怎么访问内部类？ 创建内部类对象，并且能够访问内部类私有成员 其他类怎么访问内部类： 创建内部类对象：Outer.Inner inner = new Outer.Inner(); 但是受到权限修饰符的限制（不能访问private） 使用要点 当一个静态内部类对象存在，并不一定存在对应的外部类对象。 因此，静态内部类的实例方法不能直接访问外部类的实例方法。 静态内部类看做外部类的一个静态成员。 因此，外部类的方法中可以通过：“静态内部类.名字”的方式访问静态内部类的静态成员，通过 new 静态内部类()访问静态内部类的实例。 局部内部类 内部类怎么访问外部类： 答：直接访问，就像定义在自己里面一样，并且能够访问外部类私有的成员 外部类怎么访问内部类 外部类不能访问。只能在定义这个类的方法里面访问。**并且只能通过创建对象访问。能够访问所有私有的成员 其他类怎么访问内部类 不能 注意事项： 局部内部类访问局部变量必须被final修饰。：must be final or effectively final 一旦被局部内部类访问了，该局部变量自动变成final类型，写不写final都是final 推荐加上final 为什么呢？ 因为局部变量会随着方法的调用完毕而消失，这个时候，局部对象并没有立马从堆内存中消失，还要使用那个变量。为了让数据还能继续被使用，就用final修饰，这样，在堆内存里面存储的其实是一个常量值。 怎么访问外部类 外部类怎么访问内部类？ 其他类怎么访问内部类 注意事项 非静态内部类 非静态内部类的对象是外部类对象的一个成员 直接访问，好像定义在自己类中的一样，并且可以访问外部类的私有成员 创建非静态内部类对象，并且可以访问内部类的私有成员 Outer.Inner inner =new Outer().new Inner();创建非静态内部类对象，并且受访问权限限制（不能访问private） 非静态的内部类的成员只能是非静态的。 静态内部类（nest class） 静态内部类对象是外部类的成员 可以直接访问外部类私有的成员，就像定义在自己里面一样。但是只能访问外部类静态成员 创建内部类对象，并且能够访问内部类私有成员 Outer.Inner inner =new Outer.Inner()；但是受到权限修饰符的限制（不能访问private） 静态内部类成员有静态的和非静态的 局部内部类 它是定义在方法内部的，作用域只限于本方法，称为局部内部类。 直接访问，好像定义在自己类中的一样，并且可以访问外部类的私有成员 外部类不能访问。只能在定义这个类的方法里面访问。并且只能通过创建对象访问。能够访问所有私有的成员 不能 局部内部类访问局部变量必须被final修饰。：must be final or effectively final 内部类举例123456789101112131415161718192021222324class Face&#123; String type="瓜子脸"; private class Nose&#123; String type="鹰钩鼻"; public void breath() &#123; System.out.println("吸一口氧气"); System.out.println("脸型："+Face.this.type);//内部类可直接访问外部类成员 &#125; &#125; Nose nose =new Nose();//外部类访问内部类需要创建对象 public String toString()&#123; return "脸型:"+type+",鼻型:"+nose.type; &#125; public void getBreath()&#123; nose.breath();//因为内部类是私有的，需要用get执行内部类的方法 &#125;&#125;public class InnerClass&#123; public static void main(String[] args) &#123; Face face = new Face(); System.out.println(face); face.getBreath(); &#125;&#125; 执行结果： 123脸型:瓜子脸,鼻型:鹰钩鼻吸一口氧气脸型：瓜子脸 匿名内部类概述就是内部类的简化写法。 前提：存在一个类或者接口 这里的类可以是具体类也可以是抽象类。 格式：1234new 父类构造器(实参类表) \实现接口 () &#123; @override //匿名内部类类体！&#125; 重写方法; }//前面是创建对象，后面是重写父类或接口 本质：是一个继承了类或者实现了接口的子类匿名对象 本质是一个对象！！！ 理解： 我要创建一个类或者接口，但是我又不想重写一个类去继承该类或者实现该接口，这时可以用匿名类 注意 匿名内部类没有访问修饰符。 匿名内部类没有构造方法。因为它连名字都没有那又何来构造方法呢。 匿名内部类示例123456789101112131415161718interface Inter &#123;//定义接口 void show();&#125;class Outer&#123; public static Inter method()&#123; return new Inter() &#123; @Override//匿名内部类 public void show() &#123; System.out.println("Hello world"); &#125; &#125;; &#125;&#125;public class TestDemo &#123; public static void main(String[] args) &#123; Outer.method().show(); &#125;&#125; 示例212345678910111213141516interface A &#123; void show();&#125;public class TestDemo &#123; public static void test(A a)&#123; a.show(); &#125; public static void main(String[] args) &#123; TestDemo.test(new A()&#123;//匿名内部类 @Override public void show()&#123; System.out.println("Hello world"); &#125; &#125;); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[权限修饰符]]></title>
    <url>%2F2019%2F04%2F05%2F%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[注意：这里的默认不是default关键字！default methods are allowed only in interfaces. 这里的默认修饰符是包访问权限 public protected 默认（就是不写）（包访问权限） private 同一类中 √ √ √ √ 同一包子类,其他类 √ √ √ 不同包子类 √ 不能通过父类直接访问。 只能通过子类对象去访问 不同包其他类 √ 面向对象程序设计： 有哪些类 每一类中由哪些职责 类与类之间的关系 类与类之间怎么协作 类与类之间怎么访问 类及其组成可以用的修饰符权限修饰符：public ，protected，默认，private 状态修饰符：final ，static 抽象修饰符： abstract 权限修饰符 状态修饰符 抽象修饰符 普通类 public，默认 final abstract 成员变量 均可，自己定义，private居多 final，static 不行 构造方法 4种均可，自己定义，public居多 不行 不行 成员方法 均可，自己定义public居多 final，static abstract protected，private，static只能修饰类的成员]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口interface]]></title>
    <url>%2F2019%2F04%2F05%2F%E6%8E%A5%E5%8F%A3interface%2F</url>
    <content type="text"><![CDATA[接口代表的是功能例如USB上的接口，扩展作用。 继承体现的是is a的关系 接口体现的是like a的关系，例如：猴子可以像人一样计算。 譬如游泳这一接口，谁都可以实现。 在Java中，接口主要用于解决单继承局限的问题 接口特点 接口是两个模块之间通信的标准，通信的规范。如果能把你要设计的模块之间的接口定义好，就相当于完成了系统的设计大纲，剩下的就是添砖加瓦的具体实现了。大家在工作以后，做系统时往往就是使用“面向接口”的思想来设计系统。 接口的本质是契约，就像我们人间的法律一样。制定好后大家都遵守。 接口用关键字interface表示 格式：interface 接口名 {} 类实现接口用implements表示 格式：class 类名 implements 接口名 {} 接口不能实例化 那么，接口如何实例化呢? 答：按照多态的方式，由具体的子类实例化，其实这也是多态的一种，接口多态 接口的子类 抽象类：不必重写所有的抽象方法 具体类：重写接口中的所有抽象方法 成员常量只能是常量 默认修饰符 public static final 123456789101112public class TestDemo &#123; public static void main(String[] args) &#123; Inter inter=new Demo(); System.out.println(inter.num1); inter.num1=12; //编译报错The final field Inter.num1 cannot be assigned &#125;&#125;interface Inter&#123; int num1=100;&#125;class Demo implements Inter&#123;&#125; 构造方法没有构造方法，不能实例化。 因为接口中所有的成员变量都是静态常量，不能实例化成对象，不需要初始化。 成员方法接口中所有成员的访问权限都是public ​ 接口表示的是一个功能，所以谁都可以实现它。 JDK1.7之前，接口中只能包含静态常量、抽象方法，不能有普通属性、构造方法、普通方法。 ​ 抽象方法：默认用public abstract修饰 JDK1.8后：接口中包含普通的静态方法和默认方法。 默认方法：如果该接口的子类没有重写该方法，就是这个默认方法。这里的default表示的不是访问权限，表示的是默认方法 这里其实是public default void method() 但是接口中public推荐省略 123 default void method()&#123; System.out.println("123");&#125; ​ 2. 静态方法：静态方法只能通过接口名.静态方法（）调用，不能通过子类调用 123static void function()&#123; System.out.println("123");&#125; 接口与类的关系类与类：继承关系，只能单继承，但是可以多层继承 类与接口：实现关系，也可以多实现，还可以继承一个类的同时实现多个接口 接口与接口：继承关系，可以单继承，也可以多继承 抽象类与接口的区别 抽象类 方法 变量 构造方法 关系区别 设计理念 抽象类 抽象方法，普通方法，静态方法 变量，常量 有 类与类（继承），单继承；类与接口 （实现），单实现，多实现 抽象类 被继承体现的是：”is a”的关系。共性功能 接口 JDK1.8之前，只能有抽象方法 ； JDK1.8以后有默认方法（default）、静态方法、抽象方法 常量，默认public static final 无 接口与接口（继承），单继承，多继承 接口 被实现体现的是：”like a”的关系。扩展功能 接口的实际应用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051interface USB&#123; default void printInfo() &#123;//默认方法 System.out.println("采用USB接口连接"); &#125; void start();//抽象方法 void stop(); static void usbInfo() &#123;//静态方法 System.out.println("USB4.0"); &#125;&#125;class Print implements USB&#123;//打印机类 public void printInfo() &#123;//覆写默认方法 System.out.println("打印机类覆写默认方法"); &#125; @Override public void start() &#123; System.out.println("打印机连接！"); &#125; @Override public void stop() &#123; System.out.println("打印机断开连接!"); &#125; &#125;class Flash implements USB&#123; @Override public void start() &#123; System.out.println("U盘连接！"); &#125; @Override public void stop() &#123; System.out.println("U盘断开连接!"); &#125; &#125;class Computer&#123; public void plugin(USB usb) &#123; usb.printInfo();//默认方法 usb.start();//抽象方法 usb.stop();//抽象方法 //usb.usbInfo();//编译错误，接口的静态方法只能通过接口名调用 USB.usbInfo(); &#125;&#125;public class HW4&#123; public static void main(String[] args) &#123; Computer computer=new Computer(); computer.plugin(new Flash()); System.out.println("--------------"); computer.plugin(new Print()); &#125;&#125; 输出结果： 123456789采用USB接口连接U盘连接！U盘断开连接!USB4.0--------------打印机类覆写默认方法打印机连接！打印机断开连接!USB4.0]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象类]]></title>
    <url>%2F2019%2F04%2F05%2F%E6%8A%BD%E8%B1%A1%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[抽象方法使用abstract修饰的方法，没有方法体，只有声明。定义的是一种“规范”，就是告诉子类必须要给抽象方法提供具体的实现。 抽象类包含抽象方法的类就是抽象类。通过abstract方法定义规范，然后要求子类必须定义具体实现。通过抽象类，我们就可以做到严格限制子类的设计，使子类之间更加通用。 抽象类的使用要点 有抽象方法的类只能定义成抽象类，抽象类不一定有抽象方法 问题1：没有抽象方法的抽象类，有什么意义 答：阻止直接对该类进行实例化。 问题2：怎么对Animal类型的数据进行赋值？ 回答：多态赋值，可以把抽象类的子类对象赋值给抽象类 抽象类不能实例化，即不能用new来实例化抽象类。 抽象类可以包含属性、方法、构造方法。但是构造方法不能用来new实例，只能用来被子类调用。 抽象类只能用来被继承。抽象类是为继承而生的，没有子类的抽象类毫无意义 抽象类的子类： 具体类：具体类必须重写（override）抽象类的所有抽象方法 抽象类：抽象的子类不必重写抽象类的所有抽象方法 抽象类的成员特点成员变量​ 可以是变量也可以是常量 构造方法问题：抽象类可以直接实例化么？ 答：不能 问题：构造方法的作用是什么？ 答：给对象初始化 。new + 构造方法 创建对象 问题：抽象类有构造方法么，它不能实例化，那么有什么作用？ 答：有，给子类服务的，用于子类访问，对父类数据的初始化 成员方法a. 抽象方法 ​ 限制非抽象的子类必须重写这些抽象方法（标准） b. 非抽象方法 ​ 提供一个默认实现。（父类提供一个默认的行为） ​ 抽象类举例，员工案例分析：具体—-&gt;抽象 普通员工： ​ 属性：姓名、工号、工资 ​ 行为：工作、吃饭 经理： ​ 属性：姓名、工号、工资、奖金 ​ 行为：工作、吃饭 员工（抽象） ​ 属性：姓名、工号、工资 ​ 行为：工作【抽象】、吃饭 实现： ​ Employee:(抽象) ​ 属性：name,id,salary ​ 行为：work()【抽象】,eat() ​ Staff: ​ Manager: ​ 属性：bonus 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class TestDemo &#123; public static void main(String[] args) &#123; Employee e1=new Staff("华安","9527",100); e1.work(); e1.eat(); System.out.println("----------------------"); Employee e2=new Manager("小张","10002",100000,10000); e2.work(); e2.eat(); &#125; &#125;abstract class Employee&#123; String name; String id; double salary; public Employee() &#123; &#125; public Employee(String name,String id,double salary) &#123; this.name=name; this.id=id; this.salary=salary; &#125; public abstract void work(); public void eat() &#123; System.out.println("工作饿了，我要吃饭~"); &#125;&#125;class Staff extends Employee&#123; public Staff() &#123; &#125; public Staff(String name,String id,double salary) &#123; super(name,id,salary); &#125; public void work() &#123; System.out.println("努力搬砖"); &#125;&#125;class Manager extends Employee&#123; double bonus; public Manager()&#123; &#125; public Manager(String name,String id,double salary,double bonus) &#123; super(name,id,salary); this.bonus=bonus; &#125; public void work() &#123; System.out.println("和客户撕逼~~~"); &#125;&#125; 结果： 12345努力搬砖工作饿了，我要吃饭~----------------------和客户撕逼~~~工作饿了，我要吃饭~ 几个小问题 一个类如果没有抽象方法，可不可以定义为抽象类，如果可以，有什么意义？ 答：可以，防止它进行实例化 abstract不能和哪些关键字共存 private private abstract为非法的修饰符组合，因为abstract修饰的方法必须被子类重写，private修饰的方法不能被子类继承 final final anstract为非法的修饰符组合，因为abstract修饰的方法必须被子类重写，final修饰的方法不能被重写 static static abstract为非法的修饰符组合，static修饰的方法能够直接被类调用，类优先于对象存在。抽象方法没有实现，只有定义。（无意义）]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象三大特性3——多态]]></title>
    <url>%2F2019%2F04%2F04%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A73%E2%80%94%E2%80%94%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[多态(polymorphism)多态指的是同一个方法调用，由于对象不同可能会有不同的行为。现实生活中，同一个方法，具体实现会完全不同。 比如：同样是调用人“吃饭”的方法，中国人执行就是用筷子吃饭，英国人执行就是用刀叉吃饭，印度人执行用手吃饭。 多态的要点： 多态是方法的多态，不是属性的多态(多态与属性无关)。 多态的存在要有3个必要条件：继承（实现），方法重写，父类引用指向子类对象。 父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了。 成员访问特点成员变量​ 编译看左边，运行看左边 静态变量​ 编译看左边，运行看左边 成员方法​ 编译看左边，运行看右边（多态！！！） 静态方法​ 编译看左边，运行看左边 孔子装爹​ 从前有个圣人叫孔子，孔子教论语，孔子他爹教农耕； ​ 孔子爹就比较忙，经常外出讲课，收入很高； ​ 有一天，又有人请孔子爹去教农耕，恰巧孔子爹不在。给的报酬很高，孔子就心动了。就打算打扮成他爹的样子去，穿上爹的衣服，带上爹的帽子，粘上小胡子就去了。Father f=new Son();f.name f.age 其实是爹的属性，因为别人看到的是孔子爹的属性（样貌）。别人请孔子教农耕，孔子就露馅了f.teach(）教的是论语。 1234567891011121314151617181920212223242526272829class KongDie&#123; int age=70; String name="老爹"; public static void sleep() &#123; System.out.println("孔爹睡觉"); &#125; public void teach() &#123; System.out.println("孔爹教农耕"); &#125;&#125;class Kong extends KongDie&#123; int age=30; String name="小孔"; public static void sleep() &#123; System.out.println("小孔睡觉"); &#125; public void teach() &#123; System.out.println("小孔教论语"); &#125;&#125;public class TestDemo&#123; public static void main(String[] args) &#123; KongDie f=new Kong(); System.out.println("年龄:"+f.age); System.out.println("姓名:"+f.name); f.sleep(); f.teach(); &#125;&#125; 运行结果： 1234年龄:70 //成员变量，运行看左边姓名:老爹//成员变量，运行看左边孔爹睡觉//静态方法，运行看左边小孔教论语//成员方法,运行看右边，多态！ 多态的好处 提高了程序的维护性（由继承保证） 提高了程序的扩展性（由多态保证） 多态的弊端 不能访问子类特有功能 那么我们如何才能访问子类的特有功能呢? 多态中的转型 多态中的转型问题向上转型​ 父类引用指向子类对象，我们称这个过程为向上转型，属于自动类型转换。 1Father father=new Son(); 向下转型​ 向上转型后的父类引用变量只能调用它编译类型的方法，不能调用它运行时类型的方法。这时，我们就需要进行类型的强制转换，我们称之为向下转型! 1Son son=(Son)father;//父类引用变量father实际上指向的是子类对象 面试题123456789101112131415161718192021222324252627282930313233343536373839class A&#123; char x='A'; public void show()&#123; System.out.println("父类A中的this地址为："+this); this.show2(); &#125; public void show2()&#123; System.out.println("我"); &#125;&#125;class B extends A &#123; char x='B'; public void show2()&#123; System.out.println("爱"); &#125;&#125;class C extends B &#123; char x='C'; public void show()&#123; System.out.println("子类C的super的地址为："+ super.toString()); super.show(); &#125; public void show2()&#123; System.out.println("你"); &#125;&#125;public class TestDemo &#123; public static void main(String[] args) &#123; A a = new B(); System.out.println("a的地址是："+a); System.out.println("a.x= "+a.x); a.show(); System.out.println("------------------------"); B b = new C(); System.out.println("b的地址是："+b); System.out.println("b.x= "+b.x); b.show(); &#125;&#125; 输出结果： 12345678910a的地址是：classlib.B@36d64342a.x= A//成员变量没有多态，编译运行都看左边父类A中的this地址为：classlib.B@36d64342爱------------------------b的地址是：classlib.C@511baa65b.x= B//成员变量没有多态，编译运行都看左边子类C的super的地址为：classlib.C@511baa65//super表示的是该对象内存中的一部分地址，该部分存储了从父类中继承的成员父类A中的this地址为：classlib.C@511baa65你 多态的内存分析 模拟Servlet并内存分析1234567891011121314151617181920212223public class TestDemo&#123; public static void main(String[] args) &#123; HttpServlet s=new MyServlet(); s.service(); System.out.println("对象s的内存地址"+s); &#125;&#125;class HttpServlet&#123; public void service() &#123; System.out.println("HttpServlet.service()"); System.out.println("调用doGet()时的内存地址"+this); this.doGet(); &#125; public void doGet() &#123; System.out.println("HttpServlet.doGet()"); &#125;&#125;class MyServlet extends HttpServlet &#123; //重写doGet()方法，不重写service()方法 public void doGet() &#123; System.out.println("MyServlet.doGet()"); &#125;&#125; 1234HttpServlet.service()调用doGet()时的内存地址classlib.MyServlet@36d64342MyServlet.doGet()对象s的内存地址classlib.MyServlet@36d64342 内存分析图如下：]]></content>
      <categories>
        <category>JaveSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[final关键字]]></title>
    <url>%2F2019%2F04%2F04%2Ffinal%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[final修饰变量:被他修饰的变量不可改变。一旦赋了初值，就不能被重新赋值。且必须被赋初值 12final int MAX_SPEED = 120;final int MAX_SPEED ;//编译出错 final修饰方法：该方法不可被子类重写。但是可以被重载! final修饰类:修饰的类不能被继承。比如：Math、String等。 final关键字面试题final基本类型和引用类型作为参数的情况 基本类型，是值不能被改变 引用类型，是地址值不能被改变，对象内容可以改变]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[super关键字&&继承树]]></title>
    <url>%2F2019%2F04%2F04%2Fsuper%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[this: a. 代表当前对象（哪个对象调用这个方法，它就代表哪个对象） b.代表该对象的一个空间标识（可以调用在本类中定义的成员） super： ​ a: super表示的是该对象内存中的一部分空间，该部分空间存储了从父类中继承的成员，（可以调用在父类中定义的成员） 如图所示，super代表的是里面那个小框，表示的是该对象内存中的一部分空间，该部分空间存储了从父类中继承的成员 静态方法中不能使用super关键字 123456789101112131415161718public class TestDemo&#123; public static void main(String[] args) &#123; Son1 son=new Son1(); son.method(0); &#125;&#125;class Father1&#123; int n=1024;&#125;class Son1 extends Father1&#123; int n=2048; public void method(int n) &#123; System.out.println("n="+n); System.out.println("this.n="+this.n); System.out.println("super.n="+super.n); System.out.println("子类对象:"+this); //System.out.println(super);编译错误 &#125;&#125; 输出结果： 1234n=0//方法中的局部变量this.n=2048//this代表子类，子类中的成员变量super.n=1024//上面代码中父类对象没有创建，只new了一个子类对象，所以super代表该对象的空间标识，里面存的是父类继承的成员子类对象:classlib.Son1@36d64342//相当于this.toString() 总结 super是直接对父类对象的引用。可以通过super来访问父类中被子类覆盖的非static方法或非static属性。 使用super调用普通方法，语句没有位置限制，可以在子类中随便调用。 若是构造方法的第一行代码没有显式的调用super(…)或者this(…);那么Java默认都会调用super(),含义是调用父类的无参数构造方法。这里的super()可以省略。 属性/方法的查找顺序：(比如：查找变量h) 查找当前类中有没有属性h（如果是方法，则从当前对象中开始找） 依次上溯每个父类，查看每个父类中是否有h，直到Object 如果没找到，则出现编译错误。 上面步骤，只要找到h变量，则这个过程终止。 构造方法调用顺序： 构造方法第一句总是：super(…)来调用父类对应的构造方法。所以，流程就是：先向上追溯到Object，然后再依次向下执行类的初始化块和构造方法，直到当前子类为止。 子类中的所有构造方法，默认都会访问父类中的无参构造方法 ​ 为什么呢? 因为子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化。 每一个构造方法的第一条语句默认都是：super() 子类的构造方法对父类构造方法的调用只能一次 如果父类没有无参构造方法。直接编译会报错，有如下两种解决办法 ​ a. 调用父类的有参构造方法 ​ b. 调用本类其它构造方法，其它构造方法必须调用父类的有参构造方法（本质上是要对父类成员进行初始化！） ​ 注：静态初始化块调用顺序，与构造方法调用顺序一样，不再重复。 12345678910111213141516171819202122232425public class TestDemo&#123; public static void main(String[] args) &#123; new Son2(); System.out.println("----------------------"); new Son2(100); &#125;&#125;class Father2&#123; public Father2() &#123; System.out.println("Father2()..."); &#125; public Father2(int n) &#123; System.out.println("Father2(int)..."); &#125;&#125;class Son2 extends Father2&#123; public Son2() &#123; super(100);//可以通过super(...)调用父类有参构造方法，此时系统不会默认提供无参构造方法 System.out.println("Son2()..."); &#125; public Son2(int n) &#123; //super();这是编译器自己加的，默认调用父类无参构造方法 System.out.println("Son2(int)..."); &#125;&#125; 结果： 12345Father2(int)...//调用父类有参构造方法Son2()...----------------------Father2()...//调用父类无参构造方法Son2(int)... 面试题11234567891011121314151617181920212223242526272829303132class Father &#123; static &#123; System.out.println("静态代码块Father"); &#125; &#123; System.out.println("构造代码块Father"); &#125; public Father() &#123; System.out.println("构造方法Father"); &#125;&#125;class Son extends Father &#123; static &#123; System.out.println("静态代码块Son"); &#125; &#123; System.out.println("构造代码块Son"); &#125; public Son() &#123; System.out.println("构造方法Son"); &#125;&#125;public class TestDemo&#123; public static void main(String[] args) &#123; Son son=new Son(); &#125;&#125; 结果： 123456静态代码块Father//1、加载父类的字节码文件(运行静态代码块)静态代码块Son//2、加载子类的字节码文件构造代码块Father//3、执行父类的构造代码块（构造代码块相当于构造方法的最前面）构造方法Father//4、执行父类构造方法构造代码块Son//5、执行子类的构造代码块构造方法Son//6、执行子类的构造方法 继承对象的初始化过程： 1. 加载父类的字节码文件(运行静态代码块) 2. 加载子类的字节码文件 3. 执行父类的构造代码块（构造代码块相当于构造方法的最前面） 4. 执行父类构造方法 5. 执行子类的构造代码块 6. 执行子类的构造方法 面试题212345678910111213141516171819202122class X &#123;//2 加载父类X字节码文件 Y b = new Y();//引用类型的成员变量 //3 堆中开辟空间，默认初始化b=null，显式初始化b=new Y()，堆中有引用类型成员变量b,接下去执行new Y() X() &#123;//6 构造方法初始化 打印X。至此父类X初始化完毕。开始子类Z的初始化 System.out.println("X"); &#125;&#125;class Y &#123;//4 加载Y类字节码文件，在堆中开辟空间，Y中没有成员变量,所以没有变量初始化 //5 X中new Y()构造方法初始化，打印Y，退回3 Y() &#123;//8 Z中new Y(),Y中没有成员变量，构造方法初始化，打印Y System.out.println("Y"); &#125;&#125;public class Z extends X &#123; Y y = new Y();//7 父类初始化完毕，进行Z的出初始化，堆中开辟空间，默认初始化y=null,显示初始化y=new Y(),接下去去执行new Y(); Z() &#123;//9 Z中成员变量初始化后，进行Z中构造方法初试化，打印Z System.out.println("Z"); &#125; public static void main(String[] args) &#123;//1、程序入口 new Z(); //2、new Z(),先加载父类X的字节码文件 &#125;&#125; 1234YXYZ 铺垫的小知识：第一个：成员变量有基本类型和引用类型的。1234class Demo &#123; int x = 10; //基本类型 Student s = new Student(); //引用类型&#125; 第二个：类的初始化过程 加载class文件 堆中开辟空间 变量的默认初始化 变量的显示初始化 构造代码块初始化 构造方法初始化 第三个：遇到extends，就要知道，先初始化父类数据，然后初始化子类数据。 子类构造方法中的第一行super在这里仅仅表示要先初始化父类数据。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象三大特性2——继承]]></title>
    <url>%2F2019%2F04%2F04%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A72%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[继承概述 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。 通过extends关键字可以实现类与类的继承 class 子类名 extends 父类名 {} 单独的这个类称为父类，基类或者超类；这多个类可以称为子类或者派生类。 有了继承以后，我们定义一个类的时候，可以在一个已经存在的类的基础上，还可以定义自己的新成员。 继承的好处 提高了代码的复用性 ​ 多个类相同的成员可以放到同一个类中 提高了代码的维护性 ​ 如果功能的代码需要修改，修改一处即可 让类与类之间产生了关系，是多态的前提 ​ 其实这也是继承的一个弊端：类的耦合性很强 设计原则：高内聚低耦合。 简单的理解： 内聚就是自己完成某件事情的能力。 耦合就是类与类之间的关系。 我们在设计的时候原则是：自己能完成的就不麻烦别人，这样将来别人产生了修改，就对我的影响较小。 由此可见：在开发中使用继承其实是在使用一把双刃剑。今天我们还是以继承的好处来使用，因为继承还有很多其他的特性。 继承的特点 Java中只有单继承，没有像C++那样的多继承。多继承会引起混乱，使得继承链过于复杂，系统难于维护。可以多层继承 Java中类没有多继承，接口有多继承。 子类继承父类，可以得到父类的全部属性和方法 (除了父类的构造方法)，但不见得可以直接访问(比如，父类私有的属性和方法,私有成员其实被隐式继承了)。 ​ 其实这也体现了继承的另一个弊端：打破了封装性 如果定义一个类时，没有调用extends，则它的父类是：java.lang.Object。 子类不能继承父类的构造方法，但是可以通过super关键字去访问父类构造方法。 不要为了部分功能而去继承。解释一下：我们发现两个类有部分代码相同，我们就让这两个类产生一个继承关系，这是不对的。 我们到底在什么时候使用继承呢? ​ 继承中类之间体现的是：”xxx is a xxx”的关系。 ​ 例如：水果和苹果，苹果是一种水果。 ​ 学生和人，学生是人的一种。 继承举例1234567891011121314151617181920212223242526public class Test2&#123; public static void main(String[] args) &#123; Student s = new Student("wjj",180,"cs"); s.rest();//可以直接调用父类的方法 s.study(); &#125;&#125;class Person &#123; String name; int height; public void rest()&#123; System.out.println("休息一会！"); &#125; &#125;class Student extends Person &#123; String major; //专业 public void study()&#123; System.out.println("在努力学习java！"); &#125; public Student(String name,int height,String major) &#123; //天然拥有父类的属性 this.name = name; this.height = height; this.major = major; &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码块]]></title>
    <url>%2F2019%2F04%2F03%2F%E4%BB%A3%E7%A0%81%E5%9D%97%2F</url>
    <content type="text"><![CDATA[局部代码块​ 在局部位置(方法内)，限定变量生命周期，及早释放，提高内存利用率 123456789public class TestDemo &#123; public static void main(String[] args) &#123; &#123; int i=100; System.out.println("i="+i); &#125; i=200;//此处编译错误 &#125;&#125; 构造代码块在成员位置（在类中方法外）出现；多个构造方法方法中相同的代码提取出来，存放到构造代码块里面，每次调用构造方法都执行，换句话说，每次创建对象都执行，并且在构造方法前执行 123456789101112131415161718192021222324public class TestDemo &#123; public static void main(String[] args) &#123; Student stu=new Student(); Student stu2=new Student("wjj",18); &#125;&#125;class Student&#123; String name; int age; public Student() &#123; //System.out.println("我要创建一个学生对象"); System.out.println("无参构造方法"); &#125; public Student(String name,int age) &#123; //System.out.println("我要创建一个学生对象"); System.out.println("有参构造方法"); this.name=name; this.age=age; &#125; &#123; System.out.println("我要创建一个学生对象"); //为为构造代码块,每次调用构造都执行**，并且在构造方法前执行 &#125;&#125; 输出结果： 1234我要创建一个学生对象无参构造方法我要创建一个学生对象有参构造方法 静态代码块 ：在类中方法外出现，加了static修饰构造方法用于对象的初始化!静态初始化块，用于类的初始化操作!在静态初始化块中不能直接访问非static成员。 在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且值执行一次。 注意事项注意事项： 静态初始化块执行顺序： 1. 上溯到Object类，先执行Object的静态初始化块，再向下执行子类的静态初始化块，直到我们的类的静态初始化块为止。 2. 构造方法执行顺序和上面顺序一样!! 1234567891011121314151617181920212223242526272829package TestException;public class TestDemo &#123; public static void main(String[] args) &#123; Student stu=new Student(); Student stu2=new Student("wjj",18); &#125;&#125;class Student&#123; String name; int age; static &#123; System.out.println("这是静态代码块"); &#125; &#123; //构造代码块 System.out.println("我要创建一个学生对象"); //为为构造代码块,每次调用构造都执行**，并且在构造方法前执行 &#125; public Student() &#123; //System.out.println("我要创建一个学生对象"); System.out.println("无参构造方法"); &#125; public Student(String name,int age) &#123; //System.out.println("我要创建一个学生对象"); System.out.println("有参构造方法"); this.name=name; this.age=age; &#125;&#125; 输出结果： 12345这是静态代码块//只执行一次我要创建一个学生对象//每次创建对象都执行无参构造方法我要创建一个学生对象有参构造方法 面试题：静态代码块，构造代码块，构造方法的执行顺序。 静态代码块 &gt; 构造代码块 &gt; 构造方法 同步代码块（多线程）]]></content>
  </entry>
  <entry>
    <title><![CDATA[static关键字]]></title>
    <url>%2F2019%2F04%2F02%2Fstatic%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[核心要点 static修饰的成员变量和方法，从属于类。 普通变量和方法从属于对象的。 在类中，用static声明的成员变量为静态成员变量，也称为类变量。 类变量的生命周期和类相同，在整个应用程序执行期间都有效。它有如下特点： 1. 为该类的公用变量，属于类，被该类的所有实例共享，在类被载入时被显式初始化。（随着类的加载而加载） 2. 优先于对象存在 3. 对于该类的所有对象来说，static成员变量只有一份。被该类的所有对象共享!! 4. 一般用“类名.类属性/方法”来调用。(也可以通过对象引用或类名(不需要实例化)访问静态成员。【强烈推荐使用类名调用！！！】 5. 在static方法中不可直接访问非static的成员。（因为非static成员要对象存在才存在，而static方法优先于对象存在，从属于类） 6. this不能用于static方法中。（因为this的本质就是“创建好的对象的地址”! ） 内存分析12345678910111213141516171819202122232425262728293031public class TestDemo&#123; public static void main(String[] args) &#123; Person p1=new Person("中国","迪丽热巴",20); p1.show(); Person p2=new Person("中国","古力娜扎",21); p2.show(); Person p3=new Person("中国","凤姐",40); p3.show(); System.out.println("----------------------------"); p3.nation="America"; //等价于Person.nation="America"; p1.show(); p2.show(); p3.show(); &#125;&#125;class Person&#123; static String nation; String name; int age; public Person() &#123;//构造方法 &#125; public Person(String nation,String name,int age) &#123; this.name=name; this.nation=nation; this.age=age; &#125; public void show() &#123; System.out.println("nation="+nation+",name="+name+",age="+age); &#125;&#125; 输出结果： 1234567nation=中国,name=迪丽热巴,age=20nation=中国,name=古力娜扎,age=21nation=中国,name=凤姐,age=40----------------------------nation=America,name=迪丽热巴,age=20nation=America,name=古力娜扎,age=21nation=America,name=凤姐,age=40 因为nation为静态属性，为类共享，所以全改了 main方法：public static void main(String[] args){} public :公共的，main方法是被JVM主动调用的，所以访问权限得最大 static:静态的，在被调用之前，根本就没有对象存在，所以应该用static修饰 void:返回给调用者，main方法的调用者是JVM，把值返回给JVM是没有意义的，所以用void main:只是一个约定俗成的名字 String[] args: JDK1.5 以前没有Scanner类，String[] args用于接受键盘录入的数据的,在dos窗口运行HelloWorld.class文件时，需要执行语句 1234567class HelloWorld&#123; public static void main(String[] args)&#123; for(int i=0;i&lt;args.length;i++)&#123; System.out.println(args[i]); &#125; &#125;&#125; 1java HelloWorld hello world hangzhou “hello”,”world”,”hangzhou”为我输入的3个字符串分别为args[0],args[1],args[2]]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象三大特性1—封装]]></title>
    <url>%2F2019%2F04%2F02%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A71%E2%80%94-%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[封装的作用与含义 我要看电视，只需要按一下开关和换台就可以了。有必要了解电视机内部的结构吗?有必要碰碰显像管吗?制造厂家为了方便我们使用电视，把复杂的内部细节全部封装起来，只给我们暴露简单的接口，比如：电源开关。具体内部是怎么实现的，我们不需要操心。 需要让用户知道的才暴露出来，不需要让用户知道的全部隐藏起来，这就是封装。说的专业一点，封装就是把对象的属性和操作结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。 我们程序设计要追求“高内聚，低耦合”。 高内聚就是类的内部数据操作细节自己完成，不允许外部干涉; 低耦合是仅暴露少量的方法给外部使用，尽量方便外部调用。 编程中封装的具体优点： 提高代码的安全性。 提高代码的复用性。 “高内聚”：封装细节，便于修改内部代码，提高可维护性。 “低耦合”：简化外部调用，便于调用者使用，便于扩展和协作。 没有封装的代码会出现一些问题12345678910111213141516class Person &#123; String name; int age; @Override public String toString() &#123; return "Person [name=" + name + ", age=" + age + "]"; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Person p = new Person(); p.name = "小红";//此处也可以加限制，例如游戏起名的时候会判断你的名字是否合法 p.age = -45;//年龄可以通过这种方式随意赋值，没有任何限制 System.out.println(p); &#125;&#125; *再比如说，如果哪天我们需要将Person类中的age属性修改为String类型的，你会怎么办? 例如p.age=1; 改成p.age=&quot;1&quot;; p2.age=2; 改成p2.age=&quot;2&quot;; p3.age=3; 改成p2.age=&quot;3&quot;; 你只有一处使用了这个类的话那还比较幸运，但如果你有几十处甚至上百处都用到了，那你岂不是要改到崩溃。而封装恰恰能解决这样的问题。如果使用封装，我们只需要稍微修改下Person类的setAge()方法即可，而无需修改使用了该类的客户代码。 123public void setAge(Integer age)&#123;//此处为自动装箱 this.age=age.toString();&#125; 封装的使用细节类的属性的处理 一般使用private访问权限。 提供相应的get/set方法来访问相关属性，这些方法通常是public修饰的，以提供对属性的赋值与读取操作(注意：boolean变量的get方法是is开头!)。 一些只用于本类的辅助性方法可以用private修饰，希望其他类调用的方法用public修饰。 封装使用实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Person &#123; private String name; private int age; public Person() &#123;//无参构造函数 &#125; public Person(String name, int age) &#123; this.name = name; //this.age = age;//构造方法中直接赋值，就不会判断年龄是否正确 setAge(age);// 应该调用setAge方法 &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; //在赋值之前先判断年龄是否合法 if (age &gt; 130 || age &lt; 0) &#123; System.out.println("Are you kidding?");//不合法 &#125; else &#123; this.age = age;//合法才能赋值给属性age &#125; &#125; public int getAge() &#123; return age; &#125; @Override public String toString() &#123; return "Person [name=" + name + ", age=" + age + "]"; &#125;&#125; public class Test2 &#123; public static void main(String[] args) &#123; Person p1 = new Person(); //p1.name = "小红"; //编译错误 //p1.age = -45; //编译错误 p1.setName("小红"); p1.setAge(-45); System.out.println(p1); Person p2 = new Person("小白", 300); System.out.println(p2); &#125;&#125; 1234Are you kidding?Person [name=小红, age=0]Are you kidding?Person [name=小白, age=0]//输出结果]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造方法]]></title>
    <url>%2F2019%2F04%2F02%2F%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[构造器也叫构造方法(constructor)，用于对象的初始化。构造器是一个创建对象时被自动调用的特殊方法，目的是对象的初始化。构造器的名称应与类的名称一致。Java通过new关键字来调用构造器，从而返回该类的实例，是一种特殊的方法。 申明格式123[修饰符] 类名(形参列表)&#123; ``//n条语句&#125; 方法名与类名相同 没有返回值类型，连void都没有 没有具体的返回值 例如： 1234567891011121314151617class Point &#123; double x, y; public Point(double x, double y) &#123; this.x = x; this.y = y; &#125; public double getDistance(Point p) &#123; return Math.sqrt((x - p.x) * (x - p.x) + (y - p.y) * (y - p.y)); &#125;&#125;public class TestConstructor &#123; public static void main(String[] args) &#123; Point p = new Point(3.0, 4.0); Point origin = new Point(0.0, 0.0); System.out.println(p.getDistance(origin)); &#125;&#125; 5.0//程序结果 构造方法的重载构造方法也是方法，只不过有特殊的作用而已。与普通方法一样，构造方法也可以重载。 【特别注意】 如果方法构造中形参名与属性名相同时，需要使用this关键字区分属性与形参。如下示例所示：this.id 表示属性id;id表示形参id 如果你不提供构造方法，系统会给出默认构造方法 如果你提供了构造方法，系统将不再提供【强烈推荐永远自己写一个无参构造方法】 构造方法不能递归使用（显然会一直调用自己，栈溢出） 123456789101112131415161718192021222324package classlib;public class User &#123; int id; // id String name; // 账户名 String pwd; // 密码 public User() &#123; &#125; public User(int id, String name) &#123; super(); this.id = id; this.name = name; &#125; public User(int id, String name, String pwd) &#123; this.id = id; this.name = name; this.pwd = pwd; &#125; public static void main(String[] args) &#123; User u1 = new User(); User u2 = new User(101, "WJJ"); User u3 = new User(100, "AL", "123456"); &#125;&#125; 标准案例 讲成员变量私有化 提供一个无参和所有参数的构造方法 提供setXxx和getXxx 成员方法 # 构造方法私有化 对于一个工具类，可以将无参构造方法初始化，这样这能通过类名调用其静态方法，不能为该类实例化对象 例如 123456789class MyMath&#123; private MyMath()&#123;//The constructor MyMath() is not visible //讲无参构造函数私有化 &#125; public static int add(int a,int b)&#123; return a+b; &#125; //还可以有其它计算&#125; 则此时MyMath类不能实例化，只能用类名调用静态方法]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this关键字]]></title>
    <url>%2F2019%2F04%2F02%2Fthis%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[对象创建过程与this的本质构造方法是创建Java对象的重要途径，通过new关键字调用构造器时，构造器也确实返回该类的对象，但这个对象并不是完全由构造器负责创建。创建一个对象分为如下四步： 分配对象空间，并将对象成员变量初始化为0或空 执行属性值的显示初始化 执行构造方法 返回对象的地址给相关的变量 this的本质就是“创建好的对象的地址”! 由于在构造方法调用前，对象已经创建。因此，在构造方法中也可以使用this代表“当前对象” 。 this最常用的用法： 在程序中产生二义性之处，应使用this来指明当前对象;普通方法中，this总是指向调用该方法的对象。构造方法中，this总是指向正要初始化的对象。 使用this关键字调用重载的构造方法，避免相同的初始化代码。但只能在构造方法中用，并且必须位于构造方法的第一句。 this不能用于static方法中。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象的内存分析]]></title>
    <url>%2F2019%2F04%2F02%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一个类的初始化过程Student s = new Student();在内存中做了哪些事情? 加载Student.class文件进内存【方法区】,并且创建对应的字节码文件 在栈内存为s开辟空间 在堆内存为学生对象开辟空间 对学生对象的成员变量进行默认初始化//0,null, 对学生对象的成员变量进行显示初始化显示初始化的意思是，类定义的时候给成员变量赋了初值例如： 12345class Person &#123; private String name="WJJ";//显示初始化 private int age=18;//显示初始化 //构造函数即getXxx(),setXxxx()&#125; 通过构造方法对学生对象的成员变量赋值 学生对象初始化完毕，把对象地址赋值给s变量 Java虚拟机的内存可以分为三个区域：栈stack、堆heap、方法区method area。* 栈的特点如下： 栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧(存储局部变量、操作数、方法出口等) JVM为每个线程创建一个栈，用于存放该线程执行方法的信息(实际参数、局部变量等) 栈属于线程私有，不能实现线程间的共享! 栈的存储特性是“先进后出，后进先出” 栈是由系统自动分配，速度快!栈是一个连续的内存空间! 总结关于栈和栈帧，我们做个小结： 每个JVM线程有一个私有栈，栈在线程创建的同时被创建。 栈由许多帧组成，也叫 “栈帧” 每次方法调用都会创建一个栈帧 换句话说，当一个Java/Scala/JVM方法被执行时： 当方法被执行时，一个新的栈帧被创建并用来给这个方法存储数据 栈帧大小各不相同，取决于方法的参数、局部变量和算法 当一个方法被执行时，程序只能访问当前栈帧中的数据，你能看到的只有栈顶的帧 Java/JVM中栈的官方定义Oracle关于栈和栈帧提供了如下描述： 每个JVM线程拥有一个私有的 Java虚拟机栈，创建线程的同时栈也被创建。一个JVM栈由许多帧组成，称之为”栈帧”。JVM中的栈和C等常见语言中的栈比较类似，都用于保存局部变量和部分计算结果，同时也参与方法调用和返回。 因此，你可以想象一下，一个栈拥有许多栈帧，如下图： 如Oracle官方说明，每个线程拥有自己的私有栈，因此在多线程应用中将有多个栈，每个栈有自己的栈帧。 Java中的栈 当一个新的线程创建时，JVM会为这个线程创建一个新的Stack。一个Java Stack在一个个独立的栈帧中存储了线程的状态。JVM只会在Java Stack中做两个操作：push 和 pop. 一个线程当前正在执行的方法称之为线程的 当前方法，当前方法对应的栈帧称为 当前帧，当前方法所属的类称为 当前类，当前类的常量池称为 当前常量池。 在执行一个方法时，JVM会保存当前类和当前常量池的轨迹。当JVM执行 需要操作栈帧中数据的指令时，JVM会在当前栈帧进行处理。 当一个线程执行一个Java方法时，JVM将创建一个新的栈帧并且把它push到栈顶。此时新的栈帧就变成了当前栈帧，方法执行时，使用栈帧来存储参数、局部变量、中间指令以及其他数据。 Java中的栈帧 栈帧由三部分组成：局部变量表、操作数栈以及帧数据。 每个方法涉及的局部变量表和操作数栈的大小取决于每个具体的方法，但是大小在编译后便已确定，而且已经包含在class文件中。 重要的是：栈帧的大小因局部变量表和操作数栈而异。书中对于size的描述如下： 当JVM执行一个方法时，它会检查class中的数据，以便确定一个方法执行时在局部变量表和操作数栈中所需存储的word size。然后，JVM会为当前方法创建一个size相对应的栈帧，然后把它push到栈顶。 Word size、操作数栈和常量池简述下 word size、operand stack(操作数栈)、constant pool(常量池)这三个短语的定义： word size：它是一个度量单位，在不同类型的JVM中，word size的大小不一定会相同。但是，它至少会有32位以保证可以存储long或double类型。 operand stack：操作数栈在 oracle.com 中被定义。捎带提一嘴，其中的定义涉及到了机器代码，例如：它展示了使用iadd指令进行两个integer的加法操作。 欢迎你深入学习这些细节，但是我们这里只想让你简单知道：操作数栈只是栈帧中的一块内存区域。 常量池：Java运行时常量时在 oracle.com 中定义. 写道：一个运行时常量池 … 包含了许多种常量，编译时的常见数值字面量、运行时需要处理的方法和字段引用等. 运行时常量池和一些编程语言中的符号表有点类似，只不过它比符号表存储的数据范围更广。 堆的特点如下： 堆用于存储创建好的对象和数组(数组也是对象) JVM只有一个堆，被所有线程共享 堆是一个不连续的内存空间，分配灵活，速度慢! 方法区(又叫静态区)特点如下： JVM只有一个方法区，被所有线程共享! 方法区实际也是堆，只是用于存储类、常量相关的信息! 来存放程序中永远是不变或唯一的内容。(类信息【Class对象】、静态变量、字符串常量、静态、非静态方法等) 内存图解1234567891011121314151617181920212223class Computer&#123; String brand;//品牌&#125;public class Stu&#123; int id; String name; int age; Computer comp; void study() &#123; System.out.println("我正在学习！使用电脑:"+comp.brand); &#125; //构造方法 Stu()&#123; &#125; public static void main(String[] args) &#123; Stu stu1=new Stu(); stu1.name="张三"; Computer comp1=new Computer(); comp1.brand="联想"; stu1.comp=comp1; stu1.study(); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类与对象]]></title>
    <url>%2F2019%2F04%2F02%2F%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[类与对象 类可以看做是一个模版，或者图纸，系统根据类的定义来造出对象。我们要造一个汽车，怎么样造?类就是这个图纸，规定了汽车的详细信息，然后根据图纸将汽车造出来。造出来的具体汽车就是对象 类：我们叫做class。 对象：我们叫做Object,instance(实例)。我们说某个类的对象，某个类的实例。是一样的意思。 定义一个类（模板） 1234567891011121314class Student&#123; //属性（成员变量） int id; String name; int age; //方法 public void study() &#123; System.out.println("我爱学习！"); &#125; //构造方法 public Student()&#123; &#125;&#125; 总结 ​ 1.对象是具体的事物;类是对对象的抽象; ​ 2.类可以看成一类对象的模板（蓝图），对象可以看成该类的一个具体实例。 ​ 3.类是用于描述同一类型的对象的一个抽象概念，类中定义了这一类对象所应具有的共同的属性、方法。 ​ 4.面向对象程序设计的重点是类的设计，而不是对象的设计。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象与面向过程]]></title>
    <url>%2F2019%2F04%2F01%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[我们千万不要把面向过程和面向对象对立起来。他们是相辅相成的。面向对象离不开面向过程! 总结 都是解决问题的思维方式，都是代码组织的方式。 解决简单问题可以使用面向过程 解决复杂问题：宏观上使用面向对象把握，微观处理上仍然是面向过程。 面向对象思考方式 遇到复杂问题，先从问题中找名词，然后确立这些名词哪些可以作为类，再根据问题需求确定的类的属性和方法，确定类之间的关系。 建议 面向对象具有三大特征：封装性、继承性和多态性，而面向过程没有继承性和多态性，并且面向过程的封装只是封装功能，而面向对象可以封装数据和功能。所以面向对象优势更明显。 对象说白了也是一种数据结构(对数据的管理模式)，将数据和数据的行为放到了一起。即将相关数据和相关方法封装到一个独立的实体 在内存上，对象就是一个内存块，存放了相关的数据集合! 对象的本质就一种数据的组织方式! 面向过程程序设计：程序=算法+数据结构（动词的集合，关注操作） 面向对象程序设计：程序=对象+消息（名次的集合） 面向过程(Procedure Oriented)面向过程思想思考问题时，我们首先思考“怎么按步骤实现?”并将步骤对应成方法，一步一步，最终完成。 这个适合简单任务，不需要过多协作的情况下。比如，如何开车?我们很容易就列出实现步骤： 发动车 2. 挂挡 3.踩油门 4. 走你 例如把大象放进冰箱,Java语言描述 12345678910111213141516public class Test &#123; public static void main(String[] args) &#123; step1(); step2(); step3(); &#125; public static void step1() &#123; System.out.println("开冰箱门"); &#125; public static void step2() &#123; System.out.println("把大象放进冰箱"); &#125; public static void step3() &#123; System.out.println("关上冰箱门"); &#125;&#125; 面向对象(Object Oriented,OO)面向过程适合简单、不需要协作的事务。 但是当我们思考比较复杂的问题，比如“如何造车?”，就会发现列出1234这样的步骤，是不可能的。那是因为，造车太复杂，需要很多协作才能完成。此时面向对象思想就应运而生了。 面向对象(Object Oriented)思想更契合人的思维模式。我们首先思考的是“怎么设计这个事物?” 比如思考造车，我们就会先思考“怎么设计车?”，而不是“怎么按步骤造车的问题”。这就是思维方式的转变。 一、面向对象思想思考造车，发现车由如下对象组成： 轮胎 发动机 车壳 座椅 挡风玻璃 为了便于协作，我们找轮胎厂完成制造轮胎的步骤，发动机厂完成制造发动机的步骤;这样，发现大家可以同时进行车的制造，最终进行组装，大大提高了效率。但是，具体到轮胎厂的一个流水线操作，仍然是有步骤的，还是离不开面向过程思想! 因此，面向对象可以帮助我们从宏观上把握、从整体上分析整个系统。 但是，具体到实现部分的微观操作(就是一个个方法)，仍然需要面向过程的思路去处理。 例如把大象放进冰箱，Java语言描述 1234567891011121314151617181920public class Test &#123; public static void main(String[] args) &#123; Fridge.open(); Elephant.in(); Fridge.close(); &#125;&#125;class Elephant&#123; public static void in() &#123;//此处用静态方法方便调用 System.out.println("放进冰箱"); &#125;&#125;class Fridge&#123; public static void open() &#123; System.out.println("打开冰箱门"); &#125; public static void close() &#123; System.out.println("关上冰箱门"); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组]]></title>
    <url>%2F2019%2F03%2F29%2F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组数组变量属引用类型，实例化的数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，数组对象本身是在堆中存储的。 数组概念 数组是存储同一种数据类型多个元素的集合。也可以看成是一个容器。 数组既可以存储基本数据类型，也可以存储引用数据类型。（对象的地址）（对象数组） 长度是确定的。数组一旦被创建，它的大小就是不可以改变的。 数组定义格式12type[] arr_name; //（推荐使用这种方式）type arr_name[]; 注意事项 ​ 1. 声明的时候并没有实例化任何对象，只有在实例化数组对象时，JVM才分配空间，这时才与长度有关。 ​ 2. 声明一个数组的时候并没有数组真正被创建。 ​ 3. 构造一个数组，必须指定长度。 数组初始化 Java中的数组必须先初始化,然后才能使用。 所谓初始化：就是为数组中的数组元素分配内存空间，并为每个数组元素赋初值。 数组的初始化方式 动态初始化：初始化时程序猿只指定数组长度，由系统为数组分配默认初始值。 123int[] a1 = new int[2];//动态初始化数组，先分配空间；a1[0]=1;//给数组元素赋值；a1[1]=2;//给数组元素赋值； 静态初始化：初始化时指定每个数组元素的初始值，由系统决定数组长度。 123int[] a=new int[]&#123;1,2,3&#125;;//完整格式,可以简化为下int[] a = &#123; 1, 2, 3 &#125;;// 静态初始化基本类型数组；注意这种方式不能先声明，再简洁初始化。Man[] mans = &#123; new Man(1, 1), new Man(2, 2) &#125;;// 静态初始化引用类型数组； 默认初始化：数组是引用类型，它的元素相当于类的实例变量（实例化的数组可以看成一个对象，数组中的每个元素相当于该对象的成员变量），因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。 123int a2[] = new int[2]; // 默认值：0,0boolean[] b = new boolean[2]; // 默认值：false,falseString[] s = new String[2]; // 默认值：null, null byte,short,int,long ：0 float,double：0.0 char：‘\u0000’ boolean：false 引用类型：null 0x0000(4字节) 但是一定要注意不能同时进行动态初始化和静态初始化。就是不能在给定数组长度的同时给出元素。 例如 1int data[]=new int[3]&#123;1,2,3&#125;;///编译错误！ 数组的内存分配12345678public class TestDemo&#123; public static void main(String[] args) &#123; int data[]=new int[3];//声明数组并分配空间 data[0]=10; data[1]=20; data[2]=30; &#125;&#125; 二维数组java中二维数组内存不是连续的，相当于一个链表，(和C语言不一样)【不建议使用】 二维数组的声明12345678910public class Test &#123; public static void main(String[] args) &#123; // Java中多维数组的声明和初始化应按从低维到高维的顺序进行 int[][] a = new int[3][]; a[0] = new int[2]; a[1] = new int[4]; a[2] = new int[3]; // int a1[][]=new int[][4];//非法 &#125;&#125; 二维数组的动态初始化1234567891011121314import java.util.Arrays;public class Test &#123; public static void main(String[] args) &#123; int[][] a = new int[3][]; // a[0] = &#123;1,2,5&#125;; //错误，没有声明类型就初始化 a[0] = new int[] &#123; 1, 2 &#125;; a[1] = new int[] &#123; 2, 2 &#125;; a[2] = new int[] &#123; 2, 2, 3, 4 &#125;; System.out.println(a[2][3]); System.out.println(Arrays.toString(a[0])); System.out.println(Arrays.toString(a[1])); System.out.println(Arrays.toString(a[2])); &#125;&#125; 二维数组的静态初始化12345678public class Test &#123; public static void main(String[] args) &#123; int[][] a = &#123; &#123; 1, 2, 3 &#125;, &#123; 3, 4 &#125;, &#123; 3, 5, 6, 7 &#125; &#125;; System.out.println(a[2][3]); &#125;&#125; 二维数组的内存分配 对象数组123456789101112131415161718192021222324class Book&#123; private String title; private double price; public Book(String t,double p) &#123; title=t; price=p; &#125; public String toString() &#123; return "titile= "+this.title+",price= "+this.price; &#125;&#125;public class Test01&#123; public static void main(String[] args) &#123; Book books[]=new Book[] &#123; new Book("Java",79.8), new Book("JSP",69.8), new Book("Android",89.8) &#125;; for(Book temp:books) &#123; System.out.println(temp); &#125; &#125;&#125; 1234程序执行结果：titile= Java,price= 79.8titile= JSP,price= 69.8titile= Android,price= 89.8]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位运算符面试问题]]></title>
    <url>%2F2019%2F03%2F28%2F%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[位运算符面试问题请用最有效率的方式写出计算2乘以8的结果答：2&lt;&lt;3 请自己实现两个整数变量的交换 法一 123int temp=a;a=b;b=temp; 法二 123a=a+b;b=a-b;a=a-b; 法三 123a=a^b;b=a^b;//b=a^b^b=a 主要利用性质 x^x=0a=a^b;//a=a^b^a=b x^0=x 法四 1a=(a+b)-(b=a);//不推荐 判断一个数是否是2的n次幂分析：2^n：素数因子只有2 法一:使用循环，若为偶数，一直除以2，最后为1，则为2^n，时间复杂度logn 法二：位运算2^n的数有一特点，转为2进制形式为：只有一个1，其余全为0，因此只需要判断二进制形式是否只有1个1 ​ a: 0000 1000 ​ a-1: 0000 0111 若a不为2^n次，则至少有2个1，例如 ​ b: 0000 1100 ​ b-1: 0000 1011 显然若a是2^n的数，则a&amp;(a-1)=0 123456class TestDemo&#123; public static void main(String[] args)&#123; int a=1024; System.out.println((a&amp;(a-1))==0); &#125;&#125; 一堆整数中都是成双存在，只有一个数是单独存在，请找出这个数？分析：因为一个整数x^x=0 ​ x^0=x 所以，相同的部分^运算后全变成了0，最后一个单独存在的^0得到本身 答：例如有数a,b,c,d,e 用a^b得到a1 a1^c得到a2 以此往复，得到的最后一个数，就是单独的数]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java变量的分类与自动类型转换]]></title>
    <url>%2F2019%2F03%2F26%2FJava%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Java变量的分类与自动类型转换变量的分类 类型 从属于 内存位置 声明位置 生命周期 局部变量 方法/语句块 栈内存（方法被调用时都会创建一个栈帧，存储局部变量等)）（没有默认初始化） 方法或者语句块内 从声明位置开始，直到方法或语句块执行完毕，局部变量消失 成员变量（实例变量） 对象 堆内存（有默认初始化） 类内部，方法外部 对象创建，成员变量也跟着创建。对象消失，成员变量也跟着消失； 静态变量（类变量） 类 方法区中的静态区（有默认初始化） 类内部，方法外部。static修饰。 类被加载，静态变量就有效；类被卸载，静态变量就消失 局部变量（local variable）方法或语句块内部定义的变量。生命周期是从声明位置开始到到方法或语句块执行完毕为止。局部变量在使用前必须先声明、初始化(赋初值)再使用。 成员变量（也叫实例变量 member variable）方法外部、类的内部定义的变量。从属于对象，生命周期伴随对象始终。如果不自行初始化，它会自动初始化成该类型的默认初始值。 数据类型 默认初始值 int 0 double 0.0 char ‘\u0000’ boolean false 静态变量（类变量 static variable） 使用static定义。 从属于类，生命周期伴随类始终，从类加载到卸载。 如果不自行初始化，与成员变量相同会自动初始化成该类型的默认初始值，如上表所示。 123456789101112public class TestVariable&#123; int a;//成员变量，从属于对象；成员变量会自动被初始化 static int size; //静态变量，从属于类 public static void main(String[] args) &#123; &#123; int age=18;//局部变量，从属于语句块 &#125; int salary=3000;//局部变量，从属于方法 int i;//局部变量，必须初始化 int j=i+5;//编译出错，变量i还未被初始化 &#125;&#125; 自动类型转换 数据范围小的数据与数据范围大的数据进行数学计算时，自动向大范围的数据类型转换后计算。（例如int和long计算，则int类型先自动变为long类型，再计算） 常量也有类型，常整数为int，常浮点数为double 12long a = 55555555; //编译成功，在int表示的范围内(2.1e9内)。long b = 55555555555;//不加L编译可通过，但是结果不正确，已经超过int表示的范围，数据溢出。 我们修改成long类型的常量即可 1long b = 55555555555L; 1234567public class Test02 &#123; public static void main(String[] args) &#123; int microPerDay=24*60*60*1000; long nanosPerDay=24*60*60*1000*1000*1000L; System.out.print(nanosPerDay/microPerDay); &#125;&#125; 输出： 15794//显然溢出了 这是因为24*60*60*1000*1000数据已经溢出，需要修改如下 1long nanosPerDay=24L*60*60*1000*1000*1000; 此时第一个数就变成long类型，计算正确 11000000//结果正确 12float f=(float)1.24;float f=1.24f; 问：这两种赋值方式一样么？ 答：不一样。 第一种方式，底层存储double类型，占8字节，再强制类型转换成float 第二种方式，底层 存储float类型，占4字节（推荐使用） 注意事项 byte,short,char参与运算的时候默认会转换成int类型，即使是统一数据类型相加也会转成int型 1234567public static void main(String[] args) &#123; byte b=10; byte c=10;//编译器会自动判断是否处于byte范围内。若属于，则编译通过 short a=10;//同理 byte d=b+c;//此处报错，Type mismatch: cannot convert from int to byte，b+c时候，自动转换成int类型 short s=b;//此处没问题&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java命名规范]]></title>
    <url>%2F2019%2F03%2F26%2FJava%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[Java命名规范只是建议 类和接口名称：每一个单词首字母大写，例如：TestDemo; 变量/方法名称：第一个单词首字母小写，之后每个单词的首字母大写，例如：studentName;printInfo();【驼峰原则】 常量名称：每个字母大写,若有多个单词，以_分割，例如：FLAG，MAX_VALUE; 包名称：所有字母小写 ​ 多级包： 域名反转，例如：www.zju.edu.cn –&gt; cn.edu.zju]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Typora快速编辑Markdown]]></title>
    <url>%2F2019%2F03%2F23%2F%E4%BD%BF%E7%94%A8Typora%E5%BF%AB%E9%80%9F%E7%BC%96%E8%BE%91Markdown%2F</url>
    <content type="text"><![CDATA[标题标题是用“#”实现的，标题前面加一个“#”，代表一级标题；依次类推，标题前面加六个“#”代表六级标题；一共有六级标题，编辑各种文档完全够用。 #+空格+标题内容 下划线快捷键Ctrl+u，即可实现下划线功能。 强调内容的前后分别加两个*号 斜体内容前后分别加一个\号* 斜体加粗*前后加3个** 删除线先转化成英文输入法，再把内容前后分别加上两个~号 特别注意是2个~ 列表有序列表输入数字“1”+“.”+”空格”，自动开始有序列表。 步骤1 步骤2 步骤3 无序列表输入“+”或者“-”或者“*”+空格，自动开始无序列表 步骤1 步骤2 步骤3 tableCtrl+T,在弹出的对话框中选择行列数，自动生成列表。还可以很方便地对表格进行编辑。 学号 姓名 成绩 xxx xxx xxx asd 分割线有时候，为了排版漂亮，可能会加入分隔线。Markdown加入分隔线非常简单，使用下面任意一种形式都可以 12***--- 插入图片插入本地图片设置主题_config.ymlpost_asset_folder: true当资源文件管理功能打开后，Hexo将会在你每一次通过hexo new post &lt;title&gt;命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个markdown文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹之中，你可以通过相对路径来引用它们，这样你就得到了一个简单而且方便很多的工作流。123&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; 例如本例中，将ZJU.jpg放到资源文件夹中。通过 1&#123;% asset_img ZJU.jpg 测试%&#125; 命令插入，其中[title]可省略 插入代码`System.out.println(“Hello World!”);`System.out.println(&quot;Hello World!&quot;);```System.out.println(“Hello Hexo”);System.out.println(“Hello World!”);``` 12System.out.println("Hello Hexo");System.out.println("Hello World!"); 行内代码引用，使用单个反引号进行包裹（Tab上面那个），代码块用三个反引号包裹。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Markdown 编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo写博客攻略]]></title>
    <url>%2F2019%2F03%2F22%2F%E4%BD%BF%E7%94%A8hexo%E5%86%99%E5%8D%9A%E5%AE%A2%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[新建文章在站点的根目录下执行以下命令：(本博客站点根目录为D:\blog\WJJ711)$ hexo new post &lt;title&gt;//此处title不需要加双引号例如$ hexo new post 使用hexo写攻略可以简写为$ hexo n &lt;title&gt;例如$ hexo n 使用hexo写攻略 给文章添加分类，标签 1 使用Subline Text 打开《使用hexo写博客攻略》 2 设置如下：12345678---title: 使用hexo写博客攻略date: 2019-03-22 19:34:50tags: - hexo - Markdown 编辑器categories: hexo--- 注意 - 后面的空格！ 3 博客正文需要在---下面撰写 一级标题使用一个#+空格+内容 二级标题使用2个#+空格+内容 三级标题使用3个#+空格+内容 设置列表Markdown支持有序列表和无序列表两种形式：无序列表用*或+或-标识有序列表用数字加.标识，例如1. 列表1 列表2 a 子列表1 b 子列表2 列表312345- 列表1- 列表2 a 子列表1 b 子列表2- 列表3 注意- 后面的空格 添加网站链接B站导航[B站导航](https://www.bilibili.com/)注意：https://不能少 插入图片插入本地图片设置主题_config.ymlpost_asset_folder: true当资源文件管理功能打开后，Hexo将会在你每一次通过hexo new post &lt;title&gt;命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个markdown文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹之中，你可以通过相对路径来引用它们，这样你就得到了一个简单而且方便很多的工作流。 123&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; 例如本例中，将ZJU.jpg放到资源文件夹中。通过1&#123;% asset_img ZJU.jpg 测试%&#125; 命令插入，其中[title]可省略注意，此处必须用```加换行的方式插入上面代码 制表语法如下：123表头|条目一|条目二:---:|:---:|:---:项目|项目一|项目二 以上标记效果显示如下： 表头 条目一 条目二 项目 项目一 项目二 语法说明 |、-、:之间多余的空格会被忽略，不影响布局。 三个短斜杠左右的冒号用于控制对齐方式，只放置左边冒号表示文字居左，只放置右边冒号表示文字居右，如果两边都放置冒号表示文字居中。 表格的语句上一行必须为空行，不然表格不生效 强调有时候，我们希望对某一部分文字进行强调，使用*或_包裹即可。使用单一符号标记的效果是斜体，使用两个符号标记的效果是加粗12345*这里是斜体*_这里是斜体_**这里是加粗**__这里是加粗__ 这里是斜体这里是斜体 这里是加粗这里是加粗 分割线有时候，为了排版漂亮，可能会加入分隔线。Markdown加入分隔线非常简单，使用下面任意一种形式都可以 12***--- 插入代码`System.out.println(“Hello World!”);`System.out.println(&quot;Hello World!&quot;);```System.out.println(“Hello Hexo”);System.out.println(“Hello World!”);```12System.out.println(&quot;Hello Hexo&quot;);System.out.println(&quot;Hello World!&quot;); 行内代码引用，使用单个反引号进行包裹（Tab上面那个），代码块用三个反引号包裹。 使用反斜杠\插入语法中用到的特殊符号在Markdown中，主要有以下几种特殊符号需要处理：123456789101112\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 例如要输出```需要1\`\`\`]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Markdown 编辑器</tag>
      </tags>
  </entry>
</search>
