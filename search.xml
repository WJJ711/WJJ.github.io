<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[String和StringBuffer]]></title>
    <url>%2F2019%2F04%2F09%2FString%E5%92%8CStringBuffer%2F</url>
    <content type="text"><![CDATA[概述 String类又称作不可变字符序列。对于不可变对象，本身就是线程安全的，不需要同步机制去保证。 String面试题1. String s = new String(“hello”);和String s = “hello”;的区别? String s = new String(“hello”);创建了两个对象，常量池中的”hello”，和堆内存中的对象 String s = “hello”;只创建了一个对象 2. 123456789String s1 = "hello";String s2 = "world";String s3 = "helloworld";System.out.println(s3==(s1+s2));//falseSystem.out.println(s3.equals(s1+s2));//true System.out.println(s3==("hello"+"world"));//true"hello"和"world"在编译时会自动拼接并放入常量池。所以常量池中有"helloworld"System.out.println(s3.equals("hello"+"world"));//true String 与其它类型数组转换功能## byte[] 1234String s="abc";byte[] b=s.getBytes();//[97, 98, 99]byte[] m=&#123;97, 98, 99&#125;;String str=new String(m);//abc char[]123456String s="abc";char[] c=s.toCharArray();//[a, b, c]System.out.println(Arrays.toString(c));char[] m=&#123;'a', 'b', 'c'&#125;;String str=new String(m);//abcSystem.out.println(str); StringBuffer线程安全的可变字符序列 添加功能123public StringBuffer append(String str);public StringBuffer insert(int offset,String str); 删除功能123public StringBuffer deleteCharAt(int index);public StringBuffer delete(int start,int end); 替换功能1public StringBuffer replace(int start,int end,String str); 反转功能1public StringBuffer reverse();]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object类]]></title>
    <url>%2F2019%2F04%2F08%2FObject%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Object类Object类是所有Java类的根基类，也就意味着所有的Java对象都拥有Object类的属性和方法。如果在类的声明中未使用extends关键字指明其父类，则默认继承Object类。 getClass()public final Class getClass() 返回对象的运行时类 Class:类类型，用来描述类型的类 ​ String getName（）：返回该类的全限定名 注意事项 返回的是运行时类 用final修饰，所有对象该方法行为一致(均返回的是运行时类) 重写equals 若父类和子类不能比较，则用getClass(); 若要求父类和子类能比较，则要用，instanceof 123Object s="123";System.out.println(s.getClass());//返回实例化对象的类型System.out.println(s.getClass().getName());//返回该类的全限定名 输出结果： 12class java.lang.Stringjava.lang.String equals(Object)方法重写的一般方法 equals(Objcet obj),的参数类型一定是Object类型，不然就不是Override覆写而是Overloading重载了！！ 对于一个子类添加了一个新的比较属性，就不能同时满足对称性和传递性。一般处理就是父类和子类不能比较，即返回false，使用 this.getClass()==obj.getClass()判断（这也是IDEA自动生成的版本） 对于子类没有添加一个新属性，就可以使用instanceof进行判断 hashCode()public int hashCode() 概述：返回该对象的哈希码值 默认实现：一般是通过将该对象的内存地址转换成一个整数 如果重写了equals方法， 也应该重写hashCode hash算法：1. 看成一个**模拟随机**映射 2. 映射：定义域与值域 hashCode()方法，其实也是一个hash算法 1. 定义域：内存地址 2. 值域：int的表示范围 特点：同一个对象的hashCode肯定一样，不同对象的hashCode一般来说不一样，但是有极小概率一样 对于随机映射而言，两个不同对象的hashCode一样的概率1/(4e9)；（int范围） hash算法是加密算法么？ ​ hash算法不是加密算法 ​ 加密算法肯定能解密，hash算法是一个映射函数，不能解密，只有一对一映射才能有反函数，才能解密。 hashCode的常规协议 一致性：一个对象的值没有改变时，在程序运行期间，不同时刻调用hashCode（）方法，必须返回同一个整数。 如果重写了equals（Object）方法， 也应该重写hashCode，即用equals(Object)方法比较两个对象相等，那么对这两个对象调用hashCode方法都必须生成相同的整数。 ​ 即把对象的属性分成关键域、衍生域、无关域，equals(Object)和hashCode()都应该只根据关键域的属性判定 如果根据equals（Object）方法，两个对象不相等，那么对这两个对象中任一对象调用hashCode()方法不要求一定生成不同的hash值。 但是程序员应该意识到，为不相等的对象生成不同的整数结果可以提高哈希表的性能。 clone()projected Object clone() 因为是projected修饰，所以（如果在同一个包则可以访问）如果在不同包，只能用子类对象访问，且子类需要实现Cloneable接口。 深拷贝和浅拷贝 浅拷贝只是将一个对象的所有属性值全部拷贝过来，若有引用数据类型，则拷贝对应的内存地址。故引用数据类型指向的对象是公用的，并没有在堆中生成新的对象。 Object类默认实现的是浅拷贝。 （即引用数据类型拷贝的只是地址） 如何实现深拷贝例如对该类进行拷贝 12345class People implements Cloneable&#123; int age;//基本数据类型 String name;//引用数据类型 Job job;//引用数据类型&#125; 在重写clone方法中： 实现Cloneable接口 重写clone方法，该方法抛出异常 调用super.clone()方法。完成基本数据类型的拷贝 1People peopleClone = (People) super.clone(); 对引用数据类型进行拷贝，多层的深拷贝，应该在每个类中重写clone 12String nameClone=new String(name);Job jobClone= (Job) job.clone(); 完成引用数据类型的拷贝 12peopleClone.name=nameClone;peopleClone.job=jobClone; 返回clone 1return peopleClone; 一个深拷贝示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import java.util.Objects;public class TestDemo&#123; public static void main(String[] args) throws CloneNotSupportedException &#123; People p=new People(18,"小张",new Job("程序猿",19999)); People clone= (People) p.clone(); System.out.println(p==clone);//false System.out.println(p.equals(clone));//true System.out.println(p.name==clone.name);//false System.out.println(p.name.equals(clone.name));//true System.out.println(p.job==clone.job);//false System.out.println(p.job.equals(clone.job));//true &#125;&#125;class People implements Cloneable&#123; int age; String name; Job job; public People(int age, String name, Job job) &#123; this.age = age; this.name = name; this.job = job; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; People people = (People) o; return age == people.age &amp;&amp; Objects.equals(name, people.name) &amp;&amp; Objects.equals(job, people.job); &#125; @Override public int hashCode() &#123; return Objects.hash(age, name, job); &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; People peopleClone = (People) super.clone(); String nameClone=new String(name); Job jobClone= (Job) job.clone(); peopleClone.name=nameClone; peopleClone.job=jobClone; return peopleClone; &#125;&#125;class Job implements Cloneable&#123; String work; double salary; @Override protected Object clone() throws CloneNotSupportedException &#123; Job jobClone= (Job) super.clone(); String workClone=new String(work); jobClone.work=workClone; return jobClone; &#125; public Job(String work, double salary) &#123; this.work = work; this.salary = salary; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Job job1 = (Job) o; return Double.compare(job1.salary, salary) == 0 &amp;&amp; Objects.equals(work, job1.work); &#125; @Override public int hashCode() &#123; return Objects.hash(work, salary); &#125;&#125;]]></content>
      <categories>
        <category>JaveSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内部类]]></title>
    <url>%2F2019%2F04%2F06%2F%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[定义把类定义在其他类的内部，这个类就被称为内部类。即在类A中定义了一个类B，类B就是内部类。 由于内部类提供了更好的封装特性，并且可以很方便的访问外部类的属性，所以通常内部类在只为所在外部类提供服务的情况下优先使用 举例：电脑+CPU：CPU是电脑的一个成员，cpu还得和其它成员打交道 第一个作用：隐藏内部类 第二个作用：为了更好的和外部类的其它成员交流 内部类的访问特点： 内部类可以直接访问外部类的成员，包括私有。 外部类要访问内部类的成员，必须创建对象。 注意一般情况下，内部类都会用private进行修饰，不对外部开放。 内部类的分类：成员内部类： 非静态内部类 和 静态内部类 局部内部类 匿名内部类 非静态内部类（inner class）非静态内部类的对象是外部类对象的一个成员 非静态内部类怎么访问外部类？ 答：直接访问，好像定义在自己类中的一样，并且可以访问外部类的私有成员 外部类怎么访问非静态内部类？ 答：创建非静态内部类对象，并且可以访问非静态内部类的私有成员 其他类怎么访问非静态内部类？ 答：创建非静态内部类对象，并且受访问权限限制（不能访问private） 格式：Outer.Inner inner =new Outer().new Inner(); 为什么非静态内部类可以直接访问外部类成员，就像定义在自己里面 答：非静态内部类对象秘密捕获了一个外部类对象 使用要点 i. 非静态内部类必须寄存在一个外部类对象里。因此，如果有一个非静态内部类对象那么一定存在对应的外部类对象。非静态内部类对象单独属于外部类的某个对象。 ii. 非静态内部类可以直接访问外部类的成员，但是外部类不能直接访问非静态内部类成员。 iii. 非静态内部类不能有静态方法、静态属性和静态初始化块。 iv. 外部类的静态方法、静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例。 123456789101112class Outer &#123; private int age = 10; class Inner &#123; int age = 20; public void show() &#123; int age = 30; System.out.println("内部类方法里的局部变量age:" + age);// 30 System.out.println("内部类的成员变量age:" + this.age);// 20 System.out.println("外部类的成员变量age:" + Outer.this.age);// 10 &#125; &#125;&#125; 静态内部类（nest class）静态内部类对象是外部类的成员（属于类，不是属于对象） 内部类怎么访问外部类？ 答：可以直接访问外部类私有的成员，就像定义在自己里面一样。但是只能访问外部类静态成员 外部类怎么访问内部类？ 创建内部类对象，并且能够访问内部类私有成员 其他类怎么访问内部类： 创建内部类对象：Outer.Inner inner = new Outer.Inner(); 但是受到权限修饰符的限制（不能访问private） 使用要点 当一个静态内部类对象存在，并不一定存在对应的外部类对象。 因此，静态内部类的实例方法不能直接访问外部类的实例方法。 静态内部类看做外部类的一个静态成员。 因此，外部类的方法中可以通过：“静态内部类.名字”的方式访问静态内部类的静态成员，通过 new 静态内部类()访问静态内部类的实例。 局部内部类 内部类怎么访问外部类： 答：直接访问，就像定义在自己里面一样，并且能够访问外部类私有的成员 外部类怎么访问内部类 外部类不能访问。只能在定义这个类的方法里面访问。**并且只能通过创建对象访问。能够访问所有私有的成员 其他类怎么访问内部类 不能 注意事项： 局部内部类访问局部变量必须被final修饰。：must be final or effectively final 一旦被局部内部类访问了，该局部变量自动变成final类型，写不写final都是final 推荐加上final 为什么呢？ 因为局部变量会随着方法的调用完毕而消失，这个时候，局部对象并没有立马从堆内存中消失，还要使用那个变量。为了让数据还能继续被使用，就用final修饰，这样，在堆内存里面存储的其实是一个常量值。 怎么访问外部类 外部类怎么访问内部类？ 其他类怎么访问内部类 注意事项 非静态内部类 非静态内部类的对象是外部类对象的一个成员 直接访问，好像定义在自己类中的一样，并且可以访问外部类的私有成员 创建非静态内部类对象，并且可以访问内部类的私有成员 Outer.Inner inner =new Outer().new Inner();创建非静态内部类对象，并且受访问权限限制（不能访问private） 非静态的内部类的成员只能是非静态的。 静态内部类（nest class） 静态内部类对象是外部类的成员 可以直接访问外部类私有的成员，就像定义在自己里面一样。但是只能访问外部类静态成员 创建内部类对象，并且能够访问内部类私有成员 Outer.Inner inner =new Outer.Inner()；但是受到权限修饰符的限制（不能访问private） 静态内部类成员有静态的和非静态的 局部内部类 它是定义在方法内部的，作用域只限于本方法，称为局部内部类。 直接访问，好像定义在自己类中的一样，并且可以访问外部类的私有成员 外部类不能访问。只能在定义这个类的方法里面访问。并且只能通过创建对象访问。能够访问所有私有的成员 不能 局部内部类访问局部变量必须被final修饰。：must be final or effectively final 内部类举例123456789101112131415161718192021222324class Face&#123; String type="瓜子脸"; private class Nose&#123; String type="鹰钩鼻"; public void breath() &#123; System.out.println("吸一口氧气"); System.out.println("脸型："+Face.this.type);//内部类可直接访问外部类成员 &#125; &#125; Nose nose =new Nose();//外部类访问内部类需要创建对象 public String toString()&#123; return "脸型:"+type+",鼻型:"+nose.type; &#125; public void getBreath()&#123; nose.breath();//因为内部类是私有的，需要用get执行内部类的方法 &#125;&#125;public class InnerClass&#123; public static void main(String[] args) &#123; Face face = new Face(); System.out.println(face); face.getBreath(); &#125;&#125; 执行结果： 123脸型:瓜子脸,鼻型:鹰钩鼻吸一口氧气脸型：瓜子脸 匿名内部类概述就是内部类的简化写法。 前提：存在一个类或者接口 这里的类可以是具体类也可以是抽象类。 格式：1234new 父类构造器(实参类表) \实现接口 () &#123; @override //匿名内部类类体！&#125; 重写方法; }//前面是创建对象，后面是重写父类或接口 本质：是一个继承了类或者实现了接口的子类匿名对象 本质是一个对象！！！ 理解： 我要创建一个类或者接口，但是我又不想重写一个类去继承该类或者实现该接口，这时可以用匿名类 注意 匿名内部类没有访问修饰符。 匿名内部类没有构造方法。因为它连名字都没有那又何来构造方法呢。 匿名内部类示例123456789101112131415161718interface Inter &#123;//定义接口 void show();&#125;class Outer&#123; public static Inter method()&#123; return new Inter() &#123; @Override//匿名内部类 public void show() &#123; System.out.println("Hello world"); &#125; &#125;; &#125;&#125;public class TestDemo &#123; public static void main(String[] args) &#123; Outer.method().show(); &#125;&#125; 示例212345678910111213141516interface A &#123; void show();&#125;public class TestDemo &#123; public static void test(A a)&#123; a.show(); &#125; public static void main(String[] args) &#123; TestDemo.test(new A()&#123;//匿名内部类 @Override public void show()&#123; System.out.println("Hello world"); &#125; &#125;); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[权限修饰符]]></title>
    <url>%2F2019%2F04%2F05%2F%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[注意：这里的默认不是default关键字！default methods are allowed only in interfaces. 这里的默认修饰符是包访问权限 public protected 默认（就是不写）（包访问权限） private 同一类中 √ √ √ √ 同一包子类,其他类 √ √ √ 不同包子类 √ 不能通过父类直接访问。 只能通过子类对象去访问 不同包其他类 √ 面向对象程序设计： 有哪些类 每一类中由哪些职责 类与类之间的关系 类与类之间怎么协作 类与类之间怎么访问 类及其组成可以用的修饰符权限修饰符：public ，protected，默认，private 状态修饰符：final ，static 抽象修饰符： abstract 权限修饰符 状态修饰符 抽象修饰符 普通类 public，默认 final abstract 成员变量 均可，自己定义，private居多 final，static 不行 构造方法 4种均可，自己定义，public居多 不行 不行 成员方法 均可，自己定义public居多 final，static abstract protected，private，static只能修饰类的成员]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口interface]]></title>
    <url>%2F2019%2F04%2F05%2F%E6%8E%A5%E5%8F%A3interface%2F</url>
    <content type="text"><![CDATA[接口代表的是功能例如USB上的接口，扩展作用。 继承体现的是is a的关系 接口体现的是like a的关系，例如：猴子可以像人一样计算。 譬如游泳这一接口，谁都可以实现。 在Java中，接口主要用于解决单继承局限的问题 接口特点 接口是两个模块之间通信的标准，通信的规范。如果能把你要设计的模块之间的接口定义好，就相当于完成了系统的设计大纲，剩下的就是添砖加瓦的具体实现了。大家在工作以后，做系统时往往就是使用“面向接口”的思想来设计系统。 接口的本质是契约，就像我们人间的法律一样。制定好后大家都遵守。 接口用关键字interface表示 格式：interface 接口名 {} 类实现接口用implements表示 格式：class 类名 implements 接口名 {} 接口不能实例化 那么，接口如何实例化呢? 答：按照多态的方式，由具体的子类实例化，其实这也是多态的一种，接口多态 接口的子类 抽象类：不必重写所有的抽象方法 具体类：重写接口中的所有抽象方法 成员常量只能是常量 默认修饰符 public static final 123456789101112public class TestDemo &#123; public static void main(String[] args) &#123; Inter inter=new Demo(); System.out.println(inter.num1); inter.num1=12; //编译报错The final field Inter.num1 cannot be assigned &#125;&#125;interface Inter&#123; int num1=100;&#125;class Demo implements Inter&#123;&#125; 构造方法没有构造方法，不能实例化。 因为接口中所有的成员变量都是静态常量，不能实例化成对象，不需要初始化。 成员方法接口中所有成员的访问权限都是public ​ 接口表示的是一个功能，所以谁都可以实现它。 JDK1.7之前，接口中只能包含静态常量、抽象方法，不能有普通属性、构造方法、普通方法。 ​ 抽象方法：默认用public abstract修饰 JDK1.8后：接口中包含普通的静态方法和默认方法。 默认方法：如果该接口的子类没有重写该方法，就是这个默认方法。这里的default表示的不是访问权限，表示的是默认方法 这里其实是public default void method() 但是接口中public推荐省略 123 default void method()&#123; System.out.println("123");&#125; ​ 2. 静态方法：静态方法只能通过接口名.静态方法（）调用，不能通过子类调用 123static void function()&#123; System.out.println("123");&#125; 接口与类的关系类与类：继承关系，只能单继承，但是可以多层继承 类与接口：实现关系，也可以多实现，还可以继承一个类的同时实现多个接口 接口与接口：继承关系，可以单继承，也可以多继承 抽象类与接口的区别 抽象类 方法 变量 构造方法 关系区别 设计理念 抽象类 抽象方法，普通方法，静态方法 变量，常量 有 类与类（继承），单继承；类与接口 （实现），单实现，多实现 抽象类 被继承体现的是：”is a”的关系。共性功能 接口 JDK1.8之前，只能有抽象方法 ； JDK1.8以后有默认方法（default）、静态方法、抽象方法 常量，默认public static final 无 接口与接口（继承），单继承，多继承 接口 被实现体现的是：”like a”的关系。扩展功能 接口的实际应用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051interface USB&#123; default void printInfo() &#123;//默认方法 System.out.println("采用USB接口连接"); &#125; void start();//抽象方法 void stop(); static void usbInfo() &#123;//静态方法 System.out.println("USB4.0"); &#125;&#125;class Print implements USB&#123;//打印机类 public void printInfo() &#123;//覆写默认方法 System.out.println("打印机类覆写默认方法"); &#125; @Override public void start() &#123; System.out.println("打印机连接！"); &#125; @Override public void stop() &#123; System.out.println("打印机断开连接!"); &#125; &#125;class Flash implements USB&#123; @Override public void start() &#123; System.out.println("U盘连接！"); &#125; @Override public void stop() &#123; System.out.println("U盘断开连接!"); &#125; &#125;class Computer&#123; public void plugin(USB usb) &#123; usb.printInfo();//默认方法 usb.start();//抽象方法 usb.stop();//抽象方法 //usb.usbInfo();//编译错误，接口的静态方法只能通过接口名调用 USB.usbInfo(); &#125;&#125;public class HW4&#123; public static void main(String[] args) &#123; Computer computer=new Computer(); computer.plugin(new Flash()); System.out.println("--------------"); computer.plugin(new Print()); &#125;&#125; 输出结果： 123456789采用USB接口连接U盘连接！U盘断开连接!USB4.0--------------打印机类覆写默认方法打印机连接！打印机断开连接!USB4.0]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象类]]></title>
    <url>%2F2019%2F04%2F05%2F%E6%8A%BD%E8%B1%A1%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[抽象方法使用abstract修饰的方法，没有方法体，只有声明。定义的是一种“规范”，就是告诉子类必须要给抽象方法提供具体的实现。 抽象类包含抽象方法的类就是抽象类。通过abstract方法定义规范，然后要求子类必须定义具体实现。通过抽象类，我们就可以做到严格限制子类的设计，使子类之间更加通用。 抽象类的使用要点 有抽象方法的类只能定义成抽象类，抽象类不一定有抽象方法 问题1：没有抽象方法的抽象类，有什么意义 答：阻止直接对该类进行实例化。 问题2：怎么对Animal类型的数据进行赋值？ 回答：多态赋值，可以把抽象类的子类对象赋值给抽象类 抽象类不能实例化，即不能用new来实例化抽象类。 抽象类可以包含属性、方法、构造方法。但是构造方法不能用来new实例，只能用来被子类调用。 抽象类只能用来被继承。抽象类是为继承而生的，没有子类的抽象类毫无意义 抽象类的子类： 具体类：具体类必须重写（override）抽象类的所有抽象方法 抽象类：抽象的子类不必重写抽象类的所有抽象方法 抽象类的成员特点成员变量​ 可以是变量也可以是常量 构造方法问题：抽象类可以直接实例化么？ 答：不能 问题：构造方法的作用是什么？ 答：给对象初始化 。new + 构造方法 创建对象 问题：抽象类有构造方法么，它不能实例化，那么有什么作用？ 答：有，给子类服务的，用于子类访问，对父类数据的初始化 成员方法a. 抽象方法 ​ 限制非抽象的子类必须重写这些抽象方法（标准） b. 非抽象方法 ​ 提供一个默认实现。（父类提供一个默认的行为） ​ 抽象类举例，员工案例分析：具体—-&gt;抽象 普通员工： ​ 属性：姓名、工号、工资 ​ 行为：工作、吃饭 经理： ​ 属性：姓名、工号、工资、奖金 ​ 行为：工作、吃饭 员工（抽象） ​ 属性：姓名、工号、工资 ​ 行为：工作【抽象】、吃饭 实现： ​ Employee:(抽象) ​ 属性：name,id,salary ​ 行为：work()【抽象】,eat() ​ Staff: ​ Manager: ​ 属性：bonus 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class TestDemo &#123; public static void main(String[] args) &#123; Employee e1=new Staff("华安","9527",100); e1.work(); e1.eat(); System.out.println("----------------------"); Employee e2=new Manager("小张","10002",100000,10000); e2.work(); e2.eat(); &#125; &#125;abstract class Employee&#123; String name; String id; double salary; public Employee() &#123; &#125; public Employee(String name,String id,double salary) &#123; this.name=name; this.id=id; this.salary=salary; &#125; public abstract void work(); public void eat() &#123; System.out.println("工作饿了，我要吃饭~"); &#125;&#125;class Staff extends Employee&#123; public Staff() &#123; &#125; public Staff(String name,String id,double salary) &#123; super(name,id,salary); &#125; public void work() &#123; System.out.println("努力搬砖"); &#125;&#125;class Manager extends Employee&#123; double bonus; public Manager()&#123; &#125; public Manager(String name,String id,double salary,double bonus) &#123; super(name,id,salary); this.bonus=bonus; &#125; public void work() &#123; System.out.println("和客户撕逼~~~"); &#125;&#125; 结果： 12345努力搬砖工作饿了，我要吃饭~----------------------和客户撕逼~~~工作饿了，我要吃饭~ 几个小问题 一个类如果没有抽象方法，可不可以定义为抽象类，如果可以，有什么意义？ 答：可以，防止它进行实例化 abstract不能和哪些关键字共存 private private abstract为非法的修饰符组合，因为abstract修饰的方法必须被子类重写，private修饰的方法不能被子类继承 final final anstract为非法的修饰符组合，因为abstract修饰的方法必须被子类重写，final修饰的方法不能被重写 static static abstract为非法的修饰符组合，static修饰的方法能够直接被类调用，类优先于对象存在。抽象方法没有实现，只有定义。（无意义）]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常机制]]></title>
    <url>%2F2019%2F04%2F04%2F%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"></content>
      <categories>
        <category>未完待续</category>
      </categories>
      <tags>
        <tag>未完待续</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象三大特性3——多态]]></title>
    <url>%2F2019%2F04%2F04%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A73%E2%80%94%E2%80%94%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[多态(polymorphism)多态指的是同一个方法调用，由于对象不同可能会有不同的行为。现实生活中，同一个方法，具体实现会完全不同。 比如：同样是调用人“吃饭”的方法，中国人执行就是用筷子吃饭，英国人执行就是用刀叉吃饭，印度人执行用手吃饭。 多态的要点： 多态是方法的多态，不是属性的多态(多态与属性无关)。 多态的存在要有3个必要条件：继承（实现），方法重写，父类引用指向子类对象。 父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了。 成员访问特点成员变量​ 编译看左边，运行看左边 静态变量​ 编译看左边，运行看左边 成员方法​ 编译看左边，运行看右边（多态！！！） 静态方法​ 编译看左边，运行看左边 孔子装爹​ 从前有个圣人叫孔子，孔子教论语，孔子他爹教农耕； ​ 孔子爹就比较忙，经常外出讲课，收入很高； ​ 有一天，又有人请孔子爹去教农耕，恰巧孔子爹不在。给的报酬很高，孔子就心动了。就打算打扮成他爹的样子去，穿上爹的衣服，带上爹的帽子，粘上小胡子就去了。Father f=new Son();f.name f.age 其实是爹的属性，因为别人看到的是孔子爹的属性（样貌）。别人请孔子教农耕，孔子就露馅了f.teach(）教的是论语。 1234567891011121314151617181920212223242526272829class KongDie&#123; int age=70; String name="老爹"; public static void sleep() &#123; System.out.println("孔爹睡觉"); &#125; public void teach() &#123; System.out.println("孔爹教农耕"); &#125;&#125;class Kong extends KongDie&#123; int age=30; String name="小孔"; public static void sleep() &#123; System.out.println("小孔睡觉"); &#125; public void teach() &#123; System.out.println("小孔教论语"); &#125;&#125;public class TestDemo&#123; public static void main(String[] args) &#123; KongDie f=new Kong(); System.out.println("年龄:"+f.age); System.out.println("姓名:"+f.name); f.sleep(); f.teach(); &#125;&#125; 运行结果： 1234年龄:70 //成员变量，运行看左边姓名:老爹//成员变量，运行看左边孔爹睡觉//静态方法，运行看左边小孔教论语//成员方法,运行看右边，多态！ 多态的好处 提高了程序的维护性（由继承保证） 提高了程序的扩展性（由多态保证） 多态的弊端 不能访问子类特有功能 那么我们如何才能访问子类的特有功能呢? 多态中的转型 多态中的转型问题向上转型​ 父类引用指向子类对象，我们称这个过程为向上转型，属于自动类型转换。 1Father father=new Son(); 向下转型​ 向上转型后的父类引用变量只能调用它编译类型的方法，不能调用它运行时类型的方法。这时，我们就需要进行类型的强制转换，我们称之为向下转型! 1Son son=(Son)father;//父类引用变量father实际上指向的是子类对象 面试题123456789101112131415161718192021222324252627282930313233343536373839class A&#123; char x='A'; public void show()&#123; System.out.println("父类A中的this地址为："+this); this.show2(); &#125; public void show2()&#123; System.out.println("我"); &#125;&#125;class B extends A &#123; char x='B'; public void show2()&#123; System.out.println("爱"); &#125;&#125;class C extends B &#123; char x='C'; public void show()&#123; System.out.println("子类C的super的地址为："+ super.toString()); super.show(); &#125; public void show2()&#123; System.out.println("你"); &#125;&#125;public class TestDemo &#123; public static void main(String[] args) &#123; A a = new B(); System.out.println("a的地址是："+a); System.out.println("a.x= "+a.x); a.show(); System.out.println("------------------------"); B b = new C(); System.out.println("b的地址是："+b); System.out.println("b.x= "+b.x); b.show(); &#125;&#125; 输出结果： 12345678910a的地址是：classlib.B@36d64342a.x= A//成员变量没有多态，编译运行都看左边父类A中的this地址为：classlib.B@36d64342爱------------------------b的地址是：classlib.C@511baa65b.x= B//成员变量没有多态，编译运行都看左边子类C的super的地址为：classlib.C@511baa65//super表示的是该对象内存中的一部分地址，该部分存储了从父类中继承的成员父类A中的this地址为：classlib.C@511baa65你 多态的内存分析 模拟Servlet并内存分析1234567891011121314151617181920212223public class TestDemo&#123; public static void main(String[] args) &#123; HttpServlet s=new MyServlet(); s.service(); System.out.println("对象s的内存地址"+s); &#125;&#125;class HttpServlet&#123; public void service() &#123; System.out.println("HttpServlet.service()"); System.out.println("调用doGet()时的内存地址"+this); this.doGet(); &#125; public void doGet() &#123; System.out.println("HttpServlet.doGet()"); &#125;&#125;class MyServlet extends HttpServlet &#123; //重写doGet()方法，不重写service()方法 public void doGet() &#123; System.out.println("MyServlet.doGet()"); &#125;&#125; 1234HttpServlet.service()调用doGet()时的内存地址classlib.MyServlet@36d64342MyServlet.doGet()对象s的内存地址classlib.MyServlet@36d64342 内存分析图如下：]]></content>
      <categories>
        <category>JaveSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[final关键字]]></title>
    <url>%2F2019%2F04%2F04%2Ffinal%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[final修饰变量:被他修饰的变量不可改变。一旦赋了初值，就不能被重新赋值。且必须被赋初值 12final int MAX_SPEED = 120;final int MAX_SPEED ;//编译出错 final修饰方法：该方法不可被子类重写。但是可以被重载! final修饰类:修饰的类不能被继承。比如：Math、String等。 final关键字面试题final基本类型和引用类型作为参数的情况 基本类型，是值不能被改变 引用类型，是地址值不能被改变，对象内容可以改变]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[super关键字&&继承树]]></title>
    <url>%2F2019%2F04%2F04%2Fsuper%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[this: a. 代表当前对象（哪个对象调用这个方法，它就代表哪个对象） b.代表该对象的一个空间标识（可以调用在本类中定义的成员） super： ​ a: super表示的是该对象内存中的一部分空间，该部分空间存储了从父类中继承的成员，（可以调用在父类中定义的成员） 如图所示，super代表的是里面那个小框，表示的是该对象内存中的一部分空间，该部分空间存储了从父类中继承的成员 静态方法中不能使用super关键字 123456789101112131415161718public class TestDemo&#123; public static void main(String[] args) &#123; Son1 son=new Son1(); son.method(0); &#125;&#125;class Father1&#123; int n=1024;&#125;class Son1 extends Father1&#123; int n=2048; public void method(int n) &#123; System.out.println("n="+n); System.out.println("this.n="+this.n); System.out.println("super.n="+super.n); System.out.println("子类对象:"+this); //System.out.println(super);编译错误 &#125;&#125; 输出结果： 1234n=0//方法中的局部变量this.n=2048//this代表子类，子类中的成员变量super.n=1024//上面代码中父类对象没有创建，只new了一个子类对象，所以super代表该对象的空间标识，里面存的是父类继承的成员子类对象:classlib.Son1@36d64342//相当于this.toString() 总结 super是直接对父类对象的引用。可以通过super来访问父类中被子类覆盖的非static方法或非static属性。 使用super调用普通方法，语句没有位置限制，可以在子类中随便调用。 若是构造方法的第一行代码没有显式的调用super(…)或者this(…);那么Java默认都会调用super(),含义是调用父类的无参数构造方法。这里的super()可以省略。 属性/方法的查找顺序：(比如：查找变量h) 查找当前类中有没有属性h（如果是方法，则从当前对象中开始找） 依次上溯每个父类，查看每个父类中是否有h，直到Object 如果没找到，则出现编译错误。 上面步骤，只要找到h变量，则这个过程终止。 构造方法调用顺序： 构造方法第一句总是：super(…)来调用父类对应的构造方法。所以，流程就是：先向上追溯到Object，然后再依次向下执行类的初始化块和构造方法，直到当前子类为止。 子类中的所有构造方法，默认都会访问父类中的无参构造方法 ​ 为什么呢? 因为子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化。 每一个构造方法的第一条语句默认都是：super() 子类的构造方法对父类构造方法的调用只能一次 如果父类没有无参构造方法。直接编译会报错，有如下两种解决办法 ​ a. 调用父类的有参构造方法 ​ b. 调用本类其它构造方法，其它构造方法必须调用父类的有参构造方法（本质上是要对父类成员进行初始化！） ​ 注：静态初始化块调用顺序，与构造方法调用顺序一样，不再重复。 12345678910111213141516171819202122232425public class TestDemo&#123; public static void main(String[] args) &#123; new Son2(); System.out.println("----------------------"); new Son2(100); &#125;&#125;class Father2&#123; public Father2() &#123; System.out.println("Father2()..."); &#125; public Father2(int n) &#123; System.out.println("Father2(int)..."); &#125;&#125;class Son2 extends Father2&#123; public Son2() &#123; super(100);//可以通过super(...)调用父类有参构造方法，此时系统不会默认提供无参构造方法 System.out.println("Son2()..."); &#125; public Son2(int n) &#123; //super();这是编译器自己加的，默认调用父类无参构造方法 System.out.println("Son2(int)..."); &#125;&#125; 结果： 12345Father2(int)...//调用父类有参构造方法Son2()...----------------------Father2()...//调用父类无参构造方法Son2(int)... 面试题11234567891011121314151617181920212223242526272829303132class Father &#123; static &#123; System.out.println("静态代码块Father"); &#125; &#123; System.out.println("构造代码块Father"); &#125; public Father() &#123; System.out.println("构造方法Father"); &#125;&#125;class Son extends Father &#123; static &#123; System.out.println("静态代码块Son"); &#125; &#123; System.out.println("构造代码块Son"); &#125; public Son() &#123; System.out.println("构造方法Son"); &#125;&#125;public class TestDemo&#123; public static void main(String[] args) &#123; Son son=new Son(); &#125;&#125; 结果： 123456静态代码块Father//1、加载父类的字节码文件(运行静态代码块)静态代码块Son//2、加载子类的字节码文件构造代码块Father//3、执行父类的构造代码块（构造代码块相当于构造方法的最前面）构造方法Father//4、执行父类构造方法构造代码块Son//5、执行子类的构造代码块构造方法Son//6、执行子类的构造方法 继承对象的初始化过程： 1. 加载父类的字节码文件(运行静态代码块) 2. 加载子类的字节码文件 3. 执行父类的构造代码块（构造代码块相当于构造方法的最前面） 4. 执行父类构造方法 5. 执行子类的构造代码块 6. 执行子类的构造方法 面试题212345678910111213141516171819202122class X &#123;//2 加载父类X字节码文件 Y b = new Y();//引用类型的成员变量 //3 堆中开辟空间，默认初始化b=null，显式初始化b=new Y()，堆中有引用类型成员变量b,接下去执行new Y() X() &#123;//6 构造方法初始化 打印X。至此父类X初始化完毕。开始子类Z的初始化 System.out.println("X"); &#125;&#125;class Y &#123;//4 加载Y类字节码文件，在堆中开辟空间，Y中没有成员变量,所以没有变量初始化 //5 X中new Y()构造方法初始化，打印Y，退回3 Y() &#123;//8 Z中new Y(),Y中没有成员变量，构造方法初始化，打印Y System.out.println("Y"); &#125;&#125;public class Z extends X &#123; Y y = new Y();//7 父类初始化完毕，进行Z的出初始化，堆中开辟空间，默认初始化y=null,显示初始化y=new Y(),接下去去执行new Y(); Z() &#123;//9 Z中成员变量初始化后，进行Z中构造方法初试化，打印Z System.out.println("Z"); &#125; public static void main(String[] args) &#123;//1、程序入口 new Z(); //2、new Z(),先加载父类X的字节码文件 &#125;&#125; 1234YXYZ 铺垫的小知识：第一个：成员变量有基本类型和引用类型的。1234class Demo &#123; int x = 10; //基本类型 Student s = new Student(); //引用类型&#125; 第二个：类的初始化过程 加载class文件 堆中开辟空间 变量的默认初始化 变量的显示初始化 构造代码块初始化 构造方法初始化 第三个：遇到extends，就要知道，先初始化父类数据，然后初始化子类数据。 子类构造方法中的第一行super在这里仅仅表示要先初始化父类数据。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象三大特性2——继承]]></title>
    <url>%2F2019%2F04%2F04%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A72%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[继承概述 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。 通过extends关键字可以实现类与类的继承 class 子类名 extends 父类名 {} 单独的这个类称为父类，基类或者超类；这多个类可以称为子类或者派生类。 有了继承以后，我们定义一个类的时候，可以在一个已经存在的类的基础上，还可以定义自己的新成员。 继承的好处 提高了代码的复用性 ​ 多个类相同的成员可以放到同一个类中 提高了代码的维护性 ​ 如果功能的代码需要修改，修改一处即可 让类与类之间产生了关系，是多态的前提 ​ 其实这也是继承的一个弊端：类的耦合性很强 设计原则：高内聚低耦合。 简单的理解： 内聚就是自己完成某件事情的能力。 耦合就是类与类之间的关系。 我们在设计的时候原则是：自己能完成的就不麻烦别人，这样将来别人产生了修改，就对我的影响较小。 由此可见：在开发中使用继承其实是在使用一把双刃剑。今天我们还是以继承的好处来使用，因为继承还有很多其他的特性。 继承的特点 Java中只有单继承，没有像C++那样的多继承。多继承会引起混乱，使得继承链过于复杂，系统难于维护。可以多层继承 Java中类没有多继承，接口有多继承。 子类继承父类，可以得到父类的全部属性和方法 (除了父类的构造方法)，但不见得可以直接访问(比如，父类私有的属性和方法,私有成员其实被隐式继承了)。 ​ 其实这也体现了继承的另一个弊端：打破了封装性 如果定义一个类时，没有调用extends，则它的父类是：java.lang.Object。 子类不能继承父类的构造方法，但是可以通过super关键字去访问父类构造方法。 不要为了部分功能而去继承。解释一下：我们发现两个类有部分代码相同，我们就让这两个类产生一个继承关系，这是不对的。 我们到底在什么时候使用继承呢? ​ 继承中类之间体现的是：”xxx is a xxx”的关系。 ​ 例如：水果和苹果，苹果是一种水果。 ​ 学生和人，学生是人的一种。 继承举例1234567891011121314151617181920212223242526public class Test2&#123; public static void main(String[] args) &#123; Student s = new Student("wjj",180,"cs"); s.rest();//可以直接调用父类的方法 s.study(); &#125;&#125;class Person &#123; String name; int height; public void rest()&#123; System.out.println("休息一会！"); &#125; &#125;class Student extends Person &#123; String major; //专业 public void study()&#123; System.out.println("在努力学习java！"); &#125; public Student(String name,int height,String major) &#123; //天然拥有父类的属性 this.name = name; this.height = height; this.major = major; &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码块]]></title>
    <url>%2F2019%2F04%2F03%2F%E4%BB%A3%E7%A0%81%E5%9D%97%2F</url>
    <content type="text"><![CDATA[局部代码块​ 在局部位置(方法内)，限定变量生命周期，及早释放，提高内存利用率 123456789public class TestDemo &#123; public static void main(String[] args) &#123; &#123; int i=100; System.out.println("i="+i); &#125; i=200;//此处编译错误 &#125;&#125; 构造代码块在成员位置（在类中方法外）出现；多个构造方法方法中相同的代码提取出来，存放到构造代码块里面，每次调用构造方法都执行，换句话说，每次创建对象都执行，并且在构造方法前执行 123456789101112131415161718192021222324public class TestDemo &#123; public static void main(String[] args) &#123; Student stu=new Student(); Student stu2=new Student("wjj",18); &#125;&#125;class Student&#123; String name; int age; public Student() &#123; //System.out.println("我要创建一个学生对象"); System.out.println("无参构造方法"); &#125; public Student(String name,int age) &#123; //System.out.println("我要创建一个学生对象"); System.out.println("有参构造方法"); this.name=name; this.age=age; &#125; &#123; System.out.println("我要创建一个学生对象"); //为为构造代码块,每次调用构造都执行**，并且在构造方法前执行 &#125;&#125; 输出结果： 1234我要创建一个学生对象无参构造方法我要创建一个学生对象有参构造方法 静态代码块 ：在类中方法外出现，加了static修饰构造方法用于对象的初始化!静态初始化块，用于类的初始化操作!在静态初始化块中不能直接访问非static成员。 在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且值执行一次。 注意事项注意事项： 静态初始化块执行顺序： 1. 上溯到Object类，先执行Object的静态初始化块，再向下执行子类的静态初始化块，直到我们的类的静态初始化块为止。 2. 构造方法执行顺序和上面顺序一样!! 1234567891011121314151617181920212223242526272829package TestException;public class TestDemo &#123; public static void main(String[] args) &#123; Student stu=new Student(); Student stu2=new Student("wjj",18); &#125;&#125;class Student&#123; String name; int age; static &#123; System.out.println("这是静态代码块"); &#125; &#123; //构造代码块 System.out.println("我要创建一个学生对象"); //为为构造代码块,每次调用构造都执行**，并且在构造方法前执行 &#125; public Student() &#123; //System.out.println("我要创建一个学生对象"); System.out.println("无参构造方法"); &#125; public Student(String name,int age) &#123; //System.out.println("我要创建一个学生对象"); System.out.println("有参构造方法"); this.name=name; this.age=age; &#125;&#125; 输出结果： 12345这是静态代码块//只执行一次我要创建一个学生对象//每次创建对象都执行无参构造方法我要创建一个学生对象有参构造方法 面试题：静态代码块，构造代码块，构造方法的执行顺序。 静态代码块 &gt; 构造代码块 &gt; 构造方法 同步代码块（多线程）]]></content>
  </entry>
  <entry>
    <title><![CDATA[static关键字]]></title>
    <url>%2F2019%2F04%2F02%2Fstatic%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[核心要点 static修饰的成员变量和方法，从属于类。 普通变量和方法从属于对象的。 在类中，用static声明的成员变量为静态成员变量，也称为类变量。 类变量的生命周期和类相同，在整个应用程序执行期间都有效。它有如下特点： 1. 为该类的公用变量，属于类，被该类的所有实例共享，在类被载入时被显式初始化。（随着类的加载而加载） 2. 优先于对象存在 3. 对于该类的所有对象来说，static成员变量只有一份。被该类的所有对象共享!! 4. 一般用“类名.类属性/方法”来调用。(也可以通过对象引用或类名(不需要实例化)访问静态成员。【强烈推荐使用类名调用！！！】 5. 在static方法中不可直接访问非static的成员。（因为非static成员要对象存在才存在，而static方法优先于对象存在，从属于类） 6. this不能用于static方法中。（因为this的本质就是“创建好的对象的地址”! ） 内存分析12345678910111213141516171819202122232425262728293031public class TestDemo&#123; public static void main(String[] args) &#123; Person p1=new Person("中国","迪丽热巴",20); p1.show(); Person p2=new Person("中国","古力娜扎",21); p2.show(); Person p3=new Person("中国","凤姐",40); p3.show(); System.out.println("----------------------------"); p3.nation="America"; //等价于Person.nation="America"; p1.show(); p2.show(); p3.show(); &#125;&#125;class Person&#123; static String nation; String name; int age; public Person() &#123;//构造方法 &#125; public Person(String nation,String name,int age) &#123; this.name=name; this.nation=nation; this.age=age; &#125; public void show() &#123; System.out.println("nation="+nation+",name="+name+",age="+age); &#125;&#125; 输出结果： 1234567nation=中国,name=迪丽热巴,age=20nation=中国,name=古力娜扎,age=21nation=中国,name=凤姐,age=40----------------------------nation=America,name=迪丽热巴,age=20nation=America,name=古力娜扎,age=21nation=America,name=凤姐,age=40 因为nation为静态属性，为类共享，所以全改了 main方法：public static void main(String[] args){} public :公共的，main方法是被JVM主动调用的，所以访问权限得最大 static:静态的，在被调用之前，根本就没有对象存在，所以应该用static修饰 void:返回给调用者，main方法的调用者是JVM，把值返回给JVM是没有意义的，所以用void main:只是一个约定俗成的名字 String[] args: JDK1.5 以前没有Scanner类，String[] args用于接受键盘录入的数据的,在dos窗口运行HelloWorld.class文件时，需要执行语句 1234567class HelloWorld&#123; public static void main(String[] args)&#123; for(int i=0;i&lt;args.length;i++)&#123; System.out.println(args[i]); &#125; &#125;&#125; 1java HelloWorld hello world hangzhou “hello”,”world”,”hangzhou”为我输入的3个字符串分别为args[0],args[1],args[2]]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象三大特性1—封装]]></title>
    <url>%2F2019%2F04%2F02%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A71%E2%80%94-%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[封装的作用与含义 我要看电视，只需要按一下开关和换台就可以了。有必要了解电视机内部的结构吗?有必要碰碰显像管吗?制造厂家为了方便我们使用电视，把复杂的内部细节全部封装起来，只给我们暴露简单的接口，比如：电源开关。具体内部是怎么实现的，我们不需要操心。 需要让用户知道的才暴露出来，不需要让用户知道的全部隐藏起来，这就是封装。说的专业一点，封装就是把对象的属性和操作结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。 我们程序设计要追求“高内聚，低耦合”。 高内聚就是类的内部数据操作细节自己完成，不允许外部干涉; 低耦合是仅暴露少量的方法给外部使用，尽量方便外部调用。 编程中封装的具体优点： 提高代码的安全性。 提高代码的复用性。 “高内聚”：封装细节，便于修改内部代码，提高可维护性。 “低耦合”：简化外部调用，便于调用者使用，便于扩展和协作。 没有封装的代码会出现一些问题12345678910111213141516class Person &#123; String name; int age; @Override public String toString() &#123; return "Person [name=" + name + ", age=" + age + "]"; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Person p = new Person(); p.name = "小红";//此处也可以加限制，例如游戏起名的时候会判断你的名字是否合法 p.age = -45;//年龄可以通过这种方式随意赋值，没有任何限制 System.out.println(p); &#125;&#125; *再比如说，如果哪天我们需要将Person类中的age属性修改为String类型的，你会怎么办? 例如p.age=1; 改成p.age=&quot;1&quot;; p2.age=2; 改成p2.age=&quot;2&quot;; p3.age=3; 改成p2.age=&quot;3&quot;; 你只有一处使用了这个类的话那还比较幸运，但如果你有几十处甚至上百处都用到了，那你岂不是要改到崩溃。而封装恰恰能解决这样的问题。如果使用封装，我们只需要稍微修改下Person类的setAge()方法即可，而无需修改使用了该类的客户代码。 123public void setAge(Integer age)&#123;//此处为自动装箱 this.age=age.toString();&#125; 封装的使用细节类的属性的处理 一般使用private访问权限。 提供相应的get/set方法来访问相关属性，这些方法通常是public修饰的，以提供对属性的赋值与读取操作(注意：boolean变量的get方法是is开头!)。 一些只用于本类的辅助性方法可以用private修饰，希望其他类调用的方法用public修饰。 封装使用实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Person &#123; private String name; private int age; public Person() &#123;//无参构造函数 &#125; public Person(String name, int age) &#123; this.name = name; //this.age = age;//构造方法中直接赋值，就不会判断年龄是否正确 setAge(age);// 应该调用setAge方法 &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; //在赋值之前先判断年龄是否合法 if (age &gt; 130 || age &lt; 0) &#123; System.out.println("Are you kidding?");//不合法 &#125; else &#123; this.age = age;//合法才能赋值给属性age &#125; &#125; public int getAge() &#123; return age; &#125; @Override public String toString() &#123; return "Person [name=" + name + ", age=" + age + "]"; &#125;&#125; public class Test2 &#123; public static void main(String[] args) &#123; Person p1 = new Person(); //p1.name = "小红"; //编译错误 //p1.age = -45; //编译错误 p1.setName("小红"); p1.setAge(-45); System.out.println(p1); Person p2 = new Person("小白", 300); System.out.println(p2); &#125;&#125; 1234Are you kidding?Person [name=小红, age=0]Are you kidding?Person [name=小白, age=0]//输出结果]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造方法]]></title>
    <url>%2F2019%2F04%2F02%2F%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[构造器也叫构造方法(constructor)，用于对象的初始化。构造器是一个创建对象时被自动调用的特殊方法，目的是对象的初始化。构造器的名称应与类的名称一致。Java通过new关键字来调用构造器，从而返回该类的实例，是一种特殊的方法。 申明格式123[修饰符] 类名(形参列表)&#123; ``//n条语句&#125; 方法名与类名相同 没有返回值类型，连void都没有 没有具体的返回值 例如： 1234567891011121314151617class Point &#123; double x, y; public Point(double x, double y) &#123; this.x = x; this.y = y; &#125; public double getDistance(Point p) &#123; return Math.sqrt((x - p.x) * (x - p.x) + (y - p.y) * (y - p.y)); &#125;&#125;public class TestConstructor &#123; public static void main(String[] args) &#123; Point p = new Point(3.0, 4.0); Point origin = new Point(0.0, 0.0); System.out.println(p.getDistance(origin)); &#125;&#125; 5.0//程序结果 构造方法的重载构造方法也是方法，只不过有特殊的作用而已。与普通方法一样，构造方法也可以重载。 【特别注意】 如果方法构造中形参名与属性名相同时，需要使用this关键字区分属性与形参。如下示例所示：this.id 表示属性id;id表示形参id 如果你不提供构造方法，系统会给出默认构造方法 如果你提供了构造方法，系统将不再提供【强烈推荐永远自己写一个无参构造方法】 构造方法不能递归使用（显然会一直调用自己，栈溢出） 123456789101112131415161718192021222324package classlib;public class User &#123; int id; // id String name; // 账户名 String pwd; // 密码 public User() &#123; &#125; public User(int id, String name) &#123; super(); this.id = id; this.name = name; &#125; public User(int id, String name, String pwd) &#123; this.id = id; this.name = name; this.pwd = pwd; &#125; public static void main(String[] args) &#123; User u1 = new User(); User u2 = new User(101, "WJJ"); User u3 = new User(100, "AL", "123456"); &#125;&#125; 标准案例 讲成员变量私有化 提供一个无参和所有参数的构造方法 提供setXxx和getXxx 成员方法 # 构造方法私有化 对于一个工具类，可以将无参构造方法初始化，这样这能通过类名调用其静态方法，不能为该类实例化对象 例如 123456789class MyMath&#123; private MyMath()&#123;//The constructor MyMath() is not visible //讲无参构造函数私有化 &#125; public static int add(int a,int b)&#123; return a+b; &#125; //还可以有其它计算&#125; 则此时MyMath类不能实例化，只能用类名调用静态方法]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this关键字]]></title>
    <url>%2F2019%2F04%2F02%2Fthis%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[对象创建过程与this的本质构造方法是创建Java对象的重要途径，通过new关键字调用构造器时，构造器也确实返回该类的对象，但这个对象并不是完全由构造器负责创建。创建一个对象分为如下四步： 分配对象空间，并将对象成员变量初始化为0或空 执行属性值的显示初始化 执行构造方法 返回对象的地址给相关的变量 this的本质就是“创建好的对象的地址”! 由于在构造方法调用前，对象已经创建。因此，在构造方法中也可以使用this代表“当前对象” 。 this最常用的用法： 在程序中产生二义性之处，应使用this来指明当前对象;普通方法中，this总是指向调用该方法的对象。构造方法中，this总是指向正要初始化的对象。 使用this关键字调用重载的构造方法，避免相同的初始化代码。但只能在构造方法中用，并且必须位于构造方法的第一句。 this不能用于static方法中。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象的内存分析]]></title>
    <url>%2F2019%2F04%2F02%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一个类的初始化过程Student s = new Student();在内存中做了哪些事情? 加载Student.class文件进内存【方法区】,并且创建对应的字节码文件 在栈内存为s开辟空间 在堆内存为学生对象开辟空间 对学生对象的成员变量进行默认初始化//0,null, 对学生对象的成员变量进行显示初始化显示初始化的意思是，类定义的时候给成员变量赋了初值例如： 12345class Person &#123; private String name="WJJ";//显示初始化 private int age=18;//显示初始化 //构造函数即getXxx(),setXxxx()&#125; 通过构造方法对学生对象的成员变量赋值 学生对象初始化完毕，把对象地址赋值给s变量 Java虚拟机的内存可以分为三个区域：栈stack、堆heap、方法区method area。* 栈的特点如下： 栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧(存储局部变量、操作数、方法出口等) JVM为每个线程创建一个栈，用于存放该线程执行方法的信息(实际参数、局部变量等) 栈属于线程私有，不能实现线程间的共享! 栈的存储特性是“先进后出，后进先出” 栈是由系统自动分配，速度快!栈是一个连续的内存空间! 总结关于栈和栈帧，我们做个小结： 每个JVM线程有一个私有栈，栈在线程创建的同时被创建。 栈由许多帧组成，也叫 “栈帧” 每次方法调用都会创建一个栈帧 换句话说，当一个Java/Scala/JVM方法被执行时： 当方法被执行时，一个新的栈帧被创建并用来给这个方法存储数据 栈帧大小各不相同，取决于方法的参数、局部变量和算法 当一个方法被执行时，程序只能访问当前栈帧中的数据，你能看到的只有栈顶的帧 Java/JVM中栈的官方定义Oracle关于栈和栈帧提供了如下描述： 每个JVM线程拥有一个私有的 Java虚拟机栈，创建线程的同时栈也被创建。一个JVM栈由许多帧组成，称之为”栈帧”。JVM中的栈和C等常见语言中的栈比较类似，都用于保存局部变量和部分计算结果，同时也参与方法调用和返回。 因此，你可以想象一下，一个栈拥有许多栈帧，如下图： 如Oracle官方说明，每个线程拥有自己的私有栈，因此在多线程应用中将有多个栈，每个栈有自己的栈帧。 Java中的栈 当一个新的线程创建时，JVM会为这个线程创建一个新的Stack。一个Java Stack在一个个独立的栈帧中存储了线程的状态。JVM只会在Java Stack中做两个操作：push 和 pop. 一个线程当前正在执行的方法称之为线程的 当前方法，当前方法对应的栈帧称为 当前帧，当前方法所属的类称为 当前类，当前类的常量池称为 当前常量池。 在执行一个方法时，JVM会保存当前类和当前常量池的轨迹。当JVM执行 需要操作栈帧中数据的指令时，JVM会在当前栈帧进行处理。 当一个线程执行一个Java方法时，JVM将创建一个新的栈帧并且把它push到栈顶。此时新的栈帧就变成了当前栈帧，方法执行时，使用栈帧来存储参数、局部变量、中间指令以及其他数据。 Java中的栈帧 栈帧由三部分组成：局部变量表、操作数栈以及帧数据。 每个方法涉及的局部变量表和操作数栈的大小取决于每个具体的方法，但是大小在编译后便已确定，而且已经包含在class文件中。 重要的是：栈帧的大小因局部变量表和操作数栈而异。书中对于size的描述如下： 当JVM执行一个方法时，它会检查class中的数据，以便确定一个方法执行时在局部变量表和操作数栈中所需存储的word size。然后，JVM会为当前方法创建一个size相对应的栈帧，然后把它push到栈顶。 Word size、操作数栈和常量池简述下 word size、operand stack(操作数栈)、constant pool(常量池)这三个短语的定义： word size：它是一个度量单位，在不同类型的JVM中，word size的大小不一定会相同。但是，它至少会有32位以保证可以存储long或double类型。 operand stack：操作数栈在 oracle.com 中被定义。捎带提一嘴，其中的定义涉及到了机器代码，例如：它展示了使用iadd指令进行两个integer的加法操作。 欢迎你深入学习这些细节，但是我们这里只想让你简单知道：操作数栈只是栈帧中的一块内存区域。 常量池：Java运行时常量时在 oracle.com 中定义. 写道：一个运行时常量池 … 包含了许多种常量，编译时的常见数值字面量、运行时需要处理的方法和字段引用等. 运行时常量池和一些编程语言中的符号表有点类似，只不过它比符号表存储的数据范围更广。 堆的特点如下： 堆用于存储创建好的对象和数组(数组也是对象) JVM只有一个堆，被所有线程共享 堆是一个不连续的内存空间，分配灵活，速度慢! 方法区(又叫静态区)特点如下： JVM只有一个方法区，被所有线程共享! 方法区实际也是堆，只是用于存储类、常量相关的信息! 来存放程序中永远是不变或唯一的内容。(类信息【Class对象】、静态变量、字符串常量、静态、非静态方法等) 内存图解1234567891011121314151617181920212223class Computer&#123; String brand;//品牌&#125;public class Stu&#123; int id; String name; int age; Computer comp; void study() &#123; System.out.println("我正在学习！使用电脑:"+comp.brand); &#125; //构造方法 Stu()&#123; &#125; public static void main(String[] args) &#123; Stu stu1=new Stu(); stu1.name="张三"; Computer comp1=new Computer(); comp1.brand="联想"; stu1.comp=comp1; stu1.study(); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类与对象]]></title>
    <url>%2F2019%2F04%2F02%2F%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[类与对象 类可以看做是一个模版，或者图纸，系统根据类的定义来造出对象。我们要造一个汽车，怎么样造?类就是这个图纸，规定了汽车的详细信息，然后根据图纸将汽车造出来。造出来的具体汽车就是对象 类：我们叫做class。 对象：我们叫做Object,instance(实例)。我们说某个类的对象，某个类的实例。是一样的意思。 定义一个类（模板） 1234567891011121314class Student&#123; //属性（成员变量） int id; String name; int age; //方法 public void study() &#123; System.out.println("我爱学习！"); &#125; //构造方法 public Student()&#123; &#125;&#125; 总结 ​ 1.对象是具体的事物;类是对对象的抽象; ​ 2.类可以看成一类对象的模板（蓝图），对象可以看成该类的一个具体实例。 ​ 3.类是用于描述同一类型的对象的一个抽象概念，类中定义了这一类对象所应具有的共同的属性、方法。 ​ 4.面向对象程序设计的重点是类的设计，而不是对象的设计。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象与面向过程]]></title>
    <url>%2F2019%2F04%2F01%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[我们千万不要把面向过程和面向对象对立起来。他们是相辅相成的。面向对象离不开面向过程! 总结 都是解决问题的思维方式，都是代码组织的方式。 解决简单问题可以使用面向过程 解决复杂问题：宏观上使用面向对象把握，微观处理上仍然是面向过程。 面向对象思考方式 遇到复杂问题，先从问题中找名词，然后确立这些名词哪些可以作为类，再根据问题需求确定的类的属性和方法，确定类之间的关系。 建议 面向对象具有三大特征：封装性、继承性和多态性，而面向过程没有继承性和多态性，并且面向过程的封装只是封装功能，而面向对象可以封装数据和功能。所以面向对象优势更明显。 对象说白了也是一种数据结构(对数据的管理模式)，将数据和数据的行为放到了一起。即将相关数据和相关方法封装到一个独立的实体 在内存上，对象就是一个内存块，存放了相关的数据集合! 对象的本质就一种数据的组织方式! 面向过程程序设计：程序=算法+数据结构（动词的集合，关注操作） 面向对象程序设计：程序=对象+消息（名次的集合） 面向过程(Procedure Oriented)面向过程思想思考问题时，我们首先思考“怎么按步骤实现?”并将步骤对应成方法，一步一步，最终完成。 这个适合简单任务，不需要过多协作的情况下。比如，如何开车?我们很容易就列出实现步骤： 发动车 2. 挂挡 3.踩油门 4. 走你 例如把大象放进冰箱,Java语言描述 12345678910111213141516public class Test &#123; public static void main(String[] args) &#123; step1(); step2(); step3(); &#125; public static void step1() &#123; System.out.println("开冰箱门"); &#125; public static void step2() &#123; System.out.println("把大象放进冰箱"); &#125; public static void step3() &#123; System.out.println("关上冰箱门"); &#125;&#125; 面向对象(Object Oriented,OO)面向过程适合简单、不需要协作的事务。 但是当我们思考比较复杂的问题，比如“如何造车?”，就会发现列出1234这样的步骤，是不可能的。那是因为，造车太复杂，需要很多协作才能完成。此时面向对象思想就应运而生了。 面向对象(Object Oriented)思想更契合人的思维模式。我们首先思考的是“怎么设计这个事物?” 比如思考造车，我们就会先思考“怎么设计车?”，而不是“怎么按步骤造车的问题”。这就是思维方式的转变。 一、面向对象思想思考造车，发现车由如下对象组成： 轮胎 发动机 车壳 座椅 挡风玻璃 为了便于协作，我们找轮胎厂完成制造轮胎的步骤，发动机厂完成制造发动机的步骤;这样，发现大家可以同时进行车的制造，最终进行组装，大大提高了效率。但是，具体到轮胎厂的一个流水线操作，仍然是有步骤的，还是离不开面向过程思想! 因此，面向对象可以帮助我们从宏观上把握、从整体上分析整个系统。 但是，具体到实现部分的微观操作(就是一个个方法)，仍然需要面向过程的思路去处理。 例如把大象放进冰箱，Java语言描述 1234567891011121314151617181920public class Test &#123; public static void main(String[] args) &#123; Fridge.open(); Elephant.in(); Fridge.close(); &#125;&#125;class Elephant&#123; public static void in() &#123;//此处用静态方法方便调用 System.out.println("放进冰箱"); &#125;&#125;class Fridge&#123; public static void open() &#123; System.out.println("打开冰箱门"); &#125; public static void close() &#123; System.out.println("关上冰箱门"); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组]]></title>
    <url>%2F2019%2F03%2F29%2F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组数组变量属引用类型，实例化的数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，数组对象本身是在堆中存储的。 数组概念 数组是存储同一种数据类型多个元素的集合。也可以看成是一个容器。 数组既可以存储基本数据类型，也可以存储引用数据类型。（对象的地址）（对象数组） 长度是确定的。数组一旦被创建，它的大小就是不可以改变的。 数组定义格式12type[] arr_name; //（推荐使用这种方式）type arr_name[]; 注意事项 ​ 1. 声明的时候并没有实例化任何对象，只有在实例化数组对象时，JVM才分配空间，这时才与长度有关。 ​ 2. 声明一个数组的时候并没有数组真正被创建。 ​ 3. 构造一个数组，必须指定长度。 数组初始化 Java中的数组必须先初始化,然后才能使用。 所谓初始化：就是为数组中的数组元素分配内存空间，并为每个数组元素赋初值。 数组的初始化方式 动态初始化：初始化时程序猿只指定数组长度，由系统为数组分配默认初始值。 123int[] a1 = new int[2];//动态初始化数组，先分配空间；a1[0]=1;//给数组元素赋值；a1[1]=2;//给数组元素赋值； 静态初始化：初始化时指定每个数组元素的初始值，由系统决定数组长度。 123int[] a=new int[]&#123;1,2,3&#125;;//完整格式,可以简化为下int[] a = &#123; 1, 2, 3 &#125;;// 静态初始化基本类型数组；注意这种方式不能先声明，再简洁初始化。Man[] mans = &#123; new Man(1, 1), new Man(2, 2) &#125;;// 静态初始化引用类型数组； 默认初始化：数组是引用类型，它的元素相当于类的实例变量（实例化的数组可以看成一个对象，数组中的每个元素相当于该对象的成员变量），因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。 123int a2[] = new int[2]; // 默认值：0,0boolean[] b = new boolean[2]; // 默认值：false,falseString[] s = new String[2]; // 默认值：null, null byte,short,int,long ：0 float,double：0.0 char：‘\u0000’ boolean：false 引用类型：null 0x0000(4字节) 但是一定要注意不能同时进行动态初始化和静态初始化。就是不能在给定数组长度的同时给出元素。 例如 1int data[]=new int[3]&#123;1,2,3&#125;;///编译错误！ 数组的内存分配12345678public class TestDemo&#123; public static void main(String[] args) &#123; int data[]=new int[3];//声明数组并分配空间 data[0]=10; data[1]=20; data[2]=30; &#125;&#125; 二维数组java中二维数组内存不是连续的，相当于一个链表，(和C语言不一样)【不建议使用】 二维数组的声明12345678910public class Test &#123; public static void main(String[] args) &#123; // Java中多维数组的声明和初始化应按从低维到高维的顺序进行 int[][] a = new int[3][]; a[0] = new int[2]; a[1] = new int[4]; a[2] = new int[3]; // int a1[][]=new int[][4];//非法 &#125;&#125; 二维数组的动态初始化1234567891011121314import java.util.Arrays;public class Test &#123; public static void main(String[] args) &#123; int[][] a = new int[3][]; // a[0] = &#123;1,2,5&#125;; //错误，没有声明类型就初始化 a[0] = new int[] &#123; 1, 2 &#125;; a[1] = new int[] &#123; 2, 2 &#125;; a[2] = new int[] &#123; 2, 2, 3, 4 &#125;; System.out.println(a[2][3]); System.out.println(Arrays.toString(a[0])); System.out.println(Arrays.toString(a[1])); System.out.println(Arrays.toString(a[2])); &#125;&#125; 二维数组的静态初始化12345678public class Test &#123; public static void main(String[] args) &#123; int[][] a = &#123; &#123; 1, 2, 3 &#125;, &#123; 3, 4 &#125;, &#123; 3, 5, 6, 7 &#125; &#125;; System.out.println(a[2][3]); &#125;&#125; 二维数组的内存分配 对象数组123456789101112131415161718192021222324class Book&#123; private String title; private double price; public Book(String t,double p) &#123; title=t; price=p; &#125; public String toString() &#123; return "titile= "+this.title+",price= "+this.price; &#125;&#125;public class Test01&#123; public static void main(String[] args) &#123; Book books[]=new Book[] &#123; new Book("Java",79.8), new Book("JSP",69.8), new Book("Android",89.8) &#125;; for(Book temp:books) &#123; System.out.println(temp); &#125; &#125;&#125; 1234程序执行结果：titile= Java,price= 79.8titile= JSP,price= 69.8titile= Android,price= 89.8]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位运算符面试问题]]></title>
    <url>%2F2019%2F03%2F28%2F%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[位运算符面试问题请用最有效率的方式写出计算2乘以8的结果答：2&lt;&lt;3 请自己实现两个整数变量的交换 法一 123int temp=a;a=b;b=temp; 法二 123a=a+b;b=a-b;a=a-b; 法三 123a=a^b;b=a^b;//b=a^b^b=a 主要利用性质 x^x=0a=a^b;//a=a^b^a=b x^0=x 法四 1a=(a+b)-(b=a);//不推荐 判断一个数是否是2的n次幂分析：2^n：素数因子只有2 法一:使用循环，若为偶数，一直除以2，最后为1，则为2^n，时间复杂度logn 法二：位运算2^n的数有一特点，转为2进制形式为：只有一个1，其余全为0，因此只需要判断二进制形式是否只有1个1 ​ a: 0000 1000 ​ a-1: 0000 0111 若a不为2^n次，则至少有2个1，例如 ​ b: 0000 1100 ​ b-1: 0000 1011 显然若a是2^n的数，则a&amp;(a-1)=0 123456class TestDemo&#123; public static void main(String[] args)&#123; int a=1024; System.out.println((a&amp;(a-1))==0); &#125;&#125; 一堆整数中都是成双存在，只有一个数是单独存在，请找出这个数？分析：因为一个整数x^x=0 ​ x^0=x 所以，相同的部分^运算后全变成了0，最后一个单独存在的^0得到本身 答：例如有数a,b,c,d,e 用a^b得到a1 a1^c得到a2 以此往复，得到的最后一个数，就是单独的数]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java变量的分类与自动类型转换]]></title>
    <url>%2F2019%2F03%2F26%2FJava%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Java变量的分类与自动类型转换变量的分类 类型 从属于 内存位置 声明位置 生命周期 局部变量 方法/语句块 栈内存（方法被调用时都会创建一个栈帧，存储局部变量等)）（没有默认初始化） 方法或者语句块内 从声明位置开始，直到方法或语句块执行完毕，局部变量消失 成员变量（实例变量） 对象 堆内存（有默认初始化） 类内部，方法外部 对象创建，成员变量也跟着创建。对象消失，成员变量也跟着消失； 静态变量（类变量） 类 方法区中的静态区（有默认初始化） 类内部，方法外部。static修饰。 类被加载，静态变量就有效；类被卸载，静态变量就消失 局部变量（local variable）方法或语句块内部定义的变量。生命周期是从声明位置开始到到方法或语句块执行完毕为止。局部变量在使用前必须先声明、初始化(赋初值)再使用。 成员变量（也叫实例变量 member variable）方法外部、类的内部定义的变量。从属于对象，生命周期伴随对象始终。如果不自行初始化，它会自动初始化成该类型的默认初始值。 数据类型 默认初始值 int 0 double 0.0 char ‘\u0000’ boolean false 静态变量（类变量 static variable） 使用static定义。 从属于类，生命周期伴随类始终，从类加载到卸载。 如果不自行初始化，与成员变量相同会自动初始化成该类型的默认初始值，如上表所示。 123456789101112public class TestVariable&#123; int a;//成员变量，从属于对象；成员变量会自动被初始化 static int size; //静态变量，从属于类 public static void main(String[] args) &#123; &#123; int age=18;//局部变量，从属于语句块 &#125; int salary=3000;//局部变量，从属于方法 int i;//局部变量，必须初始化 int j=i+5;//编译出错，变量i还未被初始化 &#125;&#125; 自动类型转换 数据范围小的数据与数据范围大的数据进行数学计算时，自动向大范围的数据类型转换后计算。（例如int和long计算，则int类型先自动变为long类型，再计算） 常量也有类型，常整数为int，常浮点数为double 12long a = 55555555; //编译成功，在int表示的范围内(2.1e9内)。long b = 55555555555;//不加L编译可通过，但是结果不正确，已经超过int表示的范围，数据溢出。 我们修改成long类型的常量即可 1long b = 55555555555L; 1234567public class Test02 &#123; public static void main(String[] args) &#123; int microPerDay=24*60*60*1000; long nanosPerDay=24*60*60*1000*1000*1000L; System.out.print(nanosPerDay/microPerDay); &#125;&#125; 输出： 15794//显然溢出了 这是因为24*60*60*1000*1000数据已经溢出，需要修改如下 1long nanosPerDay=24L*60*60*1000*1000*1000; 此时第一个数就变成long类型，计算正确 11000000//结果正确 12float f=(float)1.24;float f=1.24f; 问：这两种赋值方式一样么？ 答：不一样。 第一种方式，底层存储double类型，占8字节，再强制类型转换成float 第二种方式，底层 存储float类型，占4字节（推荐使用） 注意事项 byte,short,char参与运算的时候默认会转换成int类型，即使是统一数据类型相加也会转成int型 1234567public static void main(String[] args) &#123; byte b=10; byte c=10;//编译器会自动判断是否处于byte范围内。若属于，则编译通过 short a=10;//同理 byte d=b+c;//此处报错，Type mismatch: cannot convert from int to byte，b+c时候，自动转换成int类型 short s=b;//此处没问题&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java命名规范]]></title>
    <url>%2F2019%2F03%2F26%2FJava%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[Java命名规范只是建议 类和接口名称：每一个单词首字母大写，例如：TestDemo; 变量/方法名称：第一个单词首字母小写，之后每个单词的首字母大写，例如：studentName;printInfo();【驼峰原则】 常量名称：每个字母大写,若有多个单词，以_分割，例如：FLAG，MAX_VALUE; 包名称：所有字母小写 ​ 多级包： 域名反转，例如：www.zju.edu.cn –&gt; cn.edu.zju]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Typora快速编辑Markdown]]></title>
    <url>%2F2019%2F03%2F23%2F%E4%BD%BF%E7%94%A8Typora%E5%BF%AB%E9%80%9F%E7%BC%96%E8%BE%91Markdown%2F</url>
    <content type="text"><![CDATA[标题标题是用“#”实现的，标题前面加一个“#”，代表一级标题；依次类推，标题前面加六个“#”代表六级标题；一共有六级标题，编辑各种文档完全够用。 #+空格+标题内容 下划线快捷键Ctrl+u，即可实现下划线功能。 强调内容的前后分别加两个*号 斜体内容前后分别加一个\号* 斜体加粗*前后加3个** 删除线先转化成英文输入法，再把内容前后分别加上两个~号 特别注意是2个~ 列表有序列表输入数字“1”+“.”+”空格”，自动开始有序列表。 步骤1 步骤2 步骤3 无序列表输入“+”或者“-”或者“*”+空格，自动开始无序列表 步骤1 步骤2 步骤3 tableCtrl+T,在弹出的对话框中选择行列数，自动生成列表。还可以很方便地对表格进行编辑。 学号 姓名 成绩 xxx xxx xxx asd 分割线有时候，为了排版漂亮，可能会加入分隔线。Markdown加入分隔线非常简单，使用下面任意一种形式都可以 12***--- 插入图片插入本地图片设置主题_config.ymlpost_asset_folder: true当资源文件管理功能打开后，Hexo将会在你每一次通过hexo new post &lt;title&gt;命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个markdown文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹之中，你可以通过相对路径来引用它们，这样你就得到了一个简单而且方便很多的工作流。123&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; 例如本例中，将ZJU.jpg放到资源文件夹中。通过 1&#123;% asset_img ZJU.jpg 测试%&#125; 命令插入，其中[title]可省略 插入代码`System.out.println(“Hello World!”);`System.out.println(&quot;Hello World!&quot;);```System.out.println(“Hello Hexo”);System.out.println(“Hello World!”);``` 12System.out.println("Hello Hexo");System.out.println("Hello World!"); 行内代码引用，使用单个反引号进行包裹（Tab上面那个），代码块用三个反引号包裹。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Markdown 编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo写博客攻略]]></title>
    <url>%2F2019%2F03%2F22%2F%E4%BD%BF%E7%94%A8hexo%E5%86%99%E5%8D%9A%E5%AE%A2%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[新建文章在站点的根目录下执行以下命令：(本博客站点根目录为D:\blog\WJJ711)$ hexo new post &lt;title&gt;//此处title不需要加双引号例如$ hexo new post 使用hexo写攻略可以简写为$ hexo n &lt;title&gt;例如$ hexo n 使用hexo写攻略 给文章添加分类，标签 1 使用Subline Text 打开《使用hexo写博客攻略》 2 设置如下：12345678---title: 使用hexo写博客攻略date: 2019-03-22 19:34:50tags: - hexo - Markdown 编辑器categories: hexo--- 注意 - 后面的空格！ 3 博客正文需要在---下面撰写 一级标题使用一个#+空格+内容 二级标题使用2个#+空格+内容 三级标题使用3个#+空格+内容 设置列表Markdown支持有序列表和无序列表两种形式：无序列表用*或+或-标识有序列表用数字加.标识，例如1. 列表1 列表2 a 子列表1 b 子列表2 列表312345- 列表1- 列表2 a 子列表1 b 子列表2- 列表3 注意- 后面的空格 添加网站链接B站导航[B站导航](https://www.bilibili.com/)注意：https://不能少 插入图片插入本地图片设置主题_config.ymlpost_asset_folder: true当资源文件管理功能打开后，Hexo将会在你每一次通过hexo new post &lt;title&gt;命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个markdown文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹之中，你可以通过相对路径来引用它们，这样你就得到了一个简单而且方便很多的工作流。 123&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; 例如本例中，将ZJU.jpg放到资源文件夹中。通过1&#123;% asset_img ZJU.jpg 测试%&#125; 命令插入，其中[title]可省略注意，此处必须用```加换行的方式插入上面代码 制表语法如下：123表头|条目一|条目二:---:|:---:|:---:项目|项目一|项目二 以上标记效果显示如下： 表头 条目一 条目二 项目 项目一 项目二 语法说明 |、-、:之间多余的空格会被忽略，不影响布局。 三个短斜杠左右的冒号用于控制对齐方式，只放置左边冒号表示文字居左，只放置右边冒号表示文字居右，如果两边都放置冒号表示文字居中。 表格的语句上一行必须为空行，不然表格不生效 强调有时候，我们希望对某一部分文字进行强调，使用*或_包裹即可。使用单一符号标记的效果是斜体，使用两个符号标记的效果是加粗12345*这里是斜体*_这里是斜体_**这里是加粗**__这里是加粗__ 这里是斜体这里是斜体 这里是加粗这里是加粗 分割线有时候，为了排版漂亮，可能会加入分隔线。Markdown加入分隔线非常简单，使用下面任意一种形式都可以 12***--- 插入代码`System.out.println(“Hello World!”);`System.out.println(&quot;Hello World!&quot;);```System.out.println(“Hello Hexo”);System.out.println(“Hello World!”);```12System.out.println(&quot;Hello Hexo&quot;);System.out.println(&quot;Hello World!&quot;); 行内代码引用，使用单个反引号进行包裹（Tab上面那个），代码块用三个反引号包裹。 使用反斜杠\插入语法中用到的特殊符号在Markdown中，主要有以下几种特殊符号需要处理：123456789101112\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 例如要输出```需要1\`\`\`]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Markdown 编辑器</tag>
      </tags>
  </entry>
</search>
