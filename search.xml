<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[static关键字]]></title>
    <url>%2F2019%2F04%2F02%2Fstatic%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[核心要点 static修饰的成员变量和方法，从属于类。 普通变量和方法从属于对象的。 在类中，用static声明的成员变量为静态成员变量，也称为类变量。 类变量的生命周期和类相同，在整个应用程序执行期间都有效。它有如下特点： 1. 为该类的公用变量，属于类，被该类的所有实例共享，在类被载入时被显式初始化。（随着类的加载而加载） 2. 优先于对象存在 3. 对于该类的所有对象来说，static成员变量只有一份。被该类的所有对象共享!! 4. 一般用“类名.类属性/方法”来调用。(也可以通过对象引用或类名(不需要实例化)访问静态成员。【强烈推荐使用类名调用！！！】 5. 在static方法中不可直接访问非static的成员。（因为非static成员要对象存在才存在，而static方法优先于对象存在，从属于类） 6. this不能用于static方法中。（因为this的本质就是“创建好的对象的地址”! ） 内存分析12345678910111213141516171819202122232425262728293031public class TestDemo&#123; public static void main(String[] args) &#123; Person p1=new Person("中国","迪丽热巴",20); p1.show(); Person p2=new Person("中国","古力娜扎",21); p2.show(); Person p3=new Person("中国","凤姐",40); p3.show(); System.out.println("----------------------------"); p3.nation="America"; //等价于Person.nation="America"; p1.show(); p2.show(); p3.show(); &#125;&#125;class Person&#123; static String nation; String name; int age; public Person() &#123;//构造方法 &#125; public Person(String nation,String name,int age) &#123; this.name=name; this.nation=nation; this.age=age; &#125; public void show() &#123; System.out.println("nation="+nation+",name="+name+",age="+age); &#125;&#125; 输出结果： 1234567nation=中国,name=迪丽热巴,age=20nation=中国,name=古力娜扎,age=21nation=中国,name=凤姐,age=40----------------------------nation=America,name=迪丽热巴,age=20nation=America,name=古力娜扎,age=21nation=America,name=凤姐,age=40 因为nation为静态属性，为类共享，所以全改了 main方法：public static void main(String[] args){} public :公共的，main方法是被JVM主动调用的，所以访问权限得最大 static:静态的，在被调用之前，根本就没有对象存在，所以应该用static修饰 void:返回给调用者，main方法的调用者是JVM，把值返回给JVM是没有意义的，所以用void main:只是一个约定俗成的名字 String[] args: JDK1.5 以前没有Scanner类，String[] args用于接受键盘录入的数据的,在dos窗口运行HelloWorld.class文件时，需要执行语句 1234567class HelloWorld&#123; public static void main(String[] args)&#123; for(int i=0;i&lt;args.length;i++)&#123; System.out.println(args[i]); &#125; &#125;&#125; 1java HelloWorld hello world hangzhou “hello”,”world”,”hangzhou”为我输入的3个字符串分别为args[0],args[1],args[2]]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象三大特性1—封装]]></title>
    <url>%2F2019%2F04%2F02%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A71%E2%80%94-%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[封装的作用与含义 我要看电视，只需要按一下开关和换台就可以了。有必要了解电视机内部的结构吗?有必要碰碰显像管吗?制造厂家为了方便我们使用电视，把复杂的内部细节全部封装起来，只给我们暴露简单的接口，比如：电源开关。具体内部是怎么实现的，我们不需要操心。 需要让用户知道的才暴露出来，不需要让用户知道的全部隐藏起来，这就是封装。说的专业一点，封装就是把对象的属性和操作结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。 我们程序设计要追求“高内聚，低耦合”。 高内聚就是类的内部数据操作细节自己完成，不允许外部干涉; 低耦合是仅暴露少量的方法给外部使用，尽量方便外部调用。 编程中封装的具体优点： 提高代码的安全性。 提高代码的复用性。 “高内聚”：封装细节，便于修改内部代码，提高可维护性。 “低耦合”：简化外部调用，便于调用者使用，便于扩展和协作。 没有封装的代码会出现一些问题12345678910111213141516class Person &#123; String name; int age; @Override public String toString() &#123; return "Person [name=" + name + ", age=" + age + "]"; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Person p = new Person(); p.name = "小红";//此处也可以加限制，例如游戏起名的时候会判断你的名字是否合法 p.age = -45;//年龄可以通过这种方式随意赋值，没有任何限制 System.out.println(p); &#125;&#125; *再比如说，如果哪天我们需要将Person类中的age属性修改为String类型的，你会怎么办? 例如p.age=1; 改成p.age=&quot;1&quot;; p2.age=2; 改成p2.age=&quot;2&quot;; p3.age=3; 改成p2.age=&quot;3&quot;; 你只有一处使用了这个类的话那还比较幸运，但如果你有几十处甚至上百处都用到了，那你岂不是要改到崩溃。而封装恰恰能解决这样的问题。如果使用封装，我们只需要稍微修改下Person类的setAge()方法即可，而无需修改使用了该类的客户代码。 123public void setAge(Integer age)&#123;//此处为自动装箱 this.age=age.toString();&#125; 封装的使用细节类的属性的处理 一般使用private访问权限。 提供相应的get/set方法来访问相关属性，这些方法通常是public修饰的，以提供对属性的赋值与读取操作(注意：boolean变量的get方法是is开头!)。 一些只用于本类的辅助性方法可以用private修饰，希望其他类调用的方法用public修饰。 封装使用实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Person &#123; private String name; private int age; public Person() &#123;//无参构造函数 &#125; public Person(String name, int age) &#123; this.name = name; //this.age = age;//构造方法中直接赋值，就不会判断年龄是否正确 setAge(age);// 应该调用setAge方法 &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; //在赋值之前先判断年龄是否合法 if (age &gt; 130 || age &lt; 0) &#123; System.out.println("Are you kidding?");//不合法 &#125; else &#123; this.age = age;//合法才能赋值给属性age &#125; &#125; public int getAge() &#123; return age; &#125; @Override public String toString() &#123; return "Person [name=" + name + ", age=" + age + "]"; &#125;&#125; public class Test2 &#123; public static void main(String[] args) &#123; Person p1 = new Person(); //p1.name = "小红"; //编译错误 //p1.age = -45; //编译错误 p1.setName("小红"); p1.setAge(-45); System.out.println(p1); Person p2 = new Person("小白", 300); System.out.println(p2); &#125;&#125; 1234Are you kidding?Person [name=小红, age=0]Are you kidding?Person [name=小白, age=0]//输出结果]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造方法]]></title>
    <url>%2F2019%2F04%2F02%2F%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[构造器也叫构造方法(constructor)，用于对象的初始化。构造器是一个创建对象时被自动调用的特殊方法，目的是对象的初始化。构造器的名称应与类的名称一致。Java通过new关键字来调用构造器，从而返回该类的实例，是一种特殊的方法。 申明格式123[修饰符] 类名(形参列表)&#123; ``//n条语句&#125; 方法名与类名相同 没有返回值类型，连void都没有 没有具体的返回值 例如： 1234567891011121314151617class Point &#123; double x, y; public Point(double x, double y) &#123; this.x = x; this.y = y; &#125; public double getDistance(Point p) &#123; return Math.sqrt((x - p.x) * (x - p.x) + (y - p.y) * (y - p.y)); &#125;&#125;public class TestConstructor &#123; public static void main(String[] args) &#123; Point p = new Point(3.0, 4.0); Point origin = new Point(0.0, 0.0); System.out.println(p.getDistance(origin)); &#125;&#125; 5.0//程序结果 构造方法的重载构造方法也是方法，只不过有特殊的作用而已。与普通方法一样，构造方法也可以重载。 【特别注意】 如果方法构造中形参名与属性名相同时，需要使用this关键字区分属性与形参。如下示例所示：this.id 表示属性id;id表示形参id 如果你不提供构造方法，系统会给出默认构造方法 如果你提供了构造方法，系统将不再提供【强烈推荐永远自己写一个无参构造方法】 构造方法不能递归使用（显然会一直调用自己，栈溢出） 123456789101112131415161718192021222324package classlib;public class User &#123; int id; // id String name; // 账户名 String pwd; // 密码 public User() &#123; &#125; public User(int id, String name) &#123; super(); this.id = id; this.name = name; &#125; public User(int id, String name, String pwd) &#123; this.id = id; this.name = name; this.pwd = pwd; &#125; public static void main(String[] args) &#123; User u1 = new User(); User u2 = new User(101, "WJJ"); User u3 = new User(100, "AL", "123456"); &#125;&#125; 标准案例 讲成员变量私有化 提供一个无参和所有参数的构造方法 提供setXxx和getXxx 成员方法]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this关键字]]></title>
    <url>%2F2019%2F04%2F02%2Fthis%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[对象创建过程与this的本质构造方法是创建Java对象的重要途径，通过new关键字调用构造器时，构造器也确实返回该类的对象，但这个对象并不是完全由构造器负责创建。创建一个对象分为如下四步： 分配对象空间，并将对象成员变量初始化为0或空 执行属性值的显示初始化 执行构造方法 返回对象的地址给相关的变量 this的本质就是“创建好的对象的地址”! 由于在构造方法调用前，对象已经创建。因此，在构造方法中也可以使用this代表“当前对象” 。 this最常用的用法： 在程序中产生二义性之处，应使用this来指明当前对象;普通方法中，this总是指向调用该方法的对象。构造方法中，this总是指向正要初始化的对象。 使用this关键字调用重载的构造方法，避免相同的初始化代码。但只能在构造方法中用，并且必须位于构造方法的第一句。 this不能用于static方法中。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象的内存分析]]></title>
    <url>%2F2019%2F04%2F02%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一个类的初始化过程Student s = new Student();在内存中做了哪些事情? 加载Student.class文件进内存【方法区】,并且创建对应的字节码文件 在栈内存为s开辟空间 在堆内存为学生对象开辟空间 对学生对象的成员变量进行默认初始化//0,null, 对学生对象的成员变量进行显示初始化显示初始化的意思是，类定义的时候给成员变量赋了初值例如： 12345class Person &#123; private String name="WJJ";//显示初始化 private int age=18;//显示初始化 //构造函数即getXxx(),setXxxx()&#125; 通过构造方法对学生对象的成员变量赋值 学生对象初始化完毕，把对象地址赋值给s变量 Java虚拟机的内存可以分为三个区域：栈stack、堆heap、方法区method area。* 栈的特点如下： 栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧(存储局部变量、操作数、方法出口等) JVM为每个线程创建一个栈，用于存放该线程执行方法的信息(实际参数、局部变量等) 栈属于线程私有，不能实现线程间的共享! 栈的存储特性是“先进后出，后进先出” 栈是由系统自动分配，速度快!栈是一个连续的内存空间! 总结关于栈和栈帧，我们做个小结： 每个JVM线程有一个私有栈，栈在线程创建的同时被创建。 栈由许多帧组成，也叫 “栈帧” 每次方法调用都会创建一个栈帧 换句话说，当一个Java/Scala/JVM方法被执行时： 当方法被执行时，一个新的栈帧被创建并用来给这个方法存储数据 栈帧大小各不相同，取决于方法的参数、局部变量和算法 当一个方法被执行时，程序只能访问当前栈帧中的数据，你能看到的只有栈顶的帧 Java/JVM中栈的官方定义Oracle关于栈和栈帧提供了如下描述： 每个JVM线程拥有一个私有的 Java虚拟机栈，创建线程的同时栈也被创建。一个JVM栈由许多帧组成，称之为”栈帧”。JVM中的栈和C等常见语言中的栈比较类似，都用于保存局部变量和部分计算结果，同时也参与方法调用和返回。 因此，你可以想象一下，一个栈拥有许多栈帧，如下图： 如Oracle官方说明，每个线程拥有自己的私有栈，因此在多线程应用中将有多个栈，每个栈有自己的栈帧。 Java中的栈 当一个新的线程创建时，JVM会为这个线程创建一个新的Stack。一个Java Stack在一个个独立的栈帧中存储了线程的状态。JVM只会在Java Stack中做两个操作：push 和 pop. 一个线程当前正在执行的方法称之为线程的 当前方法，当前方法对应的栈帧称为 当前帧，当前方法所属的类称为 当前类，当前类的常量池称为 当前常量池。 在执行一个方法时，JVM会保存当前类和当前常量池的轨迹。当JVM执行 需要操作栈帧中数据的指令时，JVM会在当前栈帧进行处理。 当一个线程执行一个Java方法时，JVM将创建一个新的栈帧并且把它push到栈顶。此时新的栈帧就变成了当前栈帧，方法执行时，使用栈帧来存储参数、局部变量、中间指令以及其他数据。 Java中的栈帧 栈帧由三部分组成：局部变量表、操作数栈以及帧数据。 每个方法涉及的局部变量表和操作数栈的大小取决于每个具体的方法，但是大小在编译后便已确定，而且已经包含在class文件中。 重要的是：栈帧的大小因局部变量表和操作数栈而异。书中对于size的描述如下： 当JVM执行一个方法时，它会检查class中的数据，以便确定一个方法执行时在局部变量表和操作数栈中所需存储的word size。然后，JVM会为当前方法创建一个size相对应的栈帧，然后把它push到栈顶。 Word size、操作数栈和常量池简述下 word size、operand stack(操作数栈)、constant pool(常量池)这三个短语的定义： word size：它是一个度量单位，在不同类型的JVM中，word size的大小不一定会相同。但是，它至少会有32位以保证可以存储long或double类型。 operand stack：操作数栈在 oracle.com 中被定义。捎带提一嘴，其中的定义涉及到了机器代码，例如：它展示了使用iadd指令进行两个integer的加法操作。 欢迎你深入学习这些细节，但是我们这里只想让你简单知道：操作数栈只是栈帧中的一块内存区域。 常量池：Java运行时常量时在 oracle.com 中定义. 写道：一个运行时常量池 … 包含了许多种常量，编译时的常见数值字面量、运行时需要处理的方法和字段引用等. 运行时常量池和一些编程语言中的符号表有点类似，只不过它比符号表存储的数据范围更广。 堆的特点如下： 堆用于存储创建好的对象和数组(数组也是对象) JVM只有一个堆，被所有线程共享 堆是一个不连续的内存空间，分配灵活，速度慢! 方法区(又叫静态区)特点如下： JVM只有一个方法区，被所有线程共享! 方法区实际也是堆，只是用于存储类、常量相关的信息! 来存放程序中永远是不变或唯一的内容。(类信息【Class对象】、静态变量、字符串常量、静态、非静态方法等) 内存图解1234567891011121314151617181920212223class Computer&#123; String brand;//品牌&#125;public class Stu&#123; int id; String name; int age; Computer comp; void study() &#123; System.out.println("我正在学习！使用电脑:"+comp.brand); &#125; //构造方法 Stu()&#123; &#125; public static void main(String[] args) &#123; Stu stu1=new Stu(); stu1.name="张三"; Computer comp1=new Computer(); comp1.brand="联想"; stu1.comp=comp1; stu1.study(); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类与对象]]></title>
    <url>%2F2019%2F04%2F02%2F%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[类与对象 类可以看做是一个模版，或者图纸，系统根据类的定义来造出对象。我们要造一个汽车，怎么样造?类就是这个图纸，规定了汽车的详细信息，然后根据图纸将汽车造出来。造出来的具体汽车就是对象 类：我们叫做class。 对象：我们叫做Object,instance(实例)。我们说某个类的对象，某个类的实例。是一样的意思。 定义一个类（模板） 1234567891011121314class Student&#123; //属性（成员变量） int id; String name; int age; //方法 public void study() &#123; System.out.println("我爱学习！"); &#125; //构造方法 public Student()&#123; &#125;&#125; 总结 ​ 1.对象是具体的事物;类是对对象的抽象; ​ 2.类可以看成一类对象的模板（蓝图），对象可以看成该类的一个具体实例。 ​ 3.类是用于描述同一类型的对象的一个抽象概念，类中定义了这一类对象所应具有的共同的属性、方法。 ​ 4.面向对象程序设计的重点是类的设计，而不是对象的设计。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象与面向过程]]></title>
    <url>%2F2019%2F04%2F01%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[我们千万不要把面向过程和面向对象对立起来。他们是相辅相成的。面向对象离不开面向过程! 总结 都是解决问题的思维方式，都是代码组织的方式。 解决简单问题可以使用面向过程 解决复杂问题：宏观上使用面向对象把握，微观处理上仍然是面向过程。 面向对象思考方式 遇到复杂问题，先从问题中找名词，然后确立这些名词哪些可以作为类，再根据问题需求确定的类的属性和方法，确定类之间的关系。 建议 面向对象具有三大特征：封装性、继承性和多态性，而面向过程没有继承性和多态性，并且面向过程的封装只是封装功能，而面向对象可以封装数据和功能。所以面向对象优势更明显。 对象说白了也是一种数据结构(对数据的管理模式)，将数据和数据的行为放到了一起。即将相关数据和相关方法封装到一个独立的实体 在内存上，对象就是一个内存块，存放了相关的数据集合! 对象的本质就一种数据的组织方式! 面向过程程序设计：程序=算法+数据结构（动词的集合，关注操作） 面向对象程序设计：程序=对象+消息（名次的集合） 面向过程(Procedure Oriented)面向过程思想思考问题时，我们首先思考“怎么按步骤实现?”并将步骤对应成方法，一步一步，最终完成。 这个适合简单任务，不需要过多协作的情况下。比如，如何开车?我们很容易就列出实现步骤： 发动车 2. 挂挡 3.踩油门 4. 走你 例如把大象放进冰箱,Java语言描述 12345678910111213141516public class Test &#123; public static void main(String[] args) &#123; step1(); step2(); step3(); &#125; public static void step1() &#123; System.out.println("开冰箱门"); &#125; public static void step2() &#123; System.out.println("把大象放进冰箱"); &#125; public static void step3() &#123; System.out.println("关上冰箱门"); &#125;&#125; 面向对象(Object Oriented,OO)面向过程适合简单、不需要协作的事务。 但是当我们思考比较复杂的问题，比如“如何造车?”，就会发现列出1234这样的步骤，是不可能的。那是因为，造车太复杂，需要很多协作才能完成。此时面向对象思想就应运而生了。 面向对象(Object Oriented)思想更契合人的思维模式。我们首先思考的是“怎么设计这个事物?” 比如思考造车，我们就会先思考“怎么设计车?”，而不是“怎么按步骤造车的问题”。这就是思维方式的转变。 一、面向对象思想思考造车，发现车由如下对象组成： 轮胎 发动机 车壳 座椅 挡风玻璃 为了便于协作，我们找轮胎厂完成制造轮胎的步骤，发动机厂完成制造发动机的步骤;这样，发现大家可以同时进行车的制造，最终进行组装，大大提高了效率。但是，具体到轮胎厂的一个流水线操作，仍然是有步骤的，还是离不开面向过程思想! 因此，面向对象可以帮助我们从宏观上把握、从整体上分析整个系统。 但是，具体到实现部分的微观操作(就是一个个方法)，仍然需要面向过程的思路去处理。 例如把大象放进冰箱，Java语言描述 1234567891011121314151617181920public class Test &#123; public static void main(String[] args) &#123; Fridge.open(); Elephant.in(); Fridge.close(); &#125;&#125;class Elephant&#123; public static void in() &#123;//此处用静态方法方便调用 System.out.println("放进冰箱"); &#125;&#125;class Fridge&#123; public static void open() &#123; System.out.println("打开冰箱门"); &#125; public static void close() &#123; System.out.println("关上冰箱门"); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组]]></title>
    <url>%2F2019%2F03%2F29%2F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组数组变量属引用类型，实例化的数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，数组对象本身是在堆中存储的。 数组概念 数组是存储同一种数据类型多个元素的集合。也可以看成是一个容器。 数组既可以存储基本数据类型，也可以存储引用数据类型。（对象的地址）（对象数组） 长度是确定的。数组一旦被创建，它的大小就是不可以改变的。 数组定义格式12type[] arr_name; //（推荐使用这种方式）type arr_name[]; 注意事项 ​ 1. 声明的时候并没有实例化任何对象，只有在实例化数组对象时，JVM才分配空间，这时才与长度有关。 ​ 2. 声明一个数组的时候并没有数组真正被创建。 ​ 3. 构造一个数组，必须指定长度。 数组初始化 Java中的数组必须先初始化,然后才能使用。 所谓初始化：就是为数组中的数组元素分配内存空间，并为每个数组元素赋初值。 数组的初始化方式 动态初始化：初始化时程序猿只指定数组长度，由系统为数组分配默认初始值。 123int[] a1 = new int[2];//动态初始化数组，先分配空间；a1[0]=1;//给数组元素赋值；a1[1]=2;//给数组元素赋值； 静态初始化：初始化时指定每个数组元素的初始值，由系统决定数组长度。 123int[] a=new int[]&#123;1,2,3&#125;;//完整格式,可以简化为下int[] a = &#123; 1, 2, 3 &#125;;// 静态初始化基本类型数组；注意这种方式不能先声明，再简洁初始化。Man[] mans = &#123; new Man(1, 1), new Man(2, 2) &#125;;// 静态初始化引用类型数组； 默认初始化：数组是引用类型，它的元素相当于类的实例变量（实例化的数组可以看成一个对象，数组中的每个元素相当于该对象的成员变量），因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。 123int a2[] = new int[2]; // 默认值：0,0boolean[] b = new boolean[2]; // 默认值：false,falseString[] s = new String[2]; // 默认值：null, null byte,short,int,long ：0 float,double：0.0 char：‘\u0000’ boolean：false 引用类型：null 0x0000(4字节) 但是一定要注意不能同时进行动态初始化和静态初始化。就是不能在给定数组长度的同时给出元素。 例如 1int data[]=new int[3]&#123;1,2,3&#125;;///编译错误！ 数组的内存分配12345678public class TestDemo&#123; public static void main(String[] args) &#123; int data[]=new int[3];//声明数组并分配空间 data[0]=10; data[1]=20; data[2]=30; &#125;&#125; 二维数组java中二维数组内存不是连续的，相当于一个链表，(和C语言不一样)【不建议使用】 二维数组的声明12345678910public class Test &#123; public static void main(String[] args) &#123; // Java中多维数组的声明和初始化应按从低维到高维的顺序进行 int[][] a = new int[3][]; a[0] = new int[2]; a[1] = new int[4]; a[2] = new int[3]; // int a1[][]=new int[][4];//非法 &#125;&#125; 二维数组的动态初始化1234567891011121314import java.util.Arrays;public class Test &#123; public static void main(String[] args) &#123; int[][] a = new int[3][]; // a[0] = &#123;1,2,5&#125;; //错误，没有声明类型就初始化 a[0] = new int[] &#123; 1, 2 &#125;; a[1] = new int[] &#123; 2, 2 &#125;; a[2] = new int[] &#123; 2, 2, 3, 4 &#125;; System.out.println(a[2][3]); System.out.println(Arrays.toString(a[0])); System.out.println(Arrays.toString(a[1])); System.out.println(Arrays.toString(a[2])); &#125;&#125; 二维数组的静态初始化12345678public class Test &#123; public static void main(String[] args) &#123; int[][] a = &#123; &#123; 1, 2, 3 &#125;, &#123; 3, 4 &#125;, &#123; 3, 5, 6, 7 &#125; &#125;; System.out.println(a[2][3]); &#125;&#125; 二维数组的内存分配 对象数组123456789101112131415161718192021222324class Book&#123; private String title; private double price; public Book(String t,double p) &#123; title=t; price=p; &#125; public String toString() &#123; return "titile= "+this.title+",price= "+this.price; &#125;&#125;public class Test01&#123; public static void main(String[] args) &#123; Book books[]=new Book[] &#123; new Book("Java",79.8), new Book("JSP",69.8), new Book("Android",89.8) &#125;; for(Book temp:books) &#123; System.out.println(temp); &#125; &#125;&#125; 1234程序执行结果：titile= Java,price= 79.8titile= JSP,price= 69.8titile= Android,price= 89.8]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位运算符面试问题]]></title>
    <url>%2F2019%2F03%2F28%2F%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[位运算符面试问题请用最有效率的方式写出计算2乘以8的结果答：2&lt;&lt;3 请自己实现两个整数变量的交换 法一 123int temp=a;a=b;b=temp; 法二 123a=a+b;b=a-b;a=a-b; 法三 123a=a^b;b=a^b;//b=a^b^b=a 主要利用性质 x^x=0a=a^b;//a=a^b^a=b x^0=x 法四 1a=(a+b)-(b=a);//不推荐 判断一个数是否是2的n次幂分析：2^n：素数因子只有2 法一:使用循环，若为偶数，一直除以2，最后为1，则为2^n，时间复杂度logn 法二：位运算2^n的数有一特点，转为2进制形式为：只有一个1，其余全为0，因此只需要判断二进制形式是否只有1个1 ​ a: 0000 1000 ​ a-1: 0000 0111 若a不为2^n次，则至少有2个1，例如 ​ b: 0000 1100 ​ b-1: 0000 1011 显然若a是2^n的数，则a&amp;(a-1)=0 123456class TestDemo&#123; public static void main(String[] args)&#123; int a=1024; System.out.println((a&amp;(a-1))==0); &#125;&#125; 一堆整数中都是成双存在，只有一个数是单独存在，请找出这个数？分析：因为一个整数x^x=0 ​ x^0=x 所以，相同的部分^运算后全变成了0，最后一个单独存在的^0得到本身 答：例如有数a,b,c,d,e 用a^b得到a1 a1^c得到a2 以此往复，得到的最后一个数，就是单独的数]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java变量的分类与自动类型转换]]></title>
    <url>%2F2019%2F03%2F26%2FJava%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Java变量的分类与自动类型转换变量的分类 类型 从属于 内存位置 声明位置 生命周期 局部变量 方法/语句块 栈内存（方法被调用时都会创建一个栈帧，存储局部变量等)）（没有默认初始化） 方法或者语句块内 从声明位置开始，直到方法或语句块执行完毕，局部变量消失 成员变量（实例变量） 对象 堆内存（有默认初始化） 类内部，方法外部 对象创建，成员变量也跟着创建。对象消失，成员变量也跟着消失； 静态变量（类变量） 类 方法区中的静态区（有默认初始化） 类内部，方法外部。static修饰。 类被加载，静态变量就有效；类被卸载，静态变量就消失 局部变量（local variable）方法或语句块内部定义的变量。生命周期是从声明位置开始到到方法或语句块执行完毕为止。局部变量在使用前必须先声明、初始化(赋初值)再使用。 成员变量（也叫实例变量 member variable）方法外部、类的内部定义的变量。从属于对象，生命周期伴随对象始终。如果不自行初始化，它会自动初始化成该类型的默认初始值。 数据类型 默认初始值 int 0 double 0.0 char ‘\u0000’ boolean false 静态变量（类变量 static variable） 使用static定义。 从属于类，生命周期伴随类始终，从类加载到卸载。 如果不自行初始化，与成员变量相同会自动初始化成该类型的默认初始值，如上表所示。 123456789101112public class TestVariable&#123; int a;//成员变量，从属于对象；成员变量会自动被初始化 static int size; //静态变量，从属于类 public static void main(String[] args) &#123; &#123; int age=18;//局部变量，从属于语句块 &#125; int salary=3000;//局部变量，从属于方法 int i;//局部变量，必须初始化 int j=i+5;//编译出错，变量i还未被初始化 &#125;&#125; 自动类型转换 数据范围小的数据与数据范围大的数据进行数学计算时，自动向大范围的数据类型转换后计算。（例如int和long计算，则int类型先自动变为long类型，再计算） 常量也有类型，常整数为int，常浮点数为double 12long a = 55555555; //编译成功，在int表示的范围内(2.1e9内)。long b = 55555555555;//不加L编译可通过，但是结果不正确，已经超过int表示的范围，数据溢出。 我们修改成long类型的常量即可 1long b = 55555555555L; 1234567public class Test02 &#123; public static void main(String[] args) &#123; int microPerDay=24*60*60*1000; long nanosPerDay=24*60*60*1000*1000*1000L; System.out.print(nanosPerDay/microPerDay); &#125;&#125; 输出： 15794//显然溢出了 这是因为24*60*60*1000*1000数据已经溢出，需要修改如下 1long nanosPerDay=24L*60*60*1000*1000*1000; 此时第一个数就变成long类型，计算正确 11000000//结果正确 12float f=(float)1.24;float f=1.24f; 问：这两种赋值方式一样么？ 答：不一样。 第一种方式，底层存储double类型，占8字节，再强制类型转换成float 第二种方式，底层 存储float类型，占4字节（推荐使用） 注意事项 byte,short,char参与运算的时候默认会转换成int类型，即使是统一数据类型相加也会转成int型 1234567public static void main(String[] args) &#123; byte b=10; byte c=10;//编译器会自动判断是否处于byte范围内。若属于，则编译通过 short a=10;//同理 byte d=b+c;//此处报错，Type mismatch: cannot convert from int to byte，b+c时候，自动转换成int类型 short s=b;//此处没问题&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java命名规范]]></title>
    <url>%2F2019%2F03%2F26%2FJava%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[Java命名规范只是建议 类和接口名称：每一个单词首字母大写，例如：TestDemo; 变量/方法名称：第一个单词首字母小写，之后每个单词的首字母大写，例如：studentName;printInfo();【驼峰原则】 常量名称：每个字母大写,若有多个单词，以_分割，例如：FLAG，MAX_VALUE; 包名称：所有字母小写 ​ 多级包： 域名反转，例如：www.zju.edu.cn –&gt; cn.edu.zju]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Typora快速编辑Markdown]]></title>
    <url>%2F2019%2F03%2F23%2F%E4%BD%BF%E7%94%A8Typora%E5%BF%AB%E9%80%9F%E7%BC%96%E8%BE%91Markdown%2F</url>
    <content type="text"><![CDATA[标题标题是用“#”实现的，标题前面加一个“#”，代表一级标题；依次类推，标题前面加六个“#”代表六级标题；一共有六级标题，编辑各种文档完全够用。 #+空格+标题内容 下划线快捷键Ctrl+u，即可实现下划线功能。 强调内容的前后分别加两个*号 斜体内容前后分别加一个\号* 斜体加粗*前后加3个** 删除线先转化成英文输入法，再把内容前后分别加上两个~号 特别注意是2个~ 列表有序列表输入数字“1”+“.”+”空格”，自动开始有序列表。 步骤1 步骤2 步骤3 无序列表输入“+”或者“-”或者“*”+空格，自动开始无序列表 步骤1 步骤2 步骤3 tableCtrl+T,在弹出的对话框中选择行列数，自动生成列表。还可以很方便地对表格进行编辑。 学号 姓名 成绩 xxx xxx xxx asd 分割线有时候，为了排版漂亮，可能会加入分隔线。Markdown加入分隔线非常简单，使用下面任意一种形式都可以 12***--- 插入图片插入本地图片设置主题_config.ymlpost_asset_folder: true当资源文件管理功能打开后，Hexo将会在你每一次通过hexo new post &lt;title&gt;命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个markdown文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹之中，你可以通过相对路径来引用它们，这样你就得到了一个简单而且方便很多的工作流。123&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; 例如本例中，将ZJU.jpg放到资源文件夹中。通过 1&#123;% asset_img ZJU.jpg 测试%&#125; 命令插入，其中[title]可省略 插入代码`System.out.println(“Hello World!”);`System.out.println(&quot;Hello World!&quot;);```System.out.println(“Hello Hexo”);System.out.println(“Hello World!”);``` 12System.out.println("Hello Hexo");System.out.println("Hello World!"); 行内代码引用，使用单个反引号进行包裹（Tab上面那个），代码块用三个反引号包裹。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Markdown 编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo写博客攻略]]></title>
    <url>%2F2019%2F03%2F22%2F%E4%BD%BF%E7%94%A8hexo%E5%86%99%E5%8D%9A%E5%AE%A2%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[新建文章在站点的根目录下执行以下命令：(本博客站点根目录为D:\blog\WJJ711)$ hexo new post &lt;title&gt;//此处title不需要加双引号例如$ hexo new post 使用hexo写攻略可以简写为$ hexo n &lt;title&gt;例如$ hexo n 使用hexo写攻略 给文章添加分类，标签 1 使用Subline Text 打开《使用hexo写博客攻略》 2 设置如下：12345678---title: 使用hexo写博客攻略date: 2019-03-22 19:34:50tags: - hexo - Markdown 编辑器categories: hexo--- 注意 - 后面的空格！ 3 博客正文需要在---下面撰写 一级标题使用一个#+空格+内容 二级标题使用2个#+空格+内容 三级标题使用3个#+空格+内容 设置列表Markdown支持有序列表和无序列表两种形式：无序列表用*或+或-标识有序列表用数字加.标识，例如1. 列表1 列表2 a 子列表1 b 子列表2 列表312345- 列表1- 列表2 a 子列表1 b 子列表2- 列表3 注意- 后面的空格 添加网站链接B站导航[B站导航](https://www.bilibili.com/)注意：https://不能少 插入图片插入本地图片设置主题_config.ymlpost_asset_folder: true当资源文件管理功能打开后，Hexo将会在你每一次通过hexo new post &lt;title&gt;命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个markdown文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹之中，你可以通过相对路径来引用它们，这样你就得到了一个简单而且方便很多的工作流。 123&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; 例如本例中，将ZJU.jpg放到资源文件夹中。通过1&#123;% asset_img ZJU.jpg 测试%&#125; 命令插入，其中[title]可省略注意，此处必须用```加换行的方式插入上面代码 制表语法如下：123表头|条目一|条目二:---:|:---:|:---:项目|项目一|项目二 以上标记效果显示如下： 表头 条目一 条目二 项目 项目一 项目二 语法说明 |、-、:之间多余的空格会被忽略，不影响布局。 三个短斜杠左右的冒号用于控制对齐方式，只放置左边冒号表示文字居左，只放置右边冒号表示文字居右，如果两边都放置冒号表示文字居中。 表格的语句上一行必须为空行，不然表格不生效 强调有时候，我们希望对某一部分文字进行强调，使用*或_包裹即可。使用单一符号标记的效果是斜体，使用两个符号标记的效果是加粗12345*这里是斜体*_这里是斜体_**这里是加粗**__这里是加粗__ 这里是斜体这里是斜体 这里是加粗这里是加粗 分割线有时候，为了排版漂亮，可能会加入分隔线。Markdown加入分隔线非常简单，使用下面任意一种形式都可以 12***--- 插入代码`System.out.println(“Hello World!”);`System.out.println(&quot;Hello World!&quot;);```System.out.println(“Hello Hexo”);System.out.println(“Hello World!”);```12System.out.println(&quot;Hello Hexo&quot;);System.out.println(&quot;Hello World!&quot;); 行内代码引用，使用单个反引号进行包裹（Tab上面那个），代码块用三个反引号包裹。 使用反斜杠\插入语法中用到的特殊符号在Markdown中，主要有以下几种特殊符号需要处理：123456789101112\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 例如要输出```需要1\`\`\`]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Markdown 编辑器</tag>
      </tags>
  </entry>
</search>
